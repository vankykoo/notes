# java 对象内存布局与对象头

## 一、创建对象时内存布局

在Java中，当我们创建一个对象时，该对象在JVM（Java虚拟机）中的内存布局可以分为几个重要的部分。这些部分主要包括对象头（Object Header）、实例数据（Instance Data）和对齐填充（Padding）。以下是对这些部分的详细介绍：

1. **对象头（Object Header）**：
   对象头在JVM中占据的内存包括以下两个部分：
   - **Mark Word**：用于存储对象的**哈希码（hash code）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID**等信息。Mark Word 是一个可变数据结构，其具体内容在不同状态下是不同的。
   - **Class Metadata Address**：一个指向对象的类元数据的指针。通过这个指针，JVM可以知道对象是哪个类的实例，并从类元数据中获取对象的类型信息。

2. **实例数据（Instance Data）**：
   实例数据是对象的实际数据字段。包括父类继承下来的字段以及对象自己定义的字段。实例数据按照字段声明的顺序存储，但具体的顺序可能会因为字段对齐而有所调整。

3. **对齐填充（Padding）**：
   JVM的对象内存布局要求对象的起始地址必须是8字节的整数倍（某些JVM实现可能要求是16字节）。因此，在对象头和实例数据之后，可能会存在一些填充字节，以确保下一个对象的起始地址符合对齐要求。

具体来说，对象的内存布局可以表示如下：

```
| Object Header (Mark Word + Class Metadata Address) | Instance Data (Fields) | Padding |
```

### 内存布局总结

- **对象头**：包含Mark Word和类元数据指针，占用固定大小。
- **实例数据**：包含对象的字段，根据字段类型和对齐要求排列。
- **对齐填充**：用于满足对象的对齐要求。

了解对象的内存布局有助于优化Java程序的性能，特别是在高性能应用中。



## 二、Markword

在JVM中，`Mark Word` 是对象头的一部分，存储着关于对象的运行时信息。`Mark Word` 的内容会根据对象的状态动态变化（例如：是否锁定、是否处于垃圾回收标记阶段等）。以下是`Mark Word`在不同状态下的内存分布情况：

### 1. 默认状态（未锁定）
在64位JVM中，`Mark Word`通常占用64位（8字节）。在默认状态下，其内容包括以下部分：

- **unused**：25位
- **identity_hashcode**：31位（哈希码）
- **unused**：1位
- **age**：4位（对象的GC年龄）
- **biased_lock**：1位（是否启用偏向锁）
- **lock**：2位（锁标志位）

内存分布如下：

| 63-39  | 38-7              | 6      | 5-2  | 1           | 0    |
| ------ | ----------------- | ------ | ---- | ----------- | ---- |
| unused | identity_hashcode | unused | age  | biased_lock | lock |

### 2. 偏向锁状态
当对象处于偏向锁状态时，`Mark Word`会存储偏向锁相关的信息：

- **thread_id**：54位（线程ID）
- **epoch**：2位（时间戳）
- **age**：4位（对象的GC年龄）
- **biased_lock**：1位（是否启用偏向锁）
- **lock**：2位（锁标志位）

内存分布如下：

| 63-9      | 8-6   | 5-2  | 1           | 0    |
| --------- | ----- | ---- | ----------- | ---- |
| thread_id | epoch | age  | biased_lock | lock |

### 3. 轻量级锁状态
在轻量级锁状态下，`Mark Word`指向栈中的锁记录（Lock Record）的起始地址：

- **ptr_to_lock_record**：62位（指向栈中锁记录的指针）
- **lock**：2位（锁标志位）

内存分布如下：

| 63-2               | 1-0  |
| ------------------ | ---- |
| ptr_to_lock_record | lock |

### 4. 重量级锁状态
在重量级锁状态下，`Mark Word`指向监视器（Monitor）的起始地址：

- **ptr_to_monitor**：62位（指向监视器的指针）
- **lock**：2位（锁标志位）

内存分布如下：

| 63-2           | 1-0  |
| -------------- | ---- |
| ptr_to_monitor | lock |

### 5. GC标记状态
在GC标记阶段，`Mark Word`可能会用来存储GC标记信息。这种状态下的内存分布视具体的GC实现而定。

### 6. 总结
`Mark Word`在对象头中存储了丰富的信息，其内容根据对象的状态动态变化。了解`Mark Word`的内存分布有助于深入理解Java对象的管理机制，特别是在锁机制和垃圾回收方面。以下是一个简单的汇总表格：

| 状态   | 内容                                       |
| ---- | ---------------------------------------- |
| 默认   | unused (25位) + identity_hashcode (31位) + unused (1位) + age (4位) + biased_lock (1位) + lock (2位) |
| 偏向锁  | thread_id (54位) + epoch (2位) + age (4位) + biased_lock (1位) + lock (2位) |
| 轻量级锁 | ptr_to_lock_record (62位) + lock (2位)     |
| 重量级锁 | ptr_to_monitor (62位) + lock (2位)         |

通过这些信息，JVM可以高效地管理对象的状态和同步机制。



## 三、压缩指针

压缩指针（Compressed Oops）是JVM中的一种技术，用于在64位JVM中优化内存使用。Oops是"Ordinary Object Pointers"的缩写，指的是普通对象指针。在64位系统中，指针通常占用8字节（64位），而压缩指针将其压缩为4字节（32位），从而减少内存占用，提高缓存利用率。以下是关于压缩指针的详细介绍：

### 为什么使用压缩指针？

在64位JVM中，指针默认占用8字节，而对象引用（指针）在32位JVM中只占4字节。虽然64位地址空间更大，但对于大多数应用程序来说，这么大的地址空间通常用不到。因此，使用压缩指针可以有效地减少内存占用，带来以下几个好处：

1. **降低内存消耗**：对象引用的大小减半，减少了内存占用，尤其是在大量对象存在时效果显著。
2. **提高缓存效率**：更少的内存占用意味着更高的缓存命中率，从而提高性能。
3. **减少垃圾回收开销**：压缩指针减少了堆中对象的大小，从而减少了垃圾回收的工作量。

### 压缩指针的工作原理

压缩指针的实现涉及指针的压缩和解压缩过程。在JVM中，指针压缩和解压缩的过程如下：

1. **压缩（存储引用时）**：将64位对象引用转换为32位的压缩引用。通常，压缩引用是通过去掉对象引用中的一些高位来实现的，因为在实际应用中，绝大部分对象的地址不会用到完整的64位地址空间。

2. **解压缩（读取引用时）**：将32位的压缩引用还原为64位的对象引用。这通常是通过将压缩引用左移一定的位数并加上一个基址（base address）来实现的。

### 启用和配置压缩指针

在HotSpot JVM中，压缩指针默认是启用的，除非堆内存大小超过32GB。可以通过以下JVM选项来配置压缩指针：

- `-XX:+UseCompressedOops`：启用压缩指针（默认启用）。
- `-XX:-UseCompressedOops`：禁用压缩指针。
- `-XX:+UseCompressedClassPointers`：启用压缩类指针，用于压缩类元数据指针。
- `-XX:ObjectAlignmentInBytes`：设置对象对齐粒度（通常是8字节）。

### 注意事项

1. **地址空间限制**：启用压缩指针后，JVM的堆内存大小限制在32GB以内。
2. **性能影响**：压缩和解压缩指针需要一定的计算开销，但通常这个开销相对于内存节省和缓存效率的提升是可以接受的。
3. **对象对齐**：对象在堆内存中的对齐粒度通常为8字节（可通过`-XX:ObjectAlignmentInBytes`调整）。

### 总结

压缩指针是一种在64位JVM中减少内存占用、提高性能的优化技术。通过将64位对象引用压缩为32位，压缩指针在不影响程序正确性的情况下显著降低了内存使用，并提升了缓存效率。启用压缩指针对于大多数Java应用程序来说，尤其是那些需要大量对象引用的场景，是一种非常有益的优化手段。