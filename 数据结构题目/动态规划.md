# 动态规划

##零、介绍

五步：

1. 确定dp数组（dp table）以及下标的含义。
2. 确定递推公式
3. dp数组如何初始化
4. 确定遍历顺序
5. 举例推导dp数组






## 一、斐波那契数

### 题目

![](https://raw.githubusercontent.com/vankykoo/javaStudy/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E9%A2%98%E7%9B%AE/dp/130.png)



### 思路

#### 1.递归



#### 2.动态规划

①**确定dp数组以及下标的含义**：第i个数的斐波那契数值是dp[i]

②**确定递推公式**：状态转移方程 dp[i] = dp[i - 1] + dp[i - 2];

③**dp数组如何初始化**：dp[0] = 0; dp[1] = 1;

④**确定遍历顺序**：从前往后

⑤打印dp数组：用于debug



### 代码

#### 1.递归

```java
class Solution {
    public int fib(int n) {
        if(n <= 1){
            return n;
        }

        return fib(n - 1) + fib(n - 2);
    }
}
```



#### 2.动态规划

```java
class Solution {
    public int fib(int n) {
        if (n <= 1) return n;             
        int[] dp = new int[n + 1];
        dp[0] = 0;
        dp[1] = 1;
        for (int index = 2; index <= n; index++){
            dp[index] = dp[index - 1] + dp[index - 2];
        }
        return dp[n];
    }
}
```

#### 3.动态规划（推荐）

```java
//只需要维护dp数组的两个元素
class Solution {
    public int fib(int n) {
        if(n < 2) return n;

        int[] dp = new int[2];
        dp[0] = 0;
        dp[1] = 1;
        for(int i = 2;i <= n; i++){
            int sum = dp[0] + dp[1];
            dp[0] = dp[1];
            dp[1] = sum; 
        }

        return dp[1];
    }
}
```





## 二、爬楼梯

### 题目



### 思路

①**确定dp数组以及下标的定义**：dp[i]： 爬到第i层楼梯，有dp[i]种方法

②**确定递推公式：**

从dp[i]的定义可以看出，dp[i] 可以有两个方向推出来。

首先是dp[i - 1]，上i-1层楼梯，有dp[i - 1]种方法，那么再一步跳一个台阶不就是dp[i]了么。

还有就是dp[i - 2]，上i-2层楼梯，有dp[i - 2]种方法，那么再一步跳两个台阶不就是dp[i]了么。

那么dp[i]就是 dp[i - 1]与dp[i - 2]之和！

所以dp[i] = dp[i - 1] + dp[i - 2] 

③初始化dp数组：dp[0]不管，dp[1] = 1; dp[2] = 2;相当于爬到第i层有dp[i]种方法。

④遍历顺序：从前往后

⑤打印dp数组：![](https://code-thinking-1253855093.file.myqcloud.com/pics/20210105202546299.png)



### 代码

```java
class Solution {
    public int climbStairs(int n) {
        if(n <= 2) return n;

        int[] dp = new int[n + 1];
        dp[1] = 1;
        dp[2] = 2;
        for(int i = 3; i <= n; i++){
            dp[i] = dp[i - 1] + dp[i - 2];
        }

        return dp[n];
    }
}
```



```java
// 用变量记录代替数组
class Solution {
    public int climbStairs(int n) {
        if(n <= 2) return n;
        int a = 1, b = 2, sum = 0;

        for(int i = 3; i <= n; i++){
            sum = a + b;  // f(i - 1) + f(i - 2)
            a = b;        // 记录f(i - 1)，即下一轮的f(i - 2)
            b = sum;      // 记录f(i)，即下一轮的f(i - 1)
        }
        return b;
    }
}
```



## 三、使用最小花费爬楼梯

### 题目

![](https://raw.githubusercontent.com/vankykoo/javaStudy/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E9%A2%98%E7%9B%AE/dp/135.png)

### 思路

①dp[i]数组含义：爬到第i层需要花费的最小费用

②确定递推公式：

**可以有两个途径得到dp[i]，一个是dp[i-1] 一个是dp[i-2]**。

dp[i - 1] 跳到 dp[i] 需要花费 dp[i - 1] + cost[i - 1]。

dp[i - 2] 跳到 dp[i] 需要花费 dp[i - 2] + cost[i - 2]。

那么究竟是选从dp[i - 1]跳还是从dp[i - 2]跳呢？

一定是选最小的，所以dp[i] = min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);

③dp数组初始化：dp[0] = 0;  dp[1] = 0;

④确定遍历顺序：从前往后

⑤打印dp数组：![](https://code-thinking-1253855093.file.myqcloud.com/pics/20221026175104.png)



### 代码

```java
class Solution {
    public int minCostClimbingStairs(int[] cost) {
        int len = cost.length;
        int[] dp = new int[len + 1];

        // 从下标为 0 或下标为 1 的台阶开始，因此支付费用为0
        dp[0] = 0;
        dp[1] = 0;

        // 计算到达每一层台阶的最小费用
        for (int i = 2; i <= len; i++) {
            dp[i] = Math.min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);
        }

        return dp[len];
    }
}
```





## 四、不同路径

### 题目

![](https://raw.githubusercontent.com/vankykoo/javaStudy/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E9%A2%98%E7%9B%AE/dp/134.png)





### 思路

动态规划：

①dp数组的含义，dp\[i][j]表示走到（i，j）有dp\[i][j]种路径。

②递推公式：dp\[i][j] = dp\[i - 1][j] - dp\[i][j - 1];

③初始化数组：第一行和第一列都为1.

④遍历顺序：从头开始一层一层遍历

⑤打印dp数组：debug时用。



### 代码

```java
lass Solution {
    public int uniquePaths(int m, int n) {
        int[][] dp = new int[m][n];
        //初始化dp数组
        for(int i = 0; i < m; i++){
            dp[i][0] = 1;
        }
        for(int i = 0; i < n; i++){
            dp[0][i] = 1;
        }
        
        for(int i = 1; i < m; i++){
            for(int j = 1; j < n; j++){
                //递推公式
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
            }
        }

        return dp[m - 1][n - 1];
    }
}
```



## 五、不同路径Ⅱ

### 题目

![](https://raw.githubusercontent.com/vankykoo/javaStudy/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E9%A2%98%E7%9B%AE/dp/136.png)



### 思路

①dp\[i][j]的含义：到达（i+1，j+1）的路径有dp\[i][j]种。

②递推公式：如果当前位置为障碍物（`obstacleGrid[i][j] == 1`）时，就把dp\[i][j]赋值为0；如果没有障碍物，就和上一题一样，

`dp[i][j] = dp[i - 1][j] + dp[i][j - 1]`

③初始化dp数组：只需要初始化第一行和第一列，如果遇到障碍物，那么障碍物后面的数值都为零，否则都为1.

④遍历顺序：逐层遍历

⑤打印dp数组



### 代码

```java
class Solution {
    public int uniquePathsWithObstacles(int[][] obstacleGrid) {
        int m = obstacleGrid.length;
        int n = obstacleGrid[0].length;
        if(obstacleGrid[0][0] == 1){
            return 0;
        }

        int[][] dp = new int[m][n];

        //初始化
        dp[0][0] = 1;
        for(int i = 1; i < m; i++){
            if(obstacleGrid[i][0] == 1){
                for(; i < m; i++){
                    dp[i][0] = 0;
                }
            }else{
                dp[i][0] = 1;
            }
        }
        for(int i = 1; i < n; i++){
            if(obstacleGrid[0][i] == 1){
                for(; i < n; i++){
                    dp[0][i] = 0;
                }
            }else{
                dp[0][i] = 1;
            }
        }

        //递推公式
        for(int i = 1; i < m; i++){
            for(int j = 1; j < n; j++){
                if(obstacleGrid[i][j] == 1){
                    dp[i][j] = 0;
                }else{
                    dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
                }
            }
        }

        return dp[m - 1][n - 1];
    }
}
```



### 答案代码

```java
class Solution {
    public int uniquePathsWithObstacles(int[][] obstacleGrid) {
        int m = obstacleGrid.length;
        int n = obstacleGrid[0].length;
        int[][] dp = new int[m][n];

        //如果在起点或终点出现了障碍，直接返回0
        if (obstacleGrid[m - 1][n - 1] == 1 || obstacleGrid[0][0] == 1) {
            return 0;
        }

        for (int i = 0; i < m && obstacleGrid[i][0] == 0; i++) {
            dp[i][0] = 1;
        }
        for (int j = 0; j < n && obstacleGrid[0][j] == 0; j++) {
            dp[0][j] = 1;
        }

        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                dp[i][j] = (obstacleGrid[i][j] == 0) ? dp[i - 1][j] + dp[i][j - 1] : 0;
            }
        }
        return dp[m - 1][n - 1];
    }
}
```





## 六、整数拆分

### 题目

![](https://raw.githubusercontent.com/vankykoo/javaStudy/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E9%A2%98%E7%9B%AE/dp/139.png)



### 解法一：动态规划

![](https://raw.githubusercontent.com/vankykoo/javaStudy/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E9%A2%98%E7%9B%AE/dp/140.png)

```java
class Solution {
    public int integerBreak(int n) {
        int[] dp = new int[n + 1];
        for (int i = 2; i <= n; i++) {
            int curMax = 0;
            for (int j = 1; j < i; j++) {
                curMax = Math.max(curMax, Math.max(j * (i - j), j * dp[i - j]));
            }
            dp[i] = curMax;
        }
        return dp[n];
    }
}
```





### 解法二：数学

K神解法：

![](https://raw.githubusercontent.com/vankykoo/javaStudy/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E9%A2%98%E7%9B%AE/dp/141.png))



> 如果最优乘积包含因子 f >= 4，则可以将其替换为因子 2 和 f-2，而不会丢失最优性，因为 2*（f-2） = 2f-4 >= f。所以你永远不需要大于或等于 4 的因子，这意味着你只需要因子 1、2 和 3（1 当然是浪费，你只会在需要的地方将它用于 n=2 和 n=3）。
>
> 对于其余的我同意，3*3 只是比*2 2*2 好，所以你永远不会使用 2 超过两次。

```java
class Solution {
    public int integerBreak(int n) {
        if(n <= 3) return n - 1;
        int a = n / 3, b = n % 3;
        if(b == 0) return (int)Math.pow(3, a);
        if(b == 1) return (int)Math.pow(3, a - 1) * 4;
        return (int)Math.pow(3, a) * 2;
    }
}
```





## 七、不同的二叉搜索树

### 题目

![](https://raw.githubusercontent.com/vankykoo/javaStudy/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E9%A2%98%E7%9B%AE/dp/149.png)



### 思路

①dp[i]的含义：表示如果有i个节点，可以组成dp[i]种二叉搜索树。

②递推公式：就是看根结点的左子树有多少种可能，右子树有多少种可能，然后相乘即可。而左右子树是从dp数组前面的元素推出来的，所有用动态规划。

即`dp[i] = dp[比i小的个数]  *  dp[比i大的个数]`

③dp数组的初始化：只需要dp[0] = 1即可；

④遍历顺序：很容易想到是从前往后。

⑤打印dp数组。



### 代码

```java
class Solution {
    public int numTrees(int n) {
        int[] dp = new int[n + 1];
        dp[0] = 1;

        for(int i = 1; i <= n; i++){
            int sum = 0;
          //求以不同根结点可构成的二叉搜索树的和
            for(int j = 1; j <= i; j++){
              //左子树
                int left = dp[j - 1];
              //右子树
                int right = dp[i - j];
                sum += left * right;
            }
            dp[i] = sum;
        }

        return dp[n];
    }
}
```





## 八、01背包问题理论

背包分类：

![](https://code-thinking-1253855093.file.myqcloud.com/pics/20210117171307407.png)



### 1）介绍

**定义**：有n件物品和一个最多能背重量为w 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。**每件物品只能用一次**，求解将哪些物品装入背包里物品价值总和最大。



### 2）二维数组

①dp\[i][j]的含义：**dp\[i][j] 表示从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少**。【物品i在容量为j的背包下，放和不放所能取到的最大价值】

②递推公式：

- **不放物品i**：由dp\[i - 1][j]推出，即背包容量为j，里面不放物品i的最大价值，此时dp\[i][j]就是dp\[i - 1][j]。(其实就是当物品i的重量大于背包j的重量时，物品i无法放进背包中，所以背包内的价值依然和前面相同。)
- **放物品i**：由dp\[i - 1][j - weight[i]]推出，dp\[i - 1][j - weight[i]] 为背包容量为j - weight[i]的时候不放物品i的最大价值，那么dp\[i - 1][j - weight[i]] + value[i] （物品i的价值），就是背包放物品i得到的最大价值

所以递归公式： **dp\[i][j] = max(dp\[i - 1][j], dp\[i - 1][j - weight[i]] + value[i]);**

③dp数组初始化：

![](https://code-thinking-1253855093.file.myqcloud.com/pics/20210110103003361.png)

* 只初始化第一行和第一列
  * 第一列：全为0
  * 第一行：从物品0对应的重量开始填上物品0的价格，其他为0。



④遍历方向：双层for循环，其实谁在内层外层都可以，因为当前数据之和当前数据的上面和左上方的数据有关。



### 代码

```java
public class BagProblem {
    public static void main(String[] args) {
        int[] weight = {1,3,4};
        int[] value = {15,20,30};
        int bagSize = 4;
        testWeightBagProblem(weight,value,bagSize);
    }

    /**
     * 动态规划获得结果
     * @param weight  物品的重量
     * @param value   物品的价值
     * @param bagSize 背包的容量
     */
    public static void testWeightBagProblem(int[] weight, int[] value, int bagSize){

        // 创建dp数组
        int goods = weight.length;  // 获取物品的数量
        int[][] dp = new int[goods][bagSize + 1];

        // 初始化dp数组
        // 创建数组后，其中默认的值就是0
        for (int j = weight[0]; j <= bagSize; j++) {
            dp[0][j] = value[0];
        }

        // 填充dp数组
        for (int i = 1; i < weight.length; i++) {
            for (int j = 1; j <= bagSize; j++) {
                if (j < weight[i]) {
                    /**
                     * 当前背包的容量都没有当前物品i大的时候，是不放物品i的
                     * 那么前i-1个物品能放下的最大价值就是当前情况的最大价值
                     */
                    dp[i][j] = dp[i-1][j];
                } else {
                    /**
                     * 当前背包的容量可以放下物品i
                     * 那么此时分两种情况：
                     *    1、不放物品i
                     *    2、放物品i
                     * 比较这两种情况下，哪种背包中物品的最大价值最大
                     */
                    dp[i][j] = Math.max(dp[i-1][j] , dp[i-1][j-weight[i]] + value[i]);
                }
            }
        }

        // 打印dp数组
        for (int i = 0; i < goods; i++) {
            for (int j = 0; j <= bagSize; j++) {
                System.out.print(dp[i][j] + "\t");
            }
            System.out.println("\n");
        }
    }
}
```



### 3）滚动数组-一维数组

在二维数组的递推公式中：

`dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);`

可以看出dp[i]只与dp[i - 1]有关，所以可以只用一维数组来表示，把上一层的数组复制下来（滚动）。



①dp[j]的含义：容量为j的背包，可以装的最大价值为dp[j]

②递推公式：`dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);` 就是消去了i - 1 的部分

③初始化：都初始化为小于等于零的数就行

④遍历顺序：双层for循环，先遍历物品，再遍历背包容量，遍历背包容量时倒序遍历。

```java
for(int i = 0; i < weight.size(); i++) { // 遍历物品
    for(int j = bagWeight; j >= weight[i]; j--) { // 遍历背包容量
        dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);

    }
}
```

* 如果正序遍历：遍历背包容量时，就可能放入相同物品
* 如果先遍历背包容量：那么每个背包里就只会有一种物品且为1个

⑤打印dp数组：![](https://code-thinking-1253855093.file.myqcloud.com/pics/20210110103614769.png)



###代码

```java
    public static void main(String[] args) {
        int[] weight = {1, 3, 4};
        int[] value = {15, 20, 30};
        int bagWight = 4;
        testWeightBagProblem(weight, value, bagWight);
    }

    public static void testWeightBagProblem(int[] weight, int[] value, int bagWeight){
        int wLen = weight.length;
        //定义dp数组：dp[j]表示背包容量为j时，能获得的最大价值
        int[] dp = new int[bagWeight + 1];
        //遍历顺序：先遍历物品，再遍历背包容量
        for (int i = 0; i < wLen; i++){
            for (int j = bagWeight; j >= weight[i]; j--){
                dp[j] = Math.max(dp[j], dp[j - weight[i]] + value[i]);
            }
        }
        //打印dp数组
        for (int j = 0; j <= bagWeight; j++){
            System.out.print(dp[j] + " ");
        }
    }
```





## 九、分割等和子集

### 题目

![](https://raw.githubusercontent.com/vankykoo/javaStudy/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E9%A2%98%E7%9B%AE/dp/158.png))



### 思路

**可以看出01背包问题：**

- 背包的体积为sum / 2
- 背包要放入的商品（集合里的元素）重量为 元素的数值，价值也为元素的数值
- 背包如果正好装满，说明找到了总和为 sum / 2 的子集。
- 背包中每一个元素是不可重复放入。



①dp[j]含义：**背包总容量（所能装的总重量）是j，放进物品后，背的最大重量为dp[j]**。

②递推公式：dp[j] = max(dp[j], dp[j - nums[i]] + nums[i]);

③初始化dp数组：都初始化为0

④遍历顺序：物品遍历的for循环放在外层，遍历背包的for循环放在内层，内层for循环**倒序遍历**

⑤打印dp数组：![](https://code-thinking-1253855093.file.myqcloud.com/pics/20210110104240545.png)



### 代码

```java
class Solution {
    public boolean canPartition(int[] nums) {
        if(nums == null || nums.length == 0) return false;
        int n = nums.length;
        int sum = 0;
        for(int num : nums) {
            sum += num;
        }
        //总和为奇数，不能平分
        if(sum % 2 != 0) return false;
        int target = sum / 2;
        int[] dp = new int[target + 1];
        for(int i = 0; i < n; i++) {
            for(int j = target; j >= nums[i]; j--) {
                //物品 i 的重量是 nums[i]，其价值也是 nums[i]
                dp[j] = Math.max(dp[j], dp[j - nums[i]] + nums[i]);
            }
           
            //剪枝一下，每一次完成內層的for-loop，立即檢查是否dp[target] == target，優化時間複雜度（26ms -> 20ms）
            if(dp[target] == target)
                return true;
        }
        return dp[target] == target;
    }
}
```



## 十、最后一块石头的重量Ⅱ

### 题目

![](https://raw.githubusercontent.com/vankykoo/javaStudy/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E9%A2%98%E7%9B%AE/dp/182.png))

### 思路

总体思路：尽量让石头分成重量相同的两堆，相撞之后剩下的石头最小。

动态规划五部曲：

①dp[j]的含义：容量为j的背包可以背的最大重量为dp[j]

②递推公式：和01背包一样，**dp[j] = max(dp[j], dp[j - stones[i]] + stones[i]);**

③dp数组初始化：尽量分成重量相同的两堆石头，其实就是让最大容量为石头总重量的二分之一，

题目提示有1 <= stones.length <= 30，1 <= stones[i] <= 1000，所以最大重量就是30 * 1000 。

而我们要求的target其实只是最大重量的一半，所以dp数组开到15000大小就可以了。里面的数值都初始化为0即可。

④遍历顺序：和01背包滚动数组相同，先遍历物品在遍历背包，内层倒序遍历。

⑤打印dp数组：

![](https://code-thinking-1253855093.file.myqcloud.com/pics/20210121115805904.jpg)

相撞之后剩下的最小石头重量就是 (sum - dp[target]) - dp[target]

### 代码

```java
class Solution {
    public int lastStoneWeightII(int[] stones) {
        int sum = 0;
        for (int i : stones) {
            sum += i;
        }
        int target = sum >> 1;
        //初始化dp数组
        int[] dp = new int[target + 1];
        for (int i = 0; i < stones.length; i++) {
            //采用倒序
            for (int j = target; j >= stones[i]; j--) {
                //两种情况，要么放，要么不放
                dp[j] = Math.max(dp[j], dp[j - stones[i]] + stones[i]);
            }
        }
        return sum - 2 * dp[target];
    }
}
```





## 十一、目标和

### 题目

![](https://raw.githubusercontent.com/vankykoo/javaStudy/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E9%A2%98%E7%9B%AE/dp/185.png)



### 思路

题目转化为：数字前面是负号的数字的数量种类和

背包容量：数字前面是负号的数字的和neg = sum - target / 2，如果sum - target不是偶数，可以直接返回0，因为根本凑不出一种方案。

如果sum - target 小于零  ，也凑不出，即使全是正号，也不够，直接返回0。

![](https://raw.githubusercontent.com/vankykoo/javaStudy/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E9%A2%98%E7%9B%AE/dp/184.png)



### 代码

```java
//滚动数组
class Solution {
    public int findTargetSumWays(int[] nums, int target) {
        int sum = 0;
        for (int num : nums) {
            sum += num;
        }
        int diff = sum - target;
        if (diff < 0 || diff % 2 != 0) {
            return 0;
        }
        int neg = diff / 2;
        int[] dp = new int[neg + 1];
        dp[0] = 1;
        for (int num : nums) {
            for (int j = neg; j >= num; j--) {
                dp[j] += dp[j - num];
            }
        }
        return dp[neg];
    }
}
```



```java
//二维数组
class Solution {
    public int findTargetSumWays(int[] nums, int target) {
        int sum = 0;
        for (int num : nums) {
            sum += num;
        }
        int diff = sum - target;
        if (diff < 0 || diff % 2 != 0) {
            return 0;
        }
        int n = nums.length, neg = diff / 2;
        int[][] dp = new int[n + 1][neg + 1];
        dp[0][0] = 1;
        for (int i = 1; i <= n; i++) {
            int num = nums[i - 1];
            for (int j = 0; j <= neg; j++) {
                dp[i][j] = dp[i - 1][j];
                if (j >= num) {
                    dp[i][j] += dp[i - 1][j - num];
                }
            }
        }
        return dp[n][neg];
    }
}
```



## 十二、一和零

### 题目

![](https://raw.githubusercontent.com/vankykoo/javaStudy/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E9%A2%98%E7%9B%AE/dp/186.png)

### 思路

本题中 strs 数组里的元素就是物品，每个物品都是一个。

而m 和 n 相当于是一个背包，两个维度的背包。

动规五部曲：

①dp\[i][j]含义：最多有i个0和j个1的strs的最大子集的大小为dp\[i][j]。

②确定递推公式：`dp[i][j] = max(dp[i][j], dp[i - zeroNum][j - oneNum] + 1);`

③初始化：还是用类似滚动数组的做法，初始化为0。

④确定遍历顺序：外层遍历物品，内层遍历背包，且内层倒序遍历。

⑤打印dp数组：![](https://code-thinking-1253855093.file.myqcloud.com/pics/20210120111201512.jpg)



### 代码

```java
class Solution {
    public int findMaxForm(String[] strs, int m, int n) {
        //dp[i][j]表示i个0和j个1时的最大子集
        int[][] dp = new int[m + 1][n + 1];
        int oneNum, zeroNum;
        for (String str : strs) {
            oneNum = 0;
            zeroNum = 0;
            for (char ch : str.toCharArray()) {
                if (ch == '0') {
                    zeroNum++;
                } else {
                    oneNum++;
                }
            }
            //倒序遍历
            for (int i = m; i >= zeroNum; i--) {
                for (int j = n; j >= oneNum; j--) {
                    dp[i][j] = Math.max(dp[i][j], dp[i - zeroNum][j - oneNum] + 1);
                }
            }
        }
        return dp[m][n];
    }
}
```



## 十三、完全背包理论基础

* 和01背包的唯一不同，就是每种物品可以放无限件。

* 所以在遍历背包的时候，需要正序遍历。

* 可以先遍历背包再遍历物品，也可以先遍历物品再遍历背包。

  * 先遍历物品![](https://code-thinking-1253855093.file.myqcloud.com/pics/20210126104529605.jpg)

  * 先遍历背包

    ![](https://code-thinking-1253855093.file.myqcloud.com/pics/20210729234011.png)



```java
//先遍历物品，再遍历背包
private static void testCompletePack(){
    int[] weight = {1, 3, 4};
    int[] value = {15, 20, 30};
    int bagWeight = 4;
    int[] dp = new int[bagWeight + 1];
    for (int i = 0; i < weight.length; i++){ // 遍历物品
        for (int j = weight[i]; j <= bagWeight; j++){ // 遍历背包容量
            dp[j] = Math.max(dp[j], dp[j - weight[i]] + value[i]);
        }
    }
    for (int maxValue : dp){
        System.out.println(maxValue + "   ");
    }
}

//先遍历背包，再遍历物品
private static void testCompletePackAnotherWay(){
    int[] weight = {1, 3, 4};
    int[] value = {15, 20, 30};
    int bagWeight = 4;
    int[] dp = new int[bagWeight + 1];
    for (int i = 1; i <= bagWeight; i++){ // 遍历背包容量
        for (int j = 0; j < weight.length; j++){ // 遍历物品
            if (i - weight[j] >= 0){
                dp[i] = Math.max(dp[i], dp[i - weight[j]] + value[j]);
            }
        }
    }
    for (int maxValue : dp){
        System.out.println(maxValue + "   ");
    }
}
```





## 十四、零钱兑换

### 题目

![](https://raw.githubusercontent.com/vankykoo/javaStudy/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E9%A2%98%E7%9B%AE/dp/187.png)



### 思路

动规五部曲：

①dp[j]的含义：找零j元钱有dp[j]种方法

②递推公式：**dp[j] += dp[j - coins[i]]**

![](https://raw.githubusercontent.com/vankykoo/javaStudy/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E9%A2%98%E7%9B%AE/dp/188.png)

③初始化：dp[0]初始化为0；意思就需要是找零的钱和零钱数是相等的时候，总是1种。就是用相同的钱去换一张相同的钱。

④遍历顺序：两层for循环，都是从前往后。这样才能找零多张。



### 代码

```java
class Solution {
    public int change(int amount, int[] coins) {
        int len = coins.length;
        int[] dp = new int[amount + 1];

        dp[0] = 1;

        for(int i = 0; i < len; i++){
            for(int j = coins[i]; j <= amount; j++){
                dp[j] += dp[j - coins[i]];
            }
        }

        return dp[amount];
    }
}
```





## 十五、组合总和Ⅳ

### 题目

![](https://raw.githubusercontent.com/vankykoo/javaStudy/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E9%A2%98%E7%9B%AE/dp/190.png)



### 思路

动规五部曲：

①dp[i]的含义：target为i的组合数有dp[i]种。

②递推公式：分别以nums数组的每个数开头，把每种组合数加起来。

比如：target = 3时，以1 开头，后面就是 2，看看2有几种组合；以 2开头，差1，看看1有几种组合；以3 开头，差 0，零的组合只有一种。

所以：dp[i] = dp[i - nums[j]];

③初始化：dp[0] = 1；表示 nums 中是否有只用一个数就能组成target的，就是看nums中有没有target值。

④遍历顺序：外层遍历背包，内层遍历nums数组，从前向后。

> **如果求组合数就是外层for循环遍历物品，内层for遍历背包**。
>
> **如果求排列数就是外层for遍历背包，内层for循环遍历物品**。

⑤打印dp数组：

![](https://code-thinking-1253855093.file.myqcloud.com/pics/20230310000625.png)



###代码

```java
class Solution {
    public int combinationSum4(int[] nums, int target) {
        int len = nums.length;
        int[] dp = new int[target + 1];
      //初始化
        dp[0] = 1;

        for(int i = 1; i <= target; i++){
            for(int j = 0; j < len; j++){
                if(i >= nums[j]){
                    dp[i] += dp[i - nums[j]];
                }
            }
        }

        return dp[target];
    }
}
```





## 十六、爬楼梯（完全背包解法）

### 题目

![](https://raw.githubusercontent.com/vankykoo/javaStudy/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E9%A2%98%E7%9B%AE/dp/201.png)

### 思路

和上一题一样，此时的物品只有两个：1和2，背包大小就是要上的台阶数

动规五部曲：

①dp[i]的含义：爬i个台阶有dp[i]种方法

②递推公式：和之前不是背包问题的时候的思路差不多，就是到达前面两阶的方法相加。

dp[i] += dp[i - j] 	j是1和2

③初始化dp数组：dp[0] = 1;

④遍历顺序：完全背包问题，双层遍历，且都是正序

⑤打印dp数组



### 代码

```java
class Solution {
    public int climbStairs(int n) {
        int[] dp = new int[n + 1];
        dp[0] = 1;

        for(int i = 1; i < n + 1; i++){
            for(int j = 1; j <= 2; j++){
                if(i - j >= 0){
                    dp[i] += dp[i - j];
                }
            }
        }

        return dp[n];
    }
}
```





## 十七、零钱兑换

### 题目

![](https://raw.githubusercontent.com/vankykoo/javaStudy/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E9%A2%98%E7%9B%AE/dp/203.png)

### 我的代码

初始化出了问题，出现很多不必要的判断，应该初始化为最大值

而且第二层循环应该遍历钱币的，我两层都遍历了背包。。。。

```java
class Solution {
    public int coinChange(int[] coins, int amount) {
        if(amount == 0){
            return 0;
        }

        int[] dp = new int[amount + 1];
        int min = coins[0];

        for(int i = 0; i <= amount; i++){
            dp[i] = -1;
        }

        for(int i = 0; i < coins.length; i++){
            if(coins[i] < min){
                min = coins[i];
            }
            if(coins[i] <= amount){
                dp[coins[i]] = 1;
            }
        }

        if(min > amount){
            return -1;
        }

        //初始化数组

        for(int i = min + 1; i <= amount; i++){
            if(dp[i] == 1){
                continue;
            }

            for(int j = min; j <= i / 2 + 1; j++){
                if(dp[j] == -1 || dp[i - j] == -1){
                    continue;
                }
                if(dp[i] == -1){
                    dp[i] = dp[j] + dp[i - j];
                }else{
                    dp[i] = Math.min(dp[i], dp[j] + dp[i - j]);
                }
            }
        }

        return dp[amount];
    }
}
```



### 思路

动规五部曲：

①dp[j]的含义：凑齐金额为j的所需钱币最小个数为dp[j]

②递推公式：`dp[j] = min(dp[j - coins[i]] + 1, dp[j]);`

③初始化：dp[0] = 0;其他都取最大值。

④遍历顺序：两层for，谁内层谁外层都可以，都是正序遍历

> **如果求组合数就是外层for循环遍历物品，内层for遍历背包**。
>
> **如果求排列数就是外层for遍历背包，内层for循环遍历物品**。



### 代码

```java
class Solution {
    public int coinChange(int[] coins, int amount) {
        int max = Integer.MAX_VALUE;
        int[] dp = new int[amount + 1];
        //初始化dp数组为最大值
        for (int j = 0; j < dp.length; j++) {
            dp[j] = max;
        }
        //当金额为0时需要的硬币数目为0
        dp[0] = 0;
        for (int i = 0; i < coins.length; i++) {
            //正序遍历：完全背包每个硬币可以选择多次
            for (int j = coins[i]; j <= amount; j++) {
                //只有dp[j-coins[i]]不是初始最大值时，该位才有选择的必要
                if (dp[j - coins[i]] != max) {
                    //选择硬币数目最小的情况
                    dp[j] = Math.min(dp[j], dp[j - coins[i]] + 1);
                }
            }
        }
        return dp[amount] == max ? -1 : dp[amount];
    }
}
```



## 十八、完全平方数

### 题目

![](https://github.com/vankykoo/javaStudy/blob/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E9%A2%98%E7%9B%AE/dp/206.png?raw=true)

### 思路

动规五部曲：

①dp[i]的含义：表示第i个数的组成方式最少需要dp[i]个

②递推公式：dp[i] = Math.min(dp[i], dp[i - j*j] + 1);

③初始化方式：dp[0] = 0; 其他初始化为最大值

④遍历顺序：双层for循环，先遍历背包，再遍历物品。



### 代码

```java
class Solution {
    public int numSquares(int n) {
        int[] dp = new int[n + 1];
        int max = Integer.MAX_VALUE;
        for(int i = 1; i <= n; i++){
            dp[i] = max;
        }

        dp[0] = 0;

        for(int i = 1; i <= n; i++){
            for(int j = 1; j * j <= i; j++){
                dp[i] = Math.min(dp[i - j * j] + 1, dp[i]);
            }
        }

        return dp[n];
    }
}
```





## 十九、单词拆分

### 题目

![](https://raw.githubusercontent.com/vankykoo/javaStudy/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E9%A2%98%E7%9B%AE/dp/212.png)



### 思路

由于字典的单词可以重复使用，所以是一个完全背包问题。



动规五部曲：

①dp[i]的含义：长度为i的目标单词能否由字典里的单词拼出来。

②递推公式：

​	如果前面的单词可以被字典的单词组成，

​	而且后面的单词在字典中，

​	则当前单词可以被字典里的单词组成。

```java
if(set.contains(s.substring(j,i)) && dp[j]){
    dp[i] = true;
}
```

③初始化：dp[0] = true;

④遍历顺序：先遍历背包，再遍历物品。

**不能先遍历物品，再遍历背包：**

拿 s = "applepenapple", wordDict = ["apple", "pen"] 举例。

"apple", "pen" 是物品，那么我们要求 物品的组合一定是 "apple" + "pen" + "apple" 才能组成 "applepenapple"。

"apple" + "apple" + "pen" 或者 "pen" + "apple" + "apple" 是不可以的，那么我们就是强调物品之间顺序。

⑤打印dp数组



### 代码

```java
class Solution {
    public boolean wordBreak(String s, List<String> wordDict) {
        HashSet<String> set = new HashSet<>(wordDict);

        int strLen = s.length();
        boolean[] dp = new boolean[strLen + 1];
        dp[0] = true;

        for(int i = 0; i <= strLen; i++){
            for(int j = 0; j < i && !dp[i]; j++){
                if(set.contains(s.substring(j,i)) && dp[j]){
                    dp[i] = true;
                    break;
                }
            }
        }

        return dp[strLen];
    }
}
```





## 二十、多重背包理论

多重背包在01背包的基础上加上了限制物品的使用次数，<u>01背包</u>物品只能使用**1次**，<u>完全背包</u>物品可以被使用**无限次**，<u>多重背包</u>物品只能被使用**有限次**。

解法：

可以把多重背包展开成01背包，就是把一个商品当成多个商品来个，每个商品只能使用一次，这样就变成了一个01背包的问题了。

开始时：

|      | 重量   | 价值   | 数量   |
| ---- | ---- | ---- | ---- |
| 物品0  | 1    | 15   | 2    |
| 物品1  | 3    | 20   | 3    |
| 物品2  | 4    | 30   | 2    |

展开后：

|      | 重量   | 价值   | 数量   |
| ---- | ---- | ---- | ---- |
| 物品0  | 1    | 15   | 1    |
| 物品0  | 1    | 15   | 1    |
| 物品1  | 3    | 20   | 1    |
| 物品1  | 3    | 20   | 1    |
| 物品1  | 3    | 20   | 1    |
| 物品2  | 4    | 30   | 1    |
| 物品2  | 4    | 30   | 1    |



解法代码：

```java
public void testMultiPack1(){
    // 版本一：改变物品数量为01背包格式
    List<Integer> weight = new ArrayList<>(Arrays.asList(1, 3, 4));
    List<Integer> value = new ArrayList<>(Arrays.asList(15, 20, 30));
    List<Integer> nums = new ArrayList<>(Arrays.asList(2, 3, 2));
    int bagWeight = 10;

    for (int i = 0; i < nums.size(); i++) {
        while (nums.get(i) > 1) { // 把物品展开为i
            weight.add(weight.get(i));
            value.add(value.get(i));
            nums.set(i, nums.get(i) - 1);
        }
    }

    int[] dp = new int[bagWeight + 1];
    for(int i = 0; i < weight.size(); i++) { // 遍历物品
        for(int j = bagWeight; j >= weight.get(i); j--) { // 遍历背包容量
            dp[j] = Math.max(dp[j], dp[j - weight.get(i)] + value.get(i));
        }
        System.out.println(Arrays.toString(dp));
    }
}

public void testMultiPack2(){
    // 版本二：改变遍历个数
    int[] weight = new int[] {1, 3, 4};
    int[] value = new int[] {15, 20, 30};
    int[] nums = new int[] {2, 3, 2};
    int bagWeight = 10;

    int[] dp = new int[bagWeight + 1];
    for(int i = 0; i < weight.length; i++) { // 遍历物品
        for(int j = bagWeight; j >= weight[i]; j--) { // 遍历背包容量
            // 以上为01背包，然后加一个遍历个数
            for (int k = 1; k <= nums[i] && (j - k * weight[i]) >= 0; k++) { // 遍历个数
                dp[j] = Math.max(dp[j], dp[j - k * weight[i]] + k * value[i]);
            }
            System.out.println(Arrays.toString(dp));
        }
    }
}
```



## 二十一、背包问题的总结

递推公式：

![](C:\Users\86180\Desktop\picPick\216.png)



思维导图：

![](https://code-thinking-1253855093.file.myqcloud.com/pics/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%981.jpeg)



## 二十二、打家劫舍

### 题目

![](https://raw.githubusercontent.com/vankykoo/javaStudy/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E9%A2%98%E7%9B%AE/dp/225.png)

### 思路

主要是考虑这家偷还是不偷。偷的话要根据前面倒数第二家加上当前这家，不偷的话就按前面第一家算。

动规五部曲：

①dp[i]的含义：走到第 i 家能获得的最大钱数为dp[i]

②递推公式：

偷就是：`dp[i - 2] + nums[i]`

不偷就是：`dp[i - 1]`

比较一下看看偷不偷

`dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i]);`

③初始化：因为递推公式用到前面第二个，所以要初始化两个。

`dp[0] = nums[0];`

`dp[1] = Math.max(nums[0], nums[1]);`

④遍历顺序：从前往后

⑤打印dp数组



### 代码

```java
class Solution {
    public int rob(int[] nums) {
        int len = nums.length;
        if(len == 1){
            return nums[0];
        }
        
        int[] dp = new int[len];
        dp[0] = nums[0];
        dp[1] = Math.max(nums[0],nums[1]);

        for(int i = 2; i < len ; i++){
            dp[i] = Math.max(nums[i] + dp[i - 2],dp[i - 1]);
        }

        return dp[len - 1];
    }
}
```

















































































