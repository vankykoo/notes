# 动态规划

##零、介绍

五步：

1. 确定dp数组（dp table）以及下标的含义。
2. 确定递推公式
3. dp数组如何初始化
4. 确定遍历顺序
5. 举例推导dp数组






## 一、斐波那契数

### 题目

![](https://raw.githubusercontent.com/vankykoo/javaStudy/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E9%A2%98%E7%9B%AE/dp/130.png)



### 思路

#### 1.递归



#### 2.动态规划

①**确定dp数组以及下标的含义**：第i个数的斐波那契数值是dp[i]

②**确定递推公式**：状态转移方程 dp[i] = dp[i - 1] + dp[i - 2];

③**dp数组如何初始化**：dp[0] = 0; dp[1] = 1;

④**确定遍历顺序**：从前往后

⑤打印dp数组：用于debug



### 二刷

```java
class Solution {
    public int fib(int n) {
        if(n == 0){
            return 0;
        }

        int[] dp = new int[n+1];
        dp[0] = 0;
        dp[1] = 1;

        for(int i = 2; i <= n; i++){
            dp[i] = dp[i-1] + dp[i-2];
        }

        return dp[n];
    }
}
```





### 代码

#### 1.递归

```java
class Solution {
    public int fib(int n) {
        if(n <= 1){
            return n;
        }

        return fib(n - 1) + fib(n - 2);
    }
}
```



#### 2.动态规划

```java
class Solution {
    public int fib(int n) {
        if (n <= 1) return n;             
        int[] dp = new int[n + 1];
        dp[0] = 0;
        dp[1] = 1;
        for (int index = 2; index <= n; index++){
            dp[index] = dp[index - 1] + dp[index - 2];
        }
        return dp[n];
    }
}
```

#### 3.动态规划（推荐）

```java
//只需要维护dp数组的两个元素
class Solution {
    public int fib(int n) {
        if(n < 2) return n;

        int[] dp = new int[2];
        dp[0] = 0;
        dp[1] = 1;
        for(int i = 2;i <= n; i++){
            int sum = dp[0] + dp[1];
            dp[0] = dp[1];
            dp[1] = sum; 
        }

        return dp[1];
    }
}
```





## 二、爬楼梯

### 题目

![019.png (717×843) (raw.githubusercontent.com)](https://raw.githubusercontent.com/vankykoo/image/main/pic/019.png)

### 思路

①**确定dp数组以及下标的定义**：dp[i]： 爬到第i层楼梯，有dp[i]种方法

②**确定递推公式：**

从dp[i]的定义可以看出，dp[i] 可以有两个方向推出来。

首先是dp[i - 1]，上i-1层楼梯，有dp[i - 1]种方法，那么再一步跳一个台阶不就是dp[i]了么。

还有就是dp[i - 2]，上i-2层楼梯，有dp[i - 2]种方法，那么再一步跳两个台阶不就是dp[i]了么。

那么dp[i]就是 dp[i - 1]与dp[i - 2]之和！

所以dp[i] = dp[i - 1] + dp[i - 2] 

③初始化dp数组：dp[0]不管，dp[1] = 1; dp[2] = 2;相当于爬到第i层有dp[i]种方法。

④遍历顺序：从前往后

⑤打印dp数组：![](https://code-thinking-1253855093.file.myqcloud.com/pics/20210105202546299.png)



### 二刷

```java
class Solution {
    public int climbStairs(int n) {
        //根据前两节阶梯推出当前。
        int[] dp = new int[2];
        dp[0] = 1;
        dp[1] = 1;

        for(int i = 2; i <= n; i++){
            int method = dp[0] + dp[1];

            dp[0] = dp[1];
            dp[1] = method;
        }

        return dp[1];
    }
}
```





### 代码

```java
class Solution {
    public int climbStairs(int n) {
        if(n <= 2) return n;

        int[] dp = new int[n + 1];
        dp[1] = 1;
        dp[2] = 2;
        for(int i = 3; i <= n; i++){
            dp[i] = dp[i - 1] + dp[i - 2];
        }

        return dp[n];
    }
}
```



```java
// 用变量记录代替数组
class Solution {
    public int climbStairs(int n) {
        if(n <= 2) return n;
        int a = 1, b = 2, sum = 0;

        for(int i = 3; i <= n; i++){
            sum = a + b;  // f(i - 1) + f(i - 2)
            a = b;        // 记录f(i - 1)，即下一轮的f(i - 2)
            b = sum;      // 记录f(i)，即下一轮的f(i - 1)
        }
        return b;
    }
}
```



## 三、使用最小花费爬楼梯

### 题目

![](https://raw.githubusercontent.com/vankykoo/javaStudy/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E9%A2%98%E7%9B%AE/dp/135.png)



### 思路

①dp[i]数组含义：爬到第i层需要花费的最小费用

②确定递推公式：

**可以有两个途径得到dp[i]，一个是dp[i-1] 一个是dp[i-2]**。

dp[i - 1] 跳到 dp[i] 需要花费 dp[i - 1] + cost[i - 1]。

dp[i - 2] 跳到 dp[i] 需要花费 dp[i - 2] + cost[i - 2]。

那么究竟是选从dp[i - 1]跳还是从dp[i - 2]跳呢？

一定是选最小的，所以dp[i] = min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);

③dp数组初始化：dp[0] = 0;  dp[1] = 0;

④确定遍历顺序：从前往后

⑤打印dp数组：![](https://code-thinking-1253855093.file.myqcloud.com/pics/20221026175104.png)



### 二刷

```java
class Solution {
    public int minCostClimbingStairs(int[] cost) {
        int index = 0;
        int[] dp = new int[2];
        dp[0] = cost[0];
        dp[1] = cost[1];

        for(int i = 2; i < cost.length; i++){
            //这里计算从前面两个台阶中选择一个便宜的爬到当前台阶。
            int cur = Math.min(dp[0], dp[1]) + cost[i];
            dp[0] = dp[1];
            dp[1] = cur;
        }

        return Math.min(dp[0], dp[1]);
    }
}
```





### 代码

```java
class Solution {
    public int minCostClimbingStairs(int[] cost) {
        int len = cost.length;
        int[] dp = new int[len + 1];

        // 从下标为 0 或下标为 1 的台阶开始，因此支付费用为0
        dp[0] = 0;
        dp[1] = 0;

        // 计算到达每一层台阶的最小费用
        for (int i = 2; i <= len; i++) {
            dp[i] = Math.min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);
        }

        return dp[len];
    }
}
```





## 四、不同路径

### 题目

![](https://raw.githubusercontent.com/vankykoo/javaStudy/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E9%A2%98%E7%9B%AE/dp/134.png)





### 思路

动态规划：

①dp数组的含义，dp\[i][j]表示走到（i，j）有dp\[i][j]种路径。

②递推公式：dp\[i][j] = dp\[i - 1][j] - dp\[i][j - 1];

③初始化数组：第一行和第一列都为1.

④遍历顺序：从头开始一层一层遍历

⑤打印dp数组：debug时用。



### 代码

```java
lass Solution {
    public int uniquePaths(int m, int n) {
        int[][] dp = new int[m][n];
        //初始化dp数组
        for(int i = 0; i < m; i++){
            dp[i][0] = 1;
        }
        for(int i = 0; i < n; i++){
            dp[0][i] = 1;
        }
        
        for(int i = 1; i < m; i++){
            for(int j = 1; j < n; j++){
                //递推公式
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
            }
        }

        return dp[m - 1][n - 1];
    }
}
```



## 五、不同路径Ⅱ

### 题目

![](https://raw.githubusercontent.com/vankykoo/javaStudy/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E9%A2%98%E7%9B%AE/dp/136.png)



### 思路

①dp\[i][j]的含义：到达（i+1，j+1）的路径有dp\[i][j]种。

②递推公式：如果当前位置为障碍物（`obstacleGrid[i][j] == 1`）时，就把dp\[i][j]赋值为0；如果没有障碍物，就和上一题一样，

`dp[i][j] = dp[i - 1][j] + dp[i][j - 1]`

③初始化dp数组：只需要初始化第一行和第一列，如果遇到障碍物，那么障碍物后面的数值都为零，否则都为1.

④遍历顺序：逐层遍历

⑤打印dp数组



### 代码

```java
class Solution {
    public int uniquePathsWithObstacles(int[][] obstacleGrid) {
        int m = obstacleGrid.length;
        int n = obstacleGrid[0].length;
        if(obstacleGrid[0][0] == 1){
            return 0;
        }

        int[][] dp = new int[m][n];

        //初始化
        dp[0][0] = 1;
        for(int i = 1; i < m; i++){
            if(obstacleGrid[i][0] == 1){
                for(; i < m; i++){
                    dp[i][0] = 0;
                }
            }else{
                dp[i][0] = 1;
            }
        }
        for(int i = 1; i < n; i++){
            if(obstacleGrid[0][i] == 1){
                for(; i < n; i++){
                    dp[0][i] = 0;
                }
            }else{
                dp[0][i] = 1;
            }
        }

        //递推公式
        for(int i = 1; i < m; i++){
            for(int j = 1; j < n; j++){
                if(obstacleGrid[i][j] == 1){
                    dp[i][j] = 0;
                }else{
                    dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
                }
            }
        }

        return dp[m - 1][n - 1];
    }
}
```



### 答案代码

```java
class Solution {
    public int uniquePathsWithObstacles(int[][] obstacleGrid) {
        int m = obstacleGrid.length;
        int n = obstacleGrid[0].length;
        int[][] dp = new int[m][n];

        //如果在起点或终点出现了障碍，直接返回0
        if (obstacleGrid[m - 1][n - 1] == 1 || obstacleGrid[0][0] == 1) {
            return 0;
        }

        for (int i = 0; i < m && obstacleGrid[i][0] == 0; i++) {
            dp[i][0] = 1;
        }
        for (int j = 0; j < n && obstacleGrid[0][j] == 0; j++) {
            dp[0][j] = 1;
        }

        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                dp[i][j] = (obstacleGrid[i][j] == 0) ? dp[i - 1][j] + dp[i][j - 1] : 0;
            }
        }
        return dp[m - 1][n - 1];
    }
}
```





## 六、整数拆分

### 题目

![](https://raw.githubusercontent.com/vankykoo/javaStudy/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E9%A2%98%E7%9B%AE/dp/139.png)



### 解法一：动态规划

![](https://raw.githubusercontent.com/vankykoo/javaStudy/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E9%A2%98%E7%9B%AE/dp/140.png)

```java
class Solution {
    public int integerBreak(int n) {
        int[] dp = new int[n + 1];
        for (int i = 2; i <= n; i++) {
            int curMax = 0;
            for (int j = 1; j < i; j++) {
                curMax = Math.max(curMax, Math.max(j * (i - j), j * dp[i - j]));
            }
            dp[i] = curMax;
        }
        return dp[n];
    }
}
```





### 解法二：数学

K神解法：

![](https://raw.githubusercontent.com/vankykoo/javaStudy/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E9%A2%98%E7%9B%AE/dp/141.png))



> 如果最优乘积包含因子 f >= 4，则可以将其替换为因子 2 和 f-2，而不会丢失最优性，因为 2*（f-2） = 2f-4 >= f。所以你永远不需要大于或等于 4 的因子，这意味着你只需要因子 1、2 和 3（1 当然是浪费，你只会在需要的地方将它用于 n=2 和 n=3）。
>
> 对于其余的我同意，3*3 只是比*2 2*2 好，所以你永远不会使用 2 超过两次。

```java
class Solution {
    public int integerBreak(int n) {
        if(n <= 3) return n - 1;
        int a = n / 3, b = n % 3;
        if(b == 0) return (int)Math.pow(3, a);
        if(b == 1) return (int)Math.pow(3, a - 1) * 4;
        return (int)Math.pow(3, a) * 2;
    }
}
```





## 七、不同的二叉搜索树

### 题目

![](https://raw.githubusercontent.com/vankykoo/javaStudy/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E9%A2%98%E7%9B%AE/dp/149.png)



### 思路

①dp[i]的含义：表示如果有i个节点，可以组成dp[i]种二叉搜索树。

②递推公式：就是看根结点的左子树有多少种可能，右子树有多少种可能，然后相乘即可。而左右子树是从dp数组前面的元素推出来的，所有用动态规划。

即`dp[i] = dp[比i小的个数]  *  dp[比i大的个数]`

③dp数组的初始化：只需要dp[0] = 1即可；

④遍历顺序：很容易想到是从前往后。

⑤打印dp数组。



### 代码

```java
class Solution {
    public int numTrees(int n) {
        int[] dp = new int[n + 1];
        dp[0] = 1;

        for(int i = 1; i <= n; i++){
            int sum = 0;
          //求以不同根结点可构成的二叉搜索树的和
            for(int j = 1; j <= i; j++){
              //左子树
                int left = dp[j - 1];
              //右子树
                int right = dp[i - j];
                sum += left * right;
            }
            dp[i] = sum;
        }

        return dp[n];
    }
}
```





## 八、01背包问题理论

背包分类：

![](https://code-thinking-1253855093.file.myqcloud.com/pics/20210117171307407.png)



### 1）介绍

**定义**：有n件物品和一个最多能背重量为w 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。**每件物品只能用一次**，求解将哪些物品装入背包里物品价值总和最大。



### 2）二维数组

①dp\[i][j]的含义：**dp\[i][j] 表示从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少**。【物品i在容量为j的背包下，放和不放所能取到的最大价值】

②递推公式：

- **不放物品i**：由dp\[i - 1][j]推出，即背包容量为j，里面不放物品i的最大价值，此时dp\[i][j]就是dp\[i - 1][j]。(其实就是当物品i的重量大于背包j的重量时，物品i无法放进背包中，所以背包内的价值依然和前面相同。)
- **放物品i**：由dp\[i - 1][j - weight[i]]推出，dp\[i - 1][j - weight[i]] 为背包容量为j - weight[i]的时候不放物品i的最大价值，那么dp\[i - 1][j - weight[i]] + value[i] （物品i的价值），就是背包放物品i得到的最大价值

所以递归公式： **dp\[i][j] = max(dp\[i - 1][j], dp\[i - 1][j - weight[i]] + value[i]);**

③dp数组初始化：

![](https://code-thinking-1253855093.file.myqcloud.com/pics/20210110103003361.png)

* 只初始化第一行和第一列
  * 第一列：全为0
  * 第一行：从物品0对应的重量开始填上物品0的价格，其他为0。



④遍历方向：双层for循环，其实谁在内层外层都可以，因为当前数据之和当前数据的上面和左上方的数据有关。



### 代码

```java
public class BagProblem {
    public static void main(String[] args) {
        int[] weight = {1,3,4};
        int[] value = {15,20,30};
        int bagSize = 4;
        testWeightBagProblem(weight,value,bagSize);
    }

    /**
     * 动态规划获得结果
     * @param weight  物品的重量
     * @param value   物品的价值
     * @param bagSize 背包的容量
     */
    public static void testWeightBagProblem(int[] weight, int[] value, int bagSize){

        // 创建dp数组
        int goods = weight.length;  // 获取物品的数量
        int[][] dp = new int[goods][bagSize + 1];

        // 初始化dp数组
        // 创建数组后，其中默认的值就是0
        for (int j = weight[0]; j <= bagSize; j++) {
            dp[0][j] = value[0];
        }

        // 填充dp数组
        for (int i = 1; i < weight.length; i++) {
            for (int j = 1; j <= bagSize; j++) {
                if (j < weight[i]) {
                    /**
                     * 当前背包的容量都没有当前物品i大的时候，是不放物品i的
                     * 那么前i-1个物品能放下的最大价值就是当前情况的最大价值
                     */
                    dp[i][j] = dp[i-1][j];
                } else {
                    /**
                     * 当前背包的容量可以放下物品i
                     * 那么此时分两种情况：
                     *    1、不放物品i
                     *    2、放物品i
                     * 比较这两种情况下，哪种背包中物品的最大价值最大
                     */
                    dp[i][j] = Math.max(dp[i-1][j] , dp[i-1][j-weight[i]] + value[i]);
                }
            }
        }

        // 打印dp数组
        for (int i = 0; i < goods; i++) {
            for (int j = 0; j <= bagSize; j++) {
                System.out.print(dp[i][j] + "\t");
            }
            System.out.println("\n");
        }
    }
}
```



### 3）滚动数组-一维数组

在二维数组的递推公式中：

`dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);`

可以看出dp[i]只与dp[i - 1]有关，所以可以只用一维数组来表示，把上一层的数组复制下来（滚动）。



①dp[j]的含义：容量为j的背包，可以装的最大价值为dp[j]

②递推公式：`dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);` 就是消去了i - 1 的部分

③初始化：都初始化为小于等于零的数就行

④遍历顺序：双层for循环，先遍历物品，再遍历背包容量，遍历背包容量时倒序遍历。

```java
for(int i = 0; i < weight.size(); i++) { // 遍历物品
    for(int j = bagWeight; j >= weight[i]; j--) { // 遍历背包容量
        dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);

    }
}
```

* 如果正序遍历：遍历背包容量时，就可能放入相同物品
* 如果先遍历背包容量：那么每个背包里就只会有一种物品且为1个

⑤打印dp数组：![](https://code-thinking-1253855093.file.myqcloud.com/pics/20210110103614769.png)



###代码

```java
    public static void main(String[] args) {
        int[] weight = {1, 3, 4};
        int[] value = {15, 20, 30};
        int bagWight = 4;
        testWeightBagProblem(weight, value, bagWight);
    }

    public static void testWeightBagProblem(int[] weight, int[] value, int bagWeight){
        int wLen = weight.length;
        //定义dp数组：dp[j]表示背包容量为j时，能获得的最大价值
        int[] dp = new int[bagWeight + 1];
        //遍历顺序：先遍历物品，再遍历背包容量
        for (int i = 0; i < wLen; i++){
            for (int j = bagWeight; j >= weight[i]; j--){
                dp[j] = Math.max(dp[j], dp[j - weight[i]] + value[i]);
            }
        }
        //打印dp数组
        for (int j = 0; j <= bagWeight; j++){
            System.out.print(dp[j] + " ");
        }
    }
```





## 九、分割等和子集

### 题目

![](https://raw.githubusercontent.com/vankykoo/javaStudy/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E9%A2%98%E7%9B%AE/dp/158.png))



### 思路

**可以看出01背包问题：**

- 背包的体积为sum / 2
- 背包要放入的商品（集合里的元素）重量为 元素的数值，价值也为元素的数值
- 背包如果正好装满，说明找到了总和为 sum / 2 的子集。
- 背包中每一个元素是不可重复放入。



①dp[j]含义：**背包总容量（所能装的总重量）是j，放进物品后，背的最大重量为dp[j]**。

②递推公式：dp[j] = max(dp[j], dp[j - nums[i]] + nums[i]);

③初始化dp数组：都初始化为0

④遍历顺序：物品遍历的for循环放在外层，遍历背包的for循环放在内层，内层for循环**倒序遍历**

⑤打印dp数组：![](https://code-thinking-1253855093.file.myqcloud.com/pics/20210110104240545.png)



### 代码

```java
class Solution {
    public boolean canPartition(int[] nums) {
        if(nums == null || nums.length == 0) return false;
        int n = nums.length;
        int sum = 0;
        for(int num : nums) {
            sum += num;
        }
        //总和为奇数，不能平分
        if(sum % 2 != 0) return false;
        int target = sum / 2;
        int[] dp = new int[target + 1];
        for(int i = 0; i < n; i++) {
            for(int j = target; j >= nums[i]; j--) {
                //物品 i 的重量是 nums[i]，其价值也是 nums[i]
                dp[j] = Math.max(dp[j], dp[j - nums[i]] + nums[i]);
            }
           
            //剪枝一下，每一次完成內層的for-loop，立即檢查是否dp[target] == target，優化時間複雜度（26ms -> 20ms）
            if(dp[target] == target)
                return true;
        }
        return dp[target] == target;
    }
}
```



## 十、最后一块石头的重量Ⅱ

### 题目

![](https://raw.githubusercontent.com/vankykoo/javaStudy/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E9%A2%98%E7%9B%AE/dp/182.png))

### 思路

总体思路：尽量让石头分成重量相同的两堆，相撞之后剩下的石头最小。

动态规划五部曲：

①dp[j]的含义：容量为j的背包可以背的最大重量为dp[j]

②递推公式：和01背包一样，**dp[j] = max(dp[j], dp[j - stones[i]] + stones[i]);**

③dp数组初始化：尽量分成重量相同的两堆石头，其实就是让最大容量为石头总重量的二分之一，

题目提示有1 <= stones.length <= 30，1 <= stones[i] <= 1000，所以最大重量就是30 * 1000 。

而我们要求的target其实只是最大重量的一半，所以dp数组开到15000大小就可以了。里面的数值都初始化为0即可。

④遍历顺序：和01背包滚动数组相同，先遍历物品在遍历背包，内层倒序遍历。

⑤打印dp数组：

![](https://code-thinking-1253855093.file.myqcloud.com/pics/20210121115805904.jpg)

相撞之后剩下的最小石头重量就是 (sum - dp[target]) - dp[target]

### 代码

```java
class Solution {
    public int lastStoneWeightII(int[] stones) {
        int sum = 0;
        for (int i : stones) {
            sum += i;
        }
        int target = sum >> 1;
        //初始化dp数组
        int[] dp = new int[target + 1];
        for (int i = 0; i < stones.length; i++) {
            //采用倒序
            for (int j = target; j >= stones[i]; j--) {
                //两种情况，要么放，要么不放
                dp[j] = Math.max(dp[j], dp[j - stones[i]] + stones[i]);
            }
        }
        return sum - 2 * dp[target];
    }
}
```





## 十一、目标和

### 题目

![](https://raw.githubusercontent.com/vankykoo/javaStudy/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E9%A2%98%E7%9B%AE/dp/185.png)



### 思路

题目转化为：数字前面是负号的数字的数量种类和

背包容量：数字前面是负号的数字的和neg = sum - target / 2，如果sum - target不是偶数，可以直接返回0，因为根本凑不出一种方案。

如果sum - target 小于零  ，也凑不出，即使全是正号，也不够，直接返回0。

![](https://raw.githubusercontent.com/vankykoo/javaStudy/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E9%A2%98%E7%9B%AE/dp/184.png)



### 代码

```java
//滚动数组
class Solution {
    public int findTargetSumWays(int[] nums, int target) {
        int sum = 0;
        for (int num : nums) {
            sum += num;
        }
        int diff = sum - target;
        if (diff < 0 || diff % 2 != 0) {
            return 0;
        }
        int neg = diff / 2;
        int[] dp = new int[neg + 1];
        dp[0] = 1;
        for (int num : nums) {
            for (int j = neg; j >= num; j--) {
                dp[j] += dp[j - num];
            }
        }
        return dp[neg];
    }
}
```



```java
//二维数组
class Solution {
    public int findTargetSumWays(int[] nums, int target) {
        int sum = 0;
        for (int num : nums) {
            sum += num;
        }
        int diff = sum - target;
        if (diff < 0 || diff % 2 != 0) {
            return 0;
        }
        int n = nums.length, neg = diff / 2;
        int[][] dp = new int[n + 1][neg + 1];
        dp[0][0] = 1;
        for (int i = 1; i <= n; i++) {
            int num = nums[i - 1];
            for (int j = 0; j <= neg; j++) {
                dp[i][j] = dp[i - 1][j];
                if (j >= num) {
                    dp[i][j] += dp[i - 1][j - num];
                }
            }
        }
        return dp[n][neg];
    }
}
```



## 十二、一和零

### 题目

![](https://raw.githubusercontent.com/vankykoo/javaStudy/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E9%A2%98%E7%9B%AE/dp/186.png)

### 思路

本题中 strs 数组里的元素就是物品，每个物品都是一个。

而m 和 n 相当于是一个背包，两个维度的背包。

动规五部曲：

①dp\[i][j]含义：最多有i个0和j个1的strs的最大子集的大小为dp\[i][j]。

②确定递推公式：`dp[i][j] = max(dp[i][j], dp[i - zeroNum][j - oneNum] + 1);`

③初始化：还是用类似滚动数组的做法，初始化为0。

④确定遍历顺序：外层遍历物品，内层遍历背包，且内层倒序遍历。

⑤打印dp数组：![](https://code-thinking-1253855093.file.myqcloud.com/pics/20210120111201512.jpg)



### 代码

```java
class Solution {
    public int findMaxForm(String[] strs, int m, int n) {
        //dp[i][j]表示i个0和j个1时的最大子集
        int[][] dp = new int[m + 1][n + 1];
        int oneNum, zeroNum;
        for (String str : strs) {
            oneNum = 0;
            zeroNum = 0;
            for (char ch : str.toCharArray()) {
                if (ch == '0') {
                    zeroNum++;
                } else {
                    oneNum++;
                }
            }
            //倒序遍历
            for (int i = m; i >= zeroNum; i--) {
                for (int j = n; j >= oneNum; j--) {
                    dp[i][j] = Math.max(dp[i][j], dp[i - zeroNum][j - oneNum] + 1);
                }
            }
        }
        return dp[m][n];
    }
}
```



## 十三、完全背包理论基础

* 和01背包的唯一不同，就是每种物品可以放无限件。

* 所以在遍历背包的时候，需要正序遍历。

* 可以先遍历背包再遍历物品，也可以先遍历物品再遍历背包。

  * 先遍历物品![](https://code-thinking-1253855093.file.myqcloud.com/pics/20210126104529605.jpg)

  * 先遍历背包

    ![](https://code-thinking-1253855093.file.myqcloud.com/pics/20210729234011.png)



```java
//先遍历物品，再遍历背包
private static void testCompletePack(){
    int[] weight = {1, 3, 4};
    int[] value = {15, 20, 30};
    int bagWeight = 4;
    int[] dp = new int[bagWeight + 1];
    for (int i = 0; i < weight.length; i++){ // 遍历物品
        for (int j = weight[i]; j <= bagWeight; j++){ // 遍历背包容量
            dp[j] = Math.max(dp[j], dp[j - weight[i]] + value[i]);
        }
    }
    for (int maxValue : dp){
        System.out.println(maxValue + "   ");
    }
}

//先遍历背包，再遍历物品
private static void testCompletePackAnotherWay(){
    int[] weight = {1, 3, 4};
    int[] value = {15, 20, 30};
    int bagWeight = 4;
    int[] dp = new int[bagWeight + 1];
    for (int i = 1; i <= bagWeight; i++){ // 遍历背包容量
        for (int j = 0; j < weight.length; j++){ // 遍历物品
            if (i - weight[j] >= 0){
                dp[i] = Math.max(dp[i], dp[i - weight[j]] + value[j]);
            }
        }
    }
    for (int maxValue : dp){
        System.out.println(maxValue + "   ");
    }
}
```





## 十四、零钱兑换

### 题目

![](https://raw.githubusercontent.com/vankykoo/javaStudy/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E9%A2%98%E7%9B%AE/dp/187.png)



### 思路

动规五部曲：

①dp[j]的含义：找零j元钱有dp[j]种方法

②递推公式：**dp[j] += dp[j - coins[i]]**

![](https://raw.githubusercontent.com/vankykoo/javaStudy/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E9%A2%98%E7%9B%AE/dp/188.png)

③初始化：dp[0]初始化为0；意思就需要是找零的钱和零钱数是相等的时候，总是1种。就是用相同的钱去换一张相同的钱。

④遍历顺序：两层for循环，都是从前往后。这样才能找零多张。



### 代码

```java
class Solution {
    public int change(int amount, int[] coins) {
        int len = coins.length;
        int[] dp = new int[amount + 1];

        dp[0] = 1;

        for(int i = 0; i < len; i++){
            for(int j = coins[i]; j <= amount; j++){
                dp[j] += dp[j - coins[i]];
            }
        }

        return dp[amount];
    }
}
```





## 十五、组合总和Ⅳ

### 题目

![](https://raw.githubusercontent.com/vankykoo/javaStudy/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E9%A2%98%E7%9B%AE/dp/190.png)



### 思路

动规五部曲：

①dp[i]的含义：target为i的组合数有dp[i]种。

②递推公式：分别以nums数组的每个数开头，把每种组合数加起来。

比如：target = 3时，以1 开头，后面就是 2，看看2有几种组合；以 2开头，差1，看看1有几种组合；以3 开头，差 0，零的组合只有一种。

所以：dp[i] = dp[i - nums[j]];

③初始化：dp[0] = 1；表示 nums 中是否有只用一个数就能组成target的，就是看nums中有没有target值。

④遍历顺序：外层遍历背包，内层遍历nums数组，从前向后。

> **如果求组合数就是外层for循环遍历物品，内层for遍历背包**。
>
> **如果求排列数就是外层for遍历背包，内层for循环遍历物品**。

⑤打印dp数组：

![](https://code-thinking-1253855093.file.myqcloud.com/pics/20230310000625.png)



###代码

```java
class Solution {
    public int combinationSum4(int[] nums, int target) {
        int len = nums.length;
        int[] dp = new int[target + 1];
      //初始化
        dp[0] = 1;

        for(int i = 1; i <= target; i++){
            for(int j = 0; j < len; j++){
                if(i >= nums[j]){
                    dp[i] += dp[i - nums[j]];
                }
            }
        }

        return dp[target];
    }
}
```





## 十六、爬楼梯（完全背包解法）

### 题目

![](https://raw.githubusercontent.com/vankykoo/javaStudy/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E9%A2%98%E7%9B%AE/dp/201.png)

### 思路

和上一题一样，此时的物品只有两个：1和2，背包大小就是要上的台阶数

动规五部曲：

①dp[i]的含义：爬i个台阶有dp[i]种方法

②递推公式：和之前不是背包问题的时候的思路差不多，就是到达前面两阶的方法相加。

dp[i] += dp[i - j] 	j是1和2

③初始化dp数组：dp[0] = 1;

④遍历顺序：完全背包问题，双层遍历，且都是正序

⑤打印dp数组



### 代码

```java
class Solution {
    public int climbStairs(int n) {
        int[] dp = new int[n + 1];
        dp[0] = 1;

        for(int i = 1; i < n + 1; i++){
            for(int j = 1; j <= 2; j++){
                if(i - j >= 0){
                    dp[i] += dp[i - j];
                }
            }
        }

        return dp[n];
    }
}
```





## 十七、零钱兑换

### 题目

![](https://raw.githubusercontent.com/vankykoo/javaStudy/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E9%A2%98%E7%9B%AE/dp/203.png)

### 我的代码

初始化出了问题，出现很多不必要的判断，应该初始化为最大值

而且第二层循环应该遍历钱币的，我两层都遍历了背包。。。。

```java
class Solution {
    public int coinChange(int[] coins, int amount) {
        if(amount == 0){
            return 0;
        }

        int[] dp = new int[amount + 1];
        int min = coins[0];

        for(int i = 0; i <= amount; i++){
            dp[i] = -1;
        }

        for(int i = 0; i < coins.length; i++){
            if(coins[i] < min){
                min = coins[i];
            }
            if(coins[i] <= amount){
                dp[coins[i]] = 1;
            }
        }

        if(min > amount){
            return -1;
        }

        //初始化数组

        for(int i = min + 1; i <= amount; i++){
            if(dp[i] == 1){
                continue;
            }

            for(int j = min; j <= i / 2 + 1; j++){
                if(dp[j] == -1 || dp[i - j] == -1){
                    continue;
                }
                if(dp[i] == -1){
                    dp[i] = dp[j] + dp[i - j];
                }else{
                    dp[i] = Math.min(dp[i], dp[j] + dp[i - j]);
                }
            }
        }

        return dp[amount];
    }
}
```



### 思路

动规五部曲：

①dp[j]的含义：凑齐金额为j的所需钱币最小个数为dp[j]

②递推公式：`dp[j] = min(dp[j - coins[i]] + 1, dp[j]);`

③初始化：dp[0] = 0;其他都取最大值。

④遍历顺序：两层for，谁内层谁外层都可以，都是正序遍历

> **如果求组合数就是外层for循环遍历物品，内层for遍历背包**。
>
> **如果求排列数就是外层for遍历背包，内层for循环遍历物品**。



### 代码

```java
class Solution {
    public int coinChange(int[] coins, int amount) {
        int max = Integer.MAX_VALUE;
        int[] dp = new int[amount + 1];
        //初始化dp数组为最大值
        for (int j = 0; j < dp.length; j++) {
            dp[j] = max;
        }
        //当金额为0时需要的硬币数目为0
        dp[0] = 0;
        for (int i = 0; i < coins.length; i++) {
            //正序遍历：完全背包每个硬币可以选择多次
            for (int j = coins[i]; j <= amount; j++) {
                //只有dp[j-coins[i]]不是初始最大值时，该位才有选择的必要
                if (dp[j - coins[i]] != max) {
                    //选择硬币数目最小的情况
                    dp[j] = Math.min(dp[j], dp[j - coins[i]] + 1);
                }
            }
        }
        return dp[amount] == max ? -1 : dp[amount];
    }
}
```



## 十八、完全平方数

### 题目

![](https://github.com/vankykoo/javaStudy/blob/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E9%A2%98%E7%9B%AE/dp/206.png?raw=true)

### 思路

动规五部曲：

①dp[i]的含义：表示第i个数的组成方式最少需要dp[i]个

②递推公式：dp[i] = Math.min(dp[i], dp[i - j*j] + 1);

③初始化方式：dp[0] = 0; 其他初始化为最大值

④遍历顺序：双层for循环，先遍历背包，再遍历物品。



### 代码

```java
class Solution {
    public int numSquares(int n) {
        int[] dp = new int[n + 1];
        int max = Integer.MAX_VALUE;
        for(int i = 1; i <= n; i++){
            dp[i] = max;
        }

        dp[0] = 0;

        for(int i = 1; i <= n; i++){
            for(int j = 1; j * j <= i; j++){
                dp[i] = Math.min(dp[i - j * j] + 1, dp[i]);
            }
        }

        return dp[n];
    }
}
```





## 十九、单词拆分

### 题目

![](https://raw.githubusercontent.com/vankykoo/javaStudy/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E9%A2%98%E7%9B%AE/dp/212.png)



### 思路

由于字典的单词可以重复使用，所以是一个完全背包问题。



动规五部曲：

①dp[i]的含义：长度为i的目标单词能否由字典里的单词拼出来。

②递推公式：

​	如果前面的单词可以被字典的单词组成，

​	而且后面的单词在字典中，

​	则当前单词可以被字典里的单词组成。

```java
if(set.contains(s.substring(j,i)) && dp[j]){
    dp[i] = true;
}
```

③初始化：dp[0] = true;

④遍历顺序：先遍历背包，再遍历物品。

**不能先遍历物品，再遍历背包：**

拿 s = "applepenapple", wordDict = ["apple", "pen"] 举例。

"apple", "pen" 是物品，那么我们要求 物品的组合一定是 "apple" + "pen" + "apple" 才能组成 "applepenapple"。

"apple" + "apple" + "pen" 或者 "pen" + "apple" + "apple" 是不可以的，那么我们就是强调物品之间顺序。

⑤打印dp数组



### 代码

```java
class Solution {
    public boolean wordBreak(String s, List<String> wordDict) {
        HashSet<String> set = new HashSet<>(wordDict);

        int strLen = s.length();
        boolean[] dp = new boolean[strLen + 1];
        dp[0] = true;

        for(int i = 0; i <= strLen; i++){
            for(int j = 0; j < i && !dp[i]; j++){
                if(set.contains(s.substring(j,i)) && dp[j]){
                    dp[i] = true;
                    break;
                }
            }
        }

        return dp[strLen];
    }
}
```





## 二十、多重背包理论

多重背包在01背包的基础上加上了限制物品的使用次数，<u>01背包</u>物品只能使用**1次**，<u>完全背包</u>物品可以被使用**无限次**，<u>多重背包</u>物品只能被使用**有限次**。

解法：

可以把多重背包展开成01背包，就是把一个商品当成多个商品来个，每个商品只能使用一次，这样就变成了一个01背包的问题了。

开始时：

|      | 重量   | 价值   | 数量   |
| ---- | ---- | ---- | ---- |
| 物品0  | 1    | 15   | 2    |
| 物品1  | 3    | 20   | 3    |
| 物品2  | 4    | 30   | 2    |

展开后：

|      | 重量   | 价值   | 数量   |
| ---- | ---- | ---- | ---- |
| 物品0  | 1    | 15   | 1    |
| 物品0  | 1    | 15   | 1    |
| 物品1  | 3    | 20   | 1    |
| 物品1  | 3    | 20   | 1    |
| 物品1  | 3    | 20   | 1    |
| 物品2  | 4    | 30   | 1    |
| 物品2  | 4    | 30   | 1    |



解法代码：

```java
public void testMultiPack1(){
    // 版本一：改变物品数量为01背包格式
    List<Integer> weight = new ArrayList<>(Arrays.asList(1, 3, 4));
    List<Integer> value = new ArrayList<>(Arrays.asList(15, 20, 30));
    List<Integer> nums = new ArrayList<>(Arrays.asList(2, 3, 2));
    int bagWeight = 10;

    for (int i = 0; i < nums.size(); i++) {
        while (nums.get(i) > 1) { // 把物品展开为i
            weight.add(weight.get(i));
            value.add(value.get(i));
            nums.set(i, nums.get(i) - 1);
        }
    }

    int[] dp = new int[bagWeight + 1];
    for(int i = 0; i < weight.size(); i++) { // 遍历物品
        for(int j = bagWeight; j >= weight.get(i); j--) { // 遍历背包容量
            dp[j] = Math.max(dp[j], dp[j - weight.get(i)] + value.get(i));
        }
        System.out.println(Arrays.toString(dp));
    }
}

public void testMultiPack2(){
    // 版本二：改变遍历个数
    int[] weight = new int[] {1, 3, 4};
    int[] value = new int[] {15, 20, 30};
    int[] nums = new int[] {2, 3, 2};
    int bagWeight = 10;

    int[] dp = new int[bagWeight + 1];
    for(int i = 0; i < weight.length; i++) { // 遍历物品
        for(int j = bagWeight; j >= weight[i]; j--) { // 遍历背包容量
            // 以上为01背包，然后加一个遍历个数
            for (int k = 1; k <= nums[i] && (j - k * weight[i]) >= 0; k++) { // 遍历个数
                dp[j] = Math.max(dp[j], dp[j - k * weight[i]] + k * value[i]);
            }
            System.out.println(Arrays.toString(dp));
        }
    }
}
```



## 二十一、背包问题的总结

递推公式：

![20.png (912×592) (raw.githubusercontent.com)](https://raw.githubusercontent.com/vankykoo/image/main/pic/20.png)



思维导图：

![](https://code-thinking-1253855093.file.myqcloud.com/pics/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%981.jpeg)



## 二十二、打家劫舍

### 题目

![](https://raw.githubusercontent.com/vankykoo/javaStudy/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E9%A2%98%E7%9B%AE/dp/225.png)

### 思路

主要是考虑这家偷还是不偷。偷的话要根据前面倒数第二家加上当前这家，不偷的话就按前面第一家算。

动规五部曲：

①dp[i]的含义：走到第 i 家能获得的最大钱数为dp[i]

②递推公式：

偷就是：`dp[i - 2] + nums[i]`

不偷就是：`dp[i - 1]`

比较一下看看偷不偷

`dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i]);`

③初始化：因为递推公式用到前面第二个，所以要初始化两个。

`dp[0] = nums[0];`

`dp[1] = Math.max(nums[0], nums[1]);`

④遍历顺序：从前往后

⑤打印dp数组



### 代码

```java
class Solution {
    public int rob(int[] nums) {
        int len = nums.length;
        if(len == 1){
            return nums[0];
        }
        
        int[] dp = new int[len];
        dp[0] = nums[0];
        dp[1] = Math.max(nums[0],nums[1]);

        for(int i = 2; i < len ; i++){
            dp[i] = Math.max(nums[i] + dp[i - 2],dp[i - 1]);
        }

        return dp[len - 1];
    }
}
```





## 二十三、打家劫舍Ⅱ

### 题目

![](https://raw.githubusercontent.com/vankykoo/javaStudy/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E9%A2%98%E7%9B%AE/dp/226.png)



### 思路

房间成环，意思是最后一间和第一间不能同时选。

把圆圈变成直线。

那么分成三种情况：

​	①首尾都不选

​	②首选，尾不选

​	③首不选，尾选

而情况二三已经包含了情况一了。所以只对情况二，情况三进行第一次打家劫舍的思路，看看谁大就选谁。



### 代码

```java
class Solution {
    public int rob(int[] nums) {
        if (nums == null || nums.length == 0)
            return 0;
        int len = nums.length;
        if (len == 1)
            return nums[0];
        return Math.max(robAction(nums, 0, len - 1), robAction(nums, 1, len));
    }

    int robAction(int[] nums, int start, int end) {
        int x = 0, y = 0, z = 0;
        for (int i = start; i < end; i++) {
            y = z;
            z = Math.max(y, x + nums[i]);
            x = y;
        }
        return z;
    }
}
```



## 二十四、打家劫舍Ⅲ

### 题目

![](https://raw.githubusercontent.com/vankykoo/javaStudy/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E9%A2%98%E7%9B%AE/dp/228.png)



### 思路

二叉树，肯定是要考虑遍历顺序的，这里选**后序遍历**，因为父节点偷不偷要看子节点偷不偷。

还要使用到动态规划，因为这个偷不偷要看上一个人的脸色，与上一个有关。

动规五部曲 + 递归：

①dp数组：每一层递归都有属于自己的dp数组，dp数组只有两个元素，第一个是如果当前节点不偷能获得的最大钱数，第二个元素是如果当前节点偷，能获得的最大钱数，遇到空节点直接返回0。那么dp[0]代表不偷，dp[1]代表不偷。递归的返回值也是这个dp数组，因为上一层要看下一层脸色。

②遍历顺序：后序遍历

③递推公式：

**不偷** ：就是取两个字节的偷或不偷的最大值，因为自己不偷，子节点偷不偷的无所谓，钱多就行。

**偷** ：就是字节的都不偷的钱，加上当前节点的钱。

       	1. 不偷：dp[1] = Math.max(left[0], left[1]) + Math.max(right[0] + right[1]);
        	2. 偷：dp[0] = left[0] + right[0] + root.val;



### 代码

```java
class Solution {
    public int rob(TreeNode root) {
        int[] res = robAction1(root);
        return Math.max(res[0], res[1]);
    }

    int[] robAction1(TreeNode root) {
        int res[] = new int[2];
        if (root == null)
            return res;

        int[] left = robAction1(root.left);
        int[] right = robAction1(root.right);

        res[0] = Math.max(left[0], left[1]) + Math.max(right[0], right[1]);
        res[1] = root.val + left[0] + right[0];
        return res;
    }
}
```



## 二十五、买卖股票的最佳时机

### 题目

![](https://raw.githubusercontent.com/vankykoo/javaStudy/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E9%A2%98%E7%9B%AE/dp/232.png)

### 思路

定义一个二维数组，每一层有两个值，一个值是记录持有彩票时可拥有的最多钱，另一个值记录不持有彩票时可拥有的最多钱。

动规五部曲：

①dp\[i][0]的含义：持有彩票时可拥有的最多钱；dp\[i][1]的含义：不持有彩票时可拥有的最多钱。

②递推公式：

* 如果想持有彩票，即dp\[i][0]的取值：

  * 第i-1天就持有股票，那么就保持现状，所得现金就是昨天持有股票的所得现金 即：dp\[i - 1][0]
  * 第i天买入股票，所得现金就是买入今天的股票后所得现金即：-prices[i]

  `dp[i][0] = max(dp[i - 1][0], -prices[i]);`



* 如果不想持有彩票，即dp\[i][1]的取值：

  * 第i-1天就不持有股票，那么就保持现状，所得现金就是昨天不持有股票的所得现金 即：dp\[i - 1][1]
  * 第i天卖出股票，所得现金就是按照今天股票价格卖出后所得现金即：prices[i] + dp\[i - 1][0]

  `dp[i][1] = max(dp[i - 1][1], prices[i] + dp[i - 1][0]);`

③初始化：

dp\[i][0]：持有彩票：dp\[i][0] -= prices[0];

dp\[i][1] ：不持有彩票：dp\[i][1] = 0;

④遍历顺序：从前往后遍历

⑤打印dp数组



### 代码

```java
class Solution {
    public int maxProfit(int[] prices) {
        if (prices == null || prices.length == 0) return 0;
        int length = prices.length;
        // dp[i][0]代表第i天持有股票的最大收益
        // dp[i][1]代表第i天不持有股票的最大收益
        int[][] dp = new int[length][2];
        int result = 0;
        dp[0][0] = -prices[0];
        dp[0][1] = 0;
        for (int i = 1; i < length; i++) {
            dp[i][0] = Math.max(dp[i - 1][0], -prices[i]);
            dp[i][1] = Math.max(dp[i - 1][0] + prices[i], dp[i - 1][1]);
        }
        return dp[length - 1][1];
    }
}
```





## 二十六、买卖股票的最佳时机Ⅱ

### 题目

![233.png (906×1120) (raw.githubusercontent.com)](https://raw.githubusercontent.com/vankykoo/javaStudy/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E9%A2%98%E7%9B%AE/dp/233.png)



### 思路

* 我的思路：
  * 和上一题差不多，递推公式有一点变化。
  * 一但有钱赚就卖出去，如果卖出去的话要置零，即从当前节点从新开始。
* 答案思路：
  * 把赚的钱记录在dp数组里面，没有另设一个result值。
  * 如果有钱赚就累加起来。



### 代码

我的代码

```java
class Solution {
    public int maxProfit(int[] prices) {
        int len = prices.length;
        if(len == 0) return 0;

        int result = 0;
        int[][] dp = new int[len][2];

        //初始化
        dp[0][0] = 0;
        dp[0][1] -= prices[0];

        for(int i = 1; i < len; i++){
            int sellPrice = prices[i] + dp[i - 1][1];

            if(sellPrice > 0){
                //卖了
                result += sellPrice;
                dp[i][0] = 0;
                dp[i][1] = 0 - prices[i];
                continue;
            }else{
                dp[i][0] = Math.max(dp[i - 1][0], sellPrice);
                dp[i][1] = Math.max(dp[i - 1][1], 0 - prices[i]);
            }

        }

        return result;
    }
}
```

答案代码

```java
class Solution 
    // 实现1：二维数组存储
    // 可以将每天持有与否的情况分别用 dp[i][0] 和 dp[i][1] 来进行存储
    // 时间复杂度：O(n)，空间复杂度：O(n)
    public int maxProfit(int[] prices) {
        int n = prices.length;
        int[][] dp = new int[n][2];     // 创建二维数组存储状态
        dp[0][0] = 0;                   // 初始状态
        dp[0][1] = -prices[0];
        for (int i = 1; i < n; ++i) {
            dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]);    // 第 i 天，没有股票
            dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] - prices[i]);    // 第 i 天，持有股票
        }
        return dp[n - 1][0];    // 卖出股票收益高于持有股票收益，因此取[0]
    }
}
```



## 二十七、买卖股票的最佳时机Ⅲ

### 题目

![235.png (896×1195) (raw.githubusercontent.com)](https://raw.githubusercontent.com/vankykoo/javaStudy/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E9%A2%98%E7%9B%AE/dp/235.png)

### 思路

难点：可以买卖两次。



①dp数组的含义

* 分为四种状态：
  1. 第一次持有股票
  2. 第一次不持有股票
  3. 第二次持有股票
  4. 第二次不持有股票

dp\[i][j] 表示第 i 天，第 j 种状态可拥有的最大钱数。

②递推公式：

达到dp\[i][1]状态，有两个具体操作：

- 操作一：**第i天买入股票了**，那么dp\[i][1] = dp\[i-1][0] - prices[i]
- 操作二：**第i天没有操作**，而是沿用前一天买入的状态，即：dp\[i][1] = dp\[i - 1][1]

那么dp\[i][1]究竟选 dp\[i-1][0] - prices[i]，还是dp\[i - 1][1]呢？

一定是选最大的，所以 dp\[i][1] = max(dp\[i-1][0] - prices[i], dp\[i - 1][1]);

同理dp\[i][2]也有两个操作：

- 操作一：**第i天卖出股票了**，那么dp\[i][2] = dp\[i - 1][1] + prices[i]
- 操作二：**第i天没有操作**，沿用前一天卖出股票的状态，即：dp\[i][2] = dp\[i - 1][2]

所以dp\[i][2] = max(dp\[i - 1][1] + prices[i], dp\[i - 1][2])

同理可推出剩下状态部分：

dp\[i][3] = max(dp\[i - 1][3], dp\[i - 1][2] - prices[i]);

dp\[i][4] = max(dp\[i - 1][4], dp\[i - 1][3] + prices[i]);

③初始化：只需要初始化两个拥有彩票的状态即可

dp\[0][1] = -price[0];

dp\[0][3] = -price[0];

其他都为0.

④遍历顺序：从前往后

⑤打印dp数组

![](https://code-thinking-1253855093.file.myqcloud.com/pics/20201228181724295-20230310134201291.png)



### 代码

```java
// 版本一
class Solution {
    public int maxProfit(int[] prices) {
        int len = prices.length;
        // 边界判断, 题目中 length >= 1, 所以可省去
        if (prices.length == 0) return 0;

        /*
         * 定义 5 种状态:
         * 0: 没有操作, 1: 第一次买入, 2: 第一次卖出, 3: 第二次买入, 4: 第二次卖出
         */
        int[][] dp = new int[len][5];
        dp[0][1] = -prices[0];
        // 初始化第二次买入的状态是确保 最后结果是最多两次买卖的最大利润
        dp[0][3] = -prices[0];

        for (int i = 1; i < len; i++) {
            dp[i][1] = Math.max(dp[i - 1][1], -prices[i]);
            dp[i][2] = Math.max(dp[i - 1][2], dp[i - 1][1] + prices[i]);
            dp[i][3] = Math.max(dp[i - 1][3], dp[i - 1][2] - prices[i]);
            dp[i][4] = Math.max(dp[i - 1][4], dp[i - 1][3] + prices[i]);
        }

        return dp[len - 1][4];
    }
}

// 版本二: 空间优化
class Solution {
    public int maxProfit(int[] prices) {
        int[] dp = new int[4]; 
        // 存储两次交易的状态就行了
        // dp[0]代表第一次交易的买入
        dp[0] = -prices[0];
        // dp[1]代表第一次交易的卖出
        dp[1] = 0;
        // dp[2]代表第二次交易的买入
        dp[2] = -prices[0];
        // dp[3]代表第二次交易的卖出
        dp[3] = 0;
        for(int i = 1; i <= prices.length; i++){
            // 要么保持不变，要么没有就买，有了就卖
            dp[0] = Math.max(dp[0], -prices[i-1]);
            dp[1] = Math.max(dp[1], dp[0]+prices[i-1]);
            // 这已经是第二次交易了，所以得加上前一次交易卖出去的收获
            dp[2] = Math.max(dp[2], dp[1]-prices[i-1]);
            dp[3] = Math.max(dp[3], dp[2]+ prices[i-1]);
        }
        return dp[3];
    }
}
```





## 二十八、买卖股票的最佳时机Ⅳ

### 题目

![236.png (901×962) (raw.githubusercontent.com)](https://raw.githubusercontent.com/vankykoo/javaStudy/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E9%A2%98%E7%9B%AE/dp/236.png)





### 思路

和上一题差不多，只是把两次换成了k次，所以现在分为2k种状态，奇数是持有股票的状态，偶数是不持有股票的状态。

动规五部曲：

①`dp[i][j]`数组的含义：第 i - 1 天 状态为 j 的可获得的最大钱数

每天有两种状态：

```txt
j = 1时，表示第一天持有股票可获得的最大钱数；
j = 2时，表示第一天不持有股票可获得的最大钱数；
j = 3时，表示第二天持有股票可获得的最大钱数；
j = 4时，表示第二天不持有股票可获得的最大钱数；
......
```

②递推公式：

* 奇数时：`dp[i][j] = Math.max(dp[i-1][j - 1] - prices[i], dp[i - 1][j]);`
  * ①今天买 ：`dp[i - 1][j - 1] - prices[i]`
  * ②沿用之前的持有状态：`dp[i - 1][j]`
* 偶数时：`dp[i][j] = Math.max(dp[i - 1][j - 1] + prices[i], dp[i - 1][j]);`
  * ①把昨天的持有的股票卖掉：`dp[i - 1][j - 1] + prices[i]`
  * ②沿用之前的不持有状态：`dp[i - 1][j]`

③初始化dp数组：

第一天如果想持有股票，那只能是买第一天的股票，所以所有的j为奇数的元素都赋值为 `-prices[0]` ，其他赋值为0；

④遍历顺序：

按照prices从前往后

⑤打印dp数组



### 代码

```java
class Solution {
    public int maxProfit(int k, int[] prices) {
        int len = prices.length;
        int[][] dp = new int[len][k * 2 + 1];
        
      //初始化dp数组
        for(int i = 1; i < k * 2 + 1; i += 2){
            dp[0][i] = -prices[0];
        }

        for(int i = 1; i < len; i++){
            for(int j = 1; j < (k * 2 + 1); j++){
                if(j % 2 == 0){
                  //j为偶数
                    dp[i][j] = Math.max(dp[i - 1][j - 1] + prices[i], dp[i - 1][j]);
                }else{
                  //j为奇数
                    dp[i][j] = Math.max(dp[i-1][j - 1] - prices[i], dp[i - 1][j]);
                }
            }
        }

        return dp[len - 1][k * 2];
    }
}
```





## 二十九、买卖股票的最佳时期含冷冻期

### 题目

![238.png (903×816) (raw.githubusercontent.com)](https://raw.githubusercontent.com/vankykoo/javaStudy/7dc1799a3499270662fcb4852f0d30f7d2537d75/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E9%A2%98%E7%9B%AE/dp/238.png)



### 思路

分为四种状态：

![237.png (3068×1174) (raw.githubusercontent.com)](https://raw.githubusercontent.com/vankykoo/javaStudy/7dc1799a3499270662fcb4852f0d30f7d2537d75/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E9%A2%98%E7%9B%AE/dp/237.png)



动规五部曲：

①dp数组的含义：dp\[i][j]表示第 i 天时第 j 种状态可以拥有的最大钱数。

②递推公式：

由上图可知，如果有两种状态，就选比较大的。

则递推公式：

```java
dp[i][0] = Math.max(dp[i][0], dp[i - 1][3], dp[i-1][1] - prices[i]);
dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][3]);
dp[i][2] = dp[i-1][0] + prices[i];
dp[i][3] = dp[i - 1][2];
```

③初始化：

因为各自状态只与当天股价和前一天的状态有关，所以应该初始化第一天的状态。

```java
dp[0][0] = -prices[0];
dp[0][1] = 0;
dp[0][2] = 0;
dp[0][3] = 0;
```

④遍历顺序：从前往后

⑤打印dp数组



### 代码

```java
class Solution {
    public int maxProfit(int[] prices) {
        int len = prices.length;
        if(len <= 1) return 0;

        int[][] dp = new int[len][4];

        //初始化
        dp[0][0] = -prices[0]; 

        for(int i = 1; i < len; i++){
            //状态一
            dp[i][0] = Math.max(dp[i-1][0], Math.max(dp[i - 1][3] - prices[i], dp[i-1][1] - prices[i]));
            //状态二
            dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][3]);
            //状态三
            dp[i][2] = dp[i-1][0] + prices[i];
            //状态四
            dp[i][3] = dp[i - 1][2];
        }

        //返回三种不持有股票中的钱数最大值
        return Math.max(dp[len-1][1],Math.max(dp[len-1][2],dp[len-1][3]));
    }
}
```





## 三十、买卖股票的最佳时期含手续费

### 题目

![239.png (790×1023) (raw.githubusercontent.com)](https://raw.githubusercontent.com/vankykoo/javaStudy/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E9%A2%98%E7%9B%AE/dp/239.png)



### 思路

和之前可以买卖k次的一样，只是在卖股票时加了手续费。



### 代码

```java
class Solution {
    public int maxProfit(int[] prices, int fee) {
        int len = prices.length;
        int[][] dp = new int[len][2];

        //初始化
        dp[0][1] -= prices[0];

        for(int i = 1; i < len; i++){
          //这里0是不持有股票，1是持有股票
            dp[i][0] = Math.max(dp[i-1][0],prices[i] + dp[i-1][1] - fee);
            dp[i][1] = Math.max(dp[i-1][1],dp[i-1][0] - prices[i]);
        }

        return dp[len-1][0];

    }
}
```



```java
//答案：一维数组优化
// 一维数组优化
class Solution {
    public int maxProfit(int[] prices, int fee) {
    int[] dp = new int[2];
    dp[0] = -prices[0];
    dp[1] = 0;
    for (int i = 1; i <= prices.length; i++) {
      //这里0是持有股票，1是不持有股票
      dp[0] = Math.max(dp[0], dp[1] - prices[i - 1]);
      dp[1] = Math.max(dp[1], dp[0] + prices[i - 1] - fee);
    }
    return dp[1];
    }
}
```



## 三十一、最长递增子序列

### 题目

![241.png (759×849) (raw.githubusercontent.com)](https://raw.githubusercontent.com/vankykoo/javaStudy/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E9%A2%98%E7%9B%AE/dp/241.png)



### 思路

我的思路：

* 第一层for：遍历nums数组。


* 第二层for：遍历dp数组
  * 将nums[i] 与 dp[j] 比较，如果nums[i] <= dp[j] 那么就将dp[j] 换成 nums[i] ，然后直接break。如果不break，后面的数都会被换掉。这样做不影响最大长度，而且满足最后的结果是子序列的最大长度，但是这里的dp数组内的元素不是子序列。
* 跳出第二层for循环之后，判断一下nums[i] 是否 大于dp数组的最后一个数，如果大于，那么dp数组的长度要加一。【在第一层for循环内】



以 `nums = [10,9,2,5,3,7,101,18]` 为例：

![240.png (1023×452) (raw.githubusercontent.com)](https://raw.githubusercontent.com/vankykoo/javaStudy/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E9%A2%98%E7%9B%AE/dp/240.png)

### 代码

我的代码【4ms，答案70ms，我的比答案快嘿嘿】

```java
class Solution {
    public int lengthOfLIS(int[] nums) {
        int len = nums.length;
        if(len == 1){
            return 1;
        }

        int[] dp = new int[len];
        int maxLen = 0;

        dp[0] = nums[0];
        maxLen = 1;

        for(int i = 1; i < len; i++){
            for(int j = 0; j < maxLen; j++){
                if(nums[i] <= dp[j]){
                    dp[j] = nums[i];
                    break;
                }
            }

            if(nums[i] > dp[maxLen - 1]){
                dp[maxLen] = nums[i];
                maxLen++;
            }
        }

        return maxLen;
    }
}
```

答案代码：

```java
class Solution {
    public int lengthOfLIS(int[] nums) {
        int[] dp = new int[nums.length];
        int res = 0;
        Arrays.fill(dp, 1);
        for (int i = 1; i < dp.length; i++) {
            for (int j = 0; j < i; j++) {
                if (nums[i] > nums[j]) {
                    dp[i] = Math.max(dp[i], dp[j] + 1);
                }
                res = Math.max(res, dp[i]);
            }
        }
        return res;
    }
}
```



## 三十二、最长连续递增序列

### 题目

![242.png (801×847) (raw.githubusercontent.com)](https://raw.githubusercontent.com/vankykoo/javaStudy/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E9%A2%98%E7%9B%AE/dp/242.png)

### 思路

动规五部曲：

①dp[i] 的含义：表示到 nums[i] 的时候，已经连续递增的长度

②递推公式：

​	如果nums[i] 大于nums[i-1] ，那么就让`dp[i] = dp[i-1] + 1;` 然后更新res值。

​	如果nums[i] 不大于 nums[i-1]，说明递增序列断了，就让 `dp[i] = 1`；

③dp数组初始化：让dp[0] = 1；

④遍历顺序：从前往后

⑤打印dp数组。



### 代码

```java
class Solution {
    public int findLengthOfLCIS(int[] nums) {
        int len = nums.length;
        int[] dp = new int[len];

        dp[0] = 1;
        int res = 1;

        for(int i = 1; i < len; i++){
            if(nums[i] > nums[i - 1]){
                dp[i] = dp[i - 1] + 1;
                res = Math.max(res,dp[i]);
            }else{
                dp[i] = 1;
            }
        }

        return res;
    }
}
```



## 三十三、最长重复子数组

### 题目

![001.png (901×676) (raw.githubusercontent.com)](https://raw.githubusercontent.com/vankykoo/javaStudy/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E9%A2%98%E7%9B%AE/dp/001.png)

### 思路

动规五部曲：

①dp\[i][j]数组的含义：表示`数组1的下标为 i - 1 的元素`与`数组2的下标的为 j - 1 的元素` 及它们之前有多少个相同的元素。

②递推公式：双重for循环，把所有元素都遍历一遍遇到相同的两个相同的元素，只需要把两个元素的上一个元素的相同数加一即可。【这么说可能有点抽象，看图就知道了】

![](https://code-thinking-1253855093.file.myqcloud.com/pics/2021011215282060-20230310134554486.jpg)

③初始化：dp\[i][0] 和 dp\[0][i] 都要赋值为0。

④遍历顺序：都是从前往后遍历。

⑤打印dp数组





### 代码

```java
class Solution {
    public int findLength(int[] nums1, int[] nums2) {
        int len1 = nums1.length;
        int len2 = nums2.length;

        int[][] dp = new int[len1+1][len2+1];
        int res = 0;

        for(int i = 0; i < len1; i++){
            for(int j = 0; j < len2; j++){
                if(nums1[i] == nums2[j]){
                    dp[i+1][j+1] = dp[i][j] + 1;
                    res = Math.max(res,dp[i+1][j+1]);
                }
            }
        }

        return res;
    }
}
```





## 三十四、最长公共子序列

### 题目

![025.png (908×1044) (raw.githubusercontent.com)](https://raw.githubusercontent.com/vankykoo/javaStudy/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E9%A2%98%E7%9B%AE/dp/025.png)

### 思路

以text1 = "abcde" 和 text2 = "ace" 举例。

动规五部曲：

①dp\[i][j] 的含义：表示 从 text1 的[0, i-1] 的部分 和 text2的[0，j-1] 的部分的最长公共子序列。

比如dp\[4][2]  ： 表示 "abcd" 和 "ac" 的最长公共子序列

②递推公式：分为两种情况：

1. 两个字符不相等：

   那么就取 `dp[i+1][j+1] = dp[i][j+1] + dp[i+1][j];`

   比如 text1 的 d 和 text2 的 e 不相等，那么就看，"abcd" 和 “ac" 的最长公共子序列  与   "abc" 与  "ace"的最长公共子序列的较大值。

2. 两个字符相等：

   那么就取 `dp[i+1][j+1] = dp[i][j] + 1;`

   比如 text1 的 e 和 text2 的 e 相等，那么就是 "abcd" 与 "ac" 的最长公共子序列 + 1；

③初始化：`dp[0][j]` 和 `dp[i][0]` 初始化为0。

④遍历顺序：从前往后，双重for循环。

⑤打印dp数组：

![](https://code-thinking-1253855093.file.myqcloud.com/pics/20210210150215918.jpg)



### 代码

```java
class Solution {
    public int longestCommonSubsequence(String text1, String text2) {
        int len1 = text1.length();
        int len2 = text2.length();

        int[][] dp = new int[len1+1][len2+1];

        for(int i = 0; i < len1; i++){
            for(int j = 0; j < len2; j++){
                if(text1.charAt(i) == text2.charAt(j)){
                    dp[i+1][j+1] = dp[i][j] + 1;
                }else {
                    dp[i+1][j+1] = Math.max(dp[i][j+1],dp[i+1][j]);
                }
            }
        }

        return dp[len1][len2];
    }
}
```





## 三十五、不相交的线

### 题目

![](https://raw.githubusercontent.com/vankykoo/javaStudy/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E9%A2%98%E7%9B%AE/dp/030.png)

### 思路

简单分析一下题目，就是和上一题“最长公共子序列”一样的题目。



###代码

```java
class Solution {
    public int maxUncrossedLines(int[] nums1, int[] nums2) {
        int len1 = nums1.length;
        int len2 = nums2.length;

        int[][] dp = new int[len1 + 1][len2 + 1];

        for(int i = 0; i < len1; i++){
            for(int j = 0; j < len2; j++){
                if(nums1[i] == nums2[j]){
                    dp[i+1][j+1] = dp[i][j] + 1;
                }else{
                    dp[i+1][j+1] = Math.max(dp[i][j+1], dp[i+1][j]);
                }
            }
        }

        return dp[len1][len2];
    }
}
```





##三十六、最大子数组和

###题目

![031.png (901×930) (raw.githubusercontent.com)](https://raw.githubusercontent.com/vankykoo/javaStudy/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E9%A2%98%E7%9B%AE/dp/031.png)

### 思路

动规五部曲：

①dp[i] 的含义：数组nums 从 0 到 i 的最大子数组和。

②递推公式：

* **我的递推公式**：
  * 如果从 0 到 i - 1 的最大子数组和 小于零了，那就不要计入到之后的子数组里了，就从当前元素开始计算即 `dp[i] = nums[i];`
  * 如果是大于零的，那么就可以继续做子数组，`dp[i] = dp[i - 1] + nums[i];`
* **答案的递推公式**：直接看上面两个谁大就选谁。
  * 即 `dp[i] = Math.max(nums[i], dp[i-1] + nums[i]);`

其实都可以，因为递推公式后面还有一个选取较大的res 的逻辑，保证选择的是最大的子数组和。

③初始化：dp[0] = nums[0];     res = nums[0];

④遍历顺序：从前往后即可

⑤打印dp数组

![](https://code-thinking-1253855093.file.myqcloud.com/pics/20210303104129101.png)



### 代码

```java
//我的代码
class Solution {
    public int maxSubArray(int[] nums) {
        int len = nums.length;
        if(len == 1){
            return nums[0];
        }

        int[] dp = new int[len];
        dp[0] = nums[0];
        int res = nums[0];

        for(int i = 1; i < len;i++){
            if(dp[i-1] < 0){
                dp[i] = nums[i];
            }else{
                dp[i] = dp[i-1] + nums[i];
            }

            if(dp[i] > res){
                res = dp[i];
            }
        }

        return res;
    }
}
```



```java
//答案代码
public static int maxSubArray(int[] nums) {
  if (nums.length == 0) {
    return 0;
  }

  int res = nums[0];
  int[] dp = new int[nums.length];
  dp[0] = nums[0];
  for (int i = 1; i < nums.length; i++) {
    dp[i] = Math.max(dp[i - 1] + nums[i], nums[i]);
    res = res > dp[i] ? res : dp[i];
  }
  return res;
}
```



## 三十七、判断子序列

### 题目

![032.png (838×990) (raw.githubusercontent.com)](https://raw.githubusercontent.com/vankykoo/javaStudy/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E9%A2%98%E7%9B%AE/dp/032.png)



### 思路

其实和寻找最大子序列长度的题目一样，找出最大长度，看是不是等于 s 字符串的长度就行了。



### 代码

```java
class Solution {
    public boolean isSubsequence(String s, String t) {
        int len1 = s.length();
        int len2 = t.length();

        int[][] dp = new int[len1+1][len2+1];

        for(int i = 0; i < len1; i++){
            for(int j = 0; j < len2; j++){
                if(s.charAt(i) == t.charAt(j)){
                    dp[i+1][j+1] = dp[i][j] + 1;
                }else {
                    dp[i+1][j+1] = Math.max(dp[i][j+1], dp[i+1][j]);
                }
            }
        }

        return dp[len1][len2] == len1;
    }
}
```



## 三十八、不同的子序列

### 题目

![038.png (838×974) (raw.githubusercontent.com)](https://raw.githubusercontent.com/vankykoo/javaStudy/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E9%A2%98%E7%9B%AE/dp/038.png)

### 思路

动规五部曲：

①dp\[i][j] 的含义：字符串s 在[0, i-1] 区间 的子序列 中 t [0,j-1] 出现的个数。

例如：s = rabbbit      t = rabbit

 dp\[5][3]表示 rabbb的子序列中 rab 出现的个数。

②递推公式：

* 如果 两个字符相等：`dp[j+1][i+1] = dp[j][i+1] + dp[j][i];`
* 如果两个字符不相等：`dp[j+1][i+1] = dp[j][i+1];`

③初始化：

把s对应的第一行或是第一列初始化为1【看你s是行还是列】

④遍历顺序：

双重for循环，外层是t，内层是s，从前往后

⑤打印dp数组：

![](https://code-thinking.cdn.bcebos.com/pics/115.%E4%B8%8D%E5%90%8C%E7%9A%84%E5%AD%90%E5%BA%8F%E5%88%97.jpg)



### 代码

```java
//我的代码
class Solution {
    public int numDistinct(String s, String t) {
        int len1 = s.length();
        int len2 = t.length();

        int[][] dp = new int[len1+1][len2+1];
        for(int i = 0; i < len1; i++){
            dp[i][0] = 1;
        }

        for(int i = 0; i < len2; i++){
            for(int j = i; j < len1; j++){
                if(s.charAt(j) == t.charAt(i)){
                    dp[j+1][i+1] = dp[j][i+1] + dp[j][i];
                }else{
                    dp[j+1][i+1] = dp[j][i+1];
                }
            }
        }

        return dp[len1][len2];
    }
}
```

答案代码

```java
class Solution {
    public int numDistinct(String s, String t) {
        int[][] dp = new int[s.length() + 1][t.length() + 1];
        for (int i = 0; i < s.length() + 1; i++) {
            dp[i][0] = 1;
        }
        
        for (int i = 1; i < s.length() + 1; i++) {
            for (int j = 1; j < t.length() + 1; j++) {
                if (s.charAt(i - 1) == t.charAt(j - 1)) {
                    dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];
                }else{
                    dp[i][j] = dp[i - 1][j];
                }
            }
        }
        
        return dp[s.length()][t.length()];
    }
}
```





## 三十九、两个字符串的删除操作

### 题目

![039.png (835×722) (raw.githubusercontent.com)](https://raw.githubusercontent.com/vankykoo/javaStudy/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E9%A2%98%E7%9B%AE/dp/039.png)



### 思路

其实就在找 公共最长子序列 ，然后让两个字符串都减去 这个长度，相加，就是最后结果了



### 代码

```java
class Solution {
    public int minDistance(String word1, String word2) {
        int len1 = word1.length();
        int len2 = word2.length();

        int[][] dp = new int[len1+1][len2+1];
        
        for(int i = 0; i < len1; i++){
            for(int j = 0; j < len2; j++){
                if(word1.charAt(i) == word2.charAt(j)){
                    dp[i+1][j+1] = dp[i][j] + 1;
                }else{
                    dp[i+1][j+1] = Math.max(dp[i+1][j], dp[i][j+1]);
                }
            }
        }

        return len1 + len2 - 2 * dp[len1][len2];
    }
}
```





## 四十、编辑距离

### 题目

![040.png (828×1054) (raw.githubusercontent.com)](https://raw.githubusercontent.com/vankykoo/javaStudy/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E9%A2%98%E7%9B%AE/dp/040.png)

### 思路

动规五部曲

①dp\[i][j] 的含义：**表示以下标i-1为结尾的字符串word1，和以下标j-1为结尾的字符串word2，最近编辑距离为`dp[i][j]`**。

②递推公式：

* word2.charAt(i) == word1.charAt(j) 时不操作
  * `dp[i][j] = dp[i-1][j-1]`
* word2.charAt(i) != word1.charAt(j) 时操作
  * 删除、插入操作：`dp[i][j] = Math.min(dp[i][j - 1],dp[i - 1][j]) + 1;`
  * 替换操作：`dp[i][j] = dp[i - 1][j - 1] + 1`

所有，总的递推公式是取他们的最小值：``

`dp[i][j] = Math.min(dp[i-1][j-1], Math.min(dp[i][j-1], dp[i-1][j])) + 1;`

③初始化：下标为0 表示空字符串。

所以`for(int i = 0; i < len1; i++) dp[0][i] = i;`

​	`for(int i = 0; i < len2; i++) dp[i][0] = i;`

④遍历顺序：双层for循环，从前往后

⑤打印dp数组

![](https://code-thinking-1253855093.file.myqcloud.com/pics/20210114162132300.jpg)





### 代码

```java
public int minDistance(String word1, String word2) {
    int m = word1.length();
    int n = word2.length();
    int[][] dp = new int[m + 1][n + 1];
    // 初始化
    for (int i = 1; i <= m; i++) {
        dp[i][0] =  i;
    }
    for (int j = 1; j <= n; j++) {
        dp[0][j] = j;
    }
    for (int i = 1; i <= m; i++) {
        for (int j = 1; j <= n; j++) {
            // 因为dp数组有效位从1开始
            // 所以当前遍历到的字符串的位置为i-1 | j-1
            if (word1.charAt(i - 1) == word2.charAt(j - 1)) {
                dp[i][j] = dp[i - 1][j - 1];
            } else {
                dp[i][j] = Math.min(Math.min(dp[i - 1][j - 1], dp[i][j - 1]), dp[i - 1][j]) + 1;
            }
        }
    }
    return dp[m][n];
}
```





## 四十一、回文子串

### 题目

![042.png (827×945) (raw.githubusercontent.com)](https://raw.githubusercontent.com/vankykoo/javaStudy/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E9%A2%98%E7%9B%AE/dp/042.png)

### 思路

动规五部曲：

①`dp[i][j]` 的含义：表示下标从 i 到 j 的字符串是不是回文串。

②递推公式：

* 判断从i 到 j 是不是回文串，先判断下标为 i 和 j 的字符是否相等，如果相等，看 下标从 i + 1 到 j - 1 的子串是不是回文串。
* 一个字符和两个相同字符也是回文串。

所以：

```java
if (s.charAt(i) == s.charAt(j)) {
    if (j - i <= 1) { //一个字符或两个相同的字符
        result++;
        dp[i][j] = true;
    } else if (dp[i + 1][j - 1]) { 
        result++;
        dp[i][j] = true;
    }
}
```

③dp数组的初始化：都初始化为false

④遍历顺序：因为`dp[i][j]` 需要通过`dp[i+1][j-1]` 推得，所以 i 要倒序遍历，j 要正序遍历。

⑤打印dp数组：

![](https://code-thinking-1253855093.file.myqcloud.com/pics/20210121171059951-20230310132153163.jpg)



方法二：双指针法

* 两种情况：
  * 单数长度的字符串
  * 双数长度的字符串



### 代码

动态规划

```java
class Solution {
    public int countSubstrings(String s) {
        char[] chars = s.toCharArray();
        int len = chars.length;
        boolean[][] dp = new boolean[len][len];
        int result = 0;
        for (int i = len - 1; i >= 0; i--) {
            for (int j = i; j < len; j++) {
                if (chars[i] == chars[j]) {
                    if (j - i <= 1) { // 情况一 和 情况二
                        result++;
                        dp[i][j] = true;
                    } else if (dp[i + 1][j - 1]) { //情况三
                        result++;
                        dp[i][j] = true;
                    }
                }
            }
        }
        return result;
    }
}
```



双指针法：

```java
class Solution {
    public int countSubstrings(String s) {
        char[] chars = s.toCharArray();
        int result = 0;
        for (int i = 0; i < chars.length; i++) {
            result += extend(chars, i, i, chars.length); // 以i为中心
            result += extend(chars, i, i + 1, chars.length); // 以i和i+1为中心
        }
        return result;
    }
  
  public int extend(char[] chars,int i, int j, int n){
   	    int res = 0;
        while (i >= 0 && j < n && chars[i] == chars[j]) {
            i--;
            j++;
            res++;
        }
        return res;
  }
}
```





## 四十二、最长回文子序列

### 题目

![052.png (830×752) (raw.githubusercontent.com)](https://raw.githubusercontent.com/vankykoo/javaStudy/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E9%A2%98%E7%9B%AE/dp/052.png)



### 思路

动规五部曲

①`dp[i][j]` 的含义：字符串s在[i, j]范围内最长的回文子序列的长度为`dp[i][j]`。

②递推公式：

* 如果s[i] == s[j] ：那么`dp[i][j] == dp[i+1][j-1] + 2;`

* 如果s[i] != s[j] ：那么就选择删掉一个，看哪个小就删哪个，取那个大的。

  `dp[i][j] = Math.max(dp[i+1][j], dp[i][j-1]);`

③初始化：需要初始化单个字符都是回文串的情况，即`dp[i][i] = 1;`

④遍历顺序：看递推公式可以看出，i 必须从后面开始遍历，j 必须从前面开始遍历。

⑤打印dp数组：![](https://code-thinking-1253855093.file.myqcloud.com/pics/20210127151521432.jpg)



### 代码

```java
public class Solution {
    public int longestPalindromeSubseq(String s) {
        int len = s.length();
        int[][] dp = new int[len + 1][len + 1];
        for (int i = len - 1; i >= 0; i--) { // 从后往前遍历 保证情况不漏
            dp[i][i] = 1; // 初始化
            for (int j = i + 1; j < len; j++) {
                if (s.charAt(i) == s.charAt(j)) {
                    dp[i][j] = dp[i + 1][j - 1] + 2;
                } else {
                    dp[i][j] = Math.max(dp[i + 1][j], Math.max(dp[i][j], dp[i][j - 1]));
                }
            }
        }
        return dp[0][len - 1];
    }
}
```





## 四十三、总结

![](https://kstar-1253855093.cos.ap-nanjing.myqcloud.com/baguwenpdf/_%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE_%E9%9D%92.png)























