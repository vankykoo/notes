# 二叉树

## 零、定义

```java
public class TreeNode{
  int val;//元素数据
  TreeNode left;//左子树
  TreeNode right;//右子树
  //构造函数
  TreeNode(){}
  TreeNode(int val){
  	this.val = val;
  }
  TreeNode(int val, TreeNode left, TreeNode right){
    this.val = val;
    this.left = left;
    this.right = right;
  }
}
```



## 一、二叉树的递归遍历

### 1）递归

①**确定递归函数的参数和返回值**：确定哪些参数是递归过程中需要处理的，那么就在递归函数里加上这个函数，并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。

②**确定终止条件**：写完了递归算法，运行的时候经常会遇到栈溢出的错误，就是没写终止条件或者终止条件没写对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。

③**确定单层递归的逻辑**：确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。



### 2）前序遍历

```java
//中-左-右
class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> list = new ArrayList<>();
        preorder(root,list);
        return list;
    }

    public void preorder(TreeNode root,List<Integer> list){
        if(root == null){
            return;
        }
        list.add(root.val);
        preorder(root.left,list);
        preorder(root.right,list);
    }
}
```



### 3）中序排序

```java
//左-中-右
class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> list = new ArrayList<>();
        preorder(root,list);
        return list;
    }

    public void preorder(TreeNode root,List<Integer> list){
        if(root == null){
            return;
        }
        preorder(root.left,list);
        list.add(root.val);
        preorder(root.right,list);
    }
}
```



### 4）后序排序

```java
//左-右-中
class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> list = new ArrayList<>();
        preorder(root,list);
        return list;
    }

    public void preorder(TreeNode root,List<Integer> list){
        if(root == null){
            return;
        }
        preorder(root.left,list);
        preorder(root.right,list);
        list.add(root.val);
    }
}
```





## 二、二叉树的迭代遍历

### 1）前序遍历

出栈后，分别将其右孩子和左孩子入栈。

![](https://code-thinking.cdn.bcebos.com/gifs/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%88%E8%BF%AD%E4%BB%A3%E6%B3%95%EF%BC%89.gif)

```java
//前序遍历顺序：中-左-右，入栈顺序：中-左-右
class Solution {
  public List<Integer> preorderTraversal(TreeNode root) {
    List<Integer> result = new ArrayList<>();
    // 如果根节点为空，则二叉树为空，直接返回空列表
    if (root == null) {
      return result;
    }
    Stack<TreeNode> stack = new Stack<>();
    stack.push(root);
    while (!stack.isEmpty()) {
      // 弹出栈顶节点并将其值添加到结果列表中（先访问）
      TreeNode node = stack.pop();
      result.add(node.val);
      // 将当前节点的右子节点（如果存在）压入栈中，保证后访问右子节点
      if (node.right != null) {
        stack.push(node.right);
      }
      // 将当前节点的左子节点（如果存在）压入栈中，但由于是后添加，所以会在右子节点之前被访问（左-根-右顺序）
      if (node.left != null) {
        stack.push(node.left);
      }
    }
    // 遍历完成后，返回包含所有节点值按照前序遍历顺序排列的结果列表
    return result;
  }
}
```



### 2）中序遍历

**在使用迭代法写中序遍历，就需要借用指针的遍历来帮助访问节点，栈则用来处理节点上的元素。**

※入栈后，将其左孩子入栈，直到为空。

​	出栈后，将其右孩子入栈。

![](https://code-thinking.cdn.bcebos.com/gifs/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%88%E8%BF%AD%E4%BB%A3%E6%B3%95%EF%BC%89.gif)

```java
class Solution {
  public List<Integer> inorderTraversal(TreeNode root) {
    List<Integer> result = new ArrayList<>();
    if (root == null) {
      return result;
    }
    Stack<TreeNode> stack = new Stack<>();
    // 初始化一个指针变量cur指向当前待访问的节点，初始化时设为根节点
    TreeNode cur = root;

    while (cur != null || !stack.isEmpty()) {
      // 将当前节点（如果非空）一直向左移动，直到到达最左边的叶子节点
      if (cur != null) {
        stack.push(cur);
        cur = cur.left;
      } 
      // 当当前节点为空时，表示已经到达某个子树的最左边，此时从栈顶弹出一个节点并访问
      else {
        // 弹出栈顶节点并将其值添加到结果列表中（中序遍历在访问完左子树后访问父节点）
        cur = stack.pop();
        result.add(cur.val);
        // 移动到当前节点（刚刚访问过的节点）的右子节点
        cur = cur.right;
      }
    }
    return result;
  }
}
```



### 3）后序遍历

再来看后序遍历，先序遍历是中左右，后续遍历是左右中，那么我们只需要调整一下先序遍历的代码顺序，就变成中右左的遍历顺序，然后在反转result数组，输出的结果顺序就是左右中了，如下图：![](https://code-thinking-1253855093.file.myqcloud.com/pics/20200808200338924.png)

```java
class Solution{
  public List<Integer> postorderTraversal(TreeNode root){
    List<Integer> result = new ArrayList<>();
    if(root == null){
      return result;
    }
    Stack<TreeNode> stack = new Stack<>();
    stack.push(root);
    while(!stack.isEmpty()){
      TreeNode node = stack.pop();
      result.add(node.val);
      if(node.left != null){
        stack.push(node.left);
      }
      if(node.right != null){
        stack.push(node.right);
      }
    }
    Collections.reverse(result);
    return result;
  }
}
```



## 三、二叉树迭代遍历统一格式

**将访问的节点放入栈中，把要处理的节点也放入栈中但是要做标记。**

如何标记呢，**就是要处理的节点放入栈之后，紧接着放入一个空指针作为标记。** 这种方法也可以叫做标记法。



前序遍历：

```java
public class Solution {
    public List<Integer> preorderTraversal(TreeNode root){
        List<Integer> result = new LinkedList<>();
        Stack<TreeNode> st = new Stack<>();
        if(root != null) {
            st.push(root);
        }
        while(!st.empty()){
            TreeNode node = st.peek();//查看栈顶元素
            if (node != null){
                st.pop(); //将该节点弹出，避免重复操作，下面再将右中左节点添加到栈中
                if (node.right != null){
                    st.push(node.right);//添加右节点（空节点不入栈）
                }
                if (node.left != null){
                    st.push(node.left);//添加左节点（空节点不入栈）
                }
                st.push(node);//添加中节点
                st.push(null);//中节点访问过，但是没有处理，加入空节点作为标记
            }else {//只有遇到空节点的时候，才将下一个节点放进结果集
                st.pop();   //将空节点弹出
                node = st.peek();   //重新取出栈中元素
                st.pop();
                result.add(node.val);   //加入到结果集
            }
        }
        return result;
    }
}
```



中序遍历

![](https://code-thinking.cdn.bcebos.com/gifs/%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E8%BF%AD%E4%BB%A3%EF%BC%88%E7%BB%9F%E4%B8%80%E5%86%99%E6%B3%95%EF%BC%89.gif)

```java
public class Solution {
    public List<Integer> preorderTraversal(TreeNode root){
        List<Integer> result = new LinkedList<>();
        Stack<TreeNode> st = new Stack<>();
        if(root != null) {
            st.push(root);
        }
        while(!st.empty()){
            TreeNode node = st.peek();
            if (node != null){
                st.pop(); //将该节点弹出，避免重复操作，下面再将右中左节点添加到栈中
                if (node.right != null){
                    st.push(node.right);//添加右节点（空节点不入栈）
                }

                st.push(node);//添加中节点
                st.push(null);//中节点访问过，但是没有处理，加入空节点作为标记
                
                if (node.left != null){
                    st.push(node.left);//添加左节点（空节点不入栈）
                }
            }else {//只有遇到空节点的时候，才将下一个节点放进结果集
                st.pop();   //将空节点弹出
                node = st.peek();   //重新取出栈中元素
                st.pop();
                result.add(node.val);   //加入到结果集
            }
        }
        return result;
    }
}
```



后序遍历

```java
public class Solution {
    public List<Integer> preorderTraversal(TreeNode root){
        List<Integer> result = new LinkedList<>();
        Stack<TreeNode> st = new Stack<>();
        if(root != null) {
            st.push(root);
        }
        while(!st.empty()){
            TreeNode node = st.peek();
            if (node != null){
                st.pop(); //将该节点弹出，避免重复操作，下面再将右中左节点添加到栈中

                st.push(node);//添加中节点
                st.push(null);//中节点访问过，但是没有处理，加入空节点作为标记

                if (node.right != null){
                    st.push(node.right);//添加右节点（空节点不入栈）
                }
                if (node.left != null){
                    st.push(node.left);//添加左节点（空节点不入栈）
                }
            }else {//只有遇到空节点的时候，才将下一个节点放进结果集
                st.pop();   //将空节点弹出
                node = st.peek();   //重新取出栈中元素
                st.pop();
                result.add(node.val);   //加入到结果集
            }
        }
        return result;
    }
}
```





## 四、层序遍历

### 题目

![](https://pic-1317004580.cos.ap-guangzhou.myqcloud.com/%E6%96%B0%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BA%8C%E5%8F%89%E6%A0%91/1.png)

### 思路

①用**队列**存储每层元素，需要记录下每层的队列的size，用于记录下次遍历的次数

②出队列前把左右还在放入队列中

③如果队列为0则遍历完成

![](https://code-thinking.cdn.bcebos.com/gifs/102%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86.gif)

### 代码

```java
// 102.二叉树的层序遍历
class Solution {
    public List<List<Integer>> resList = new ArrayList<List<Integer>>();

    public List<List<Integer>> levelOrder(TreeNode root) {
        //checkFun01(root,0);
        checkFun02(root);

        return resList;
    }

    //DFS--递归方式
    public void checkFun01(TreeNode node, Integer deep) {
        if (node == null) return;
        deep++;

        if (resList.size() < deep) {
            //当层级增加时，list的Item也增加，利用list的索引值进行层级界定
            List<Integer> item = new ArrayList<Integer>();
            resList.add(item);
        }
        resList.get(deep - 1).add(node.val);

        checkFun01(node.left, deep);
        checkFun01(node.right, deep);
    }

    //BFS--迭代方式--借助队列
    public void checkFun02(TreeNode node) {
        if (node == null) return;
        Queue<TreeNode> que = new LinkedList<TreeNode>();
        que.offer(node);

        while (!que.isEmpty()) {
            List<Integer> itemList = new ArrayList<Integer>();
            int len = que.size();

            while (len > 0) {
                TreeNode tmpNode = que.poll();
                itemList.add(tmpNode.val);

                if (tmpNode.left != null) que.offer(tmpNode.left);
                if (tmpNode.right != null) que.offer(tmpNode.right);
                len--;
            }

            resList.add(itemList);
        }

    }
}
```



## 五、翻转二叉树

### 题目

![](https://pic-1317004580.cos.ap-guangzhou.myqcloud.com/%E6%96%B0%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BA%8C%E5%8F%89%E6%A0%91/2.png)

------

### 我的思路

使用递归，前序遍历到一个结点就交换左右孩子，返回条件是结点为空。

### 代码

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public TreeNode invertTree(TreeNode root) {
        reverse(root);
        return root;
    }

    public void reverse(TreeNode node){
        if(node == null){
            return;
        }
        swap(node);
        reverse(node.left);
        reverse(node.right);
    }
	//结点的左右孩子交换逻辑
    public void swap(TreeNode node){
        TreeNode temp = node.left;
        node.left = node.right;
        node.right = temp;
    }
}
```

------

### 二刷

```java
class Solution {
    public TreeNode invertTree(TreeNode root) {
        traversal(root);
        return root;
    }

    public void traversal(TreeNode root){
        if(root == null){
            return;
        }

        TreeNode tmp = root.left;
        root.left = root.right;
        root.right = tmp;

        traversal(root.right);
        traversal(root.left);
    }
}
```









### 答案思路

####1）递归

![](https://code-thinking.cdn.bcebos.com/gifs/%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91.gif)

和我思路差不多，也可以时候后序遍历，但是不要使用中序遍历。

#### 2）递归版

只是遍历节点的方法不同。



### 答案代码

```java
//DFS递归
class Solution {
   /**
     * 前后序遍历都可以
     * 中序不行，因为先左孩子交换孩子，再根交换孩子（做完后，右孩子已经变成了原来的左孩子），再右孩子交换孩子（此时其实是对原来的左孩子做交换）
     */
    public TreeNode invertTree(TreeNode root) {
        if (root == null) {
            return null;
        }
        invertTree(root.left);
        invertTree(root.right);
        swapChildren(root);
        return root;
    }

    private void swapChildren(TreeNode root) {
        TreeNode tmp = root.left;
        root.left = root.right;
        root.right = tmp;
    }
}

//BFS
class Solution {
    public TreeNode invertTree(TreeNode root) {
        if (root == null) {return null;}
        ArrayDeque<TreeNode> deque = new ArrayDeque<>();
        deque.offer(root);
        while (!deque.isEmpty()) {
            int size = deque.size();
            while (size-- > 0) {
                TreeNode node = deque.poll();
                swap(node);
                if (node.left != null) deque.offer(node.left);
                if (node.right != null) deque.offer(node.right);
            }
        }
        return root;
    }

    public void swap(TreeNode root) {
        TreeNode temp = root.left;
        root.left = root.right;
        root.right = temp;
    }
}
```



## 六、对称二叉树

### 题目

![](https://pic-1317004580.cos.ap-guangzhou.myqcloud.com/%E6%96%B0%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BA%8C%E5%8F%89%E6%A0%91/3.png)

------

###我的思路

①使用递归

②左边遍历顺序为左右中，右边遍历顺序为右左中

③传回两个子树的遍历的数组，返回两个数组的比较结果

### 我的代码

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public boolean isSymmetric(TreeNode root) {
        List<Integer> rightList = new LinkedList<>();
        List<Integer> leftList = new LinkedList<>();
        rightNode(root.right,rightList);
        Integer[] arr1 = rightList.toArray(new Integer[0]);
        leftNode(root.left,leftList);
        Integer[] arr2 = leftList.toArray(new Integer[0]);
        return Arrays.equals(arr1, arr2);
    }
	//根结点右子树的遍历方式：右-左-中
    public List<Integer> rightNode(TreeNode right,List<Integer> list){
        if(right == null){
            list.add(null);
            return list;
        }
        rightNode(right.right,list);
        rightNode(right.left,list);
        list.add(right.val);
        return list;
    }
	//根结点右子树的遍历方式：左-右-中
    public List<Integer> leftNode(TreeNode left,List<Integer> list){
        if(left == null){
            list.add(null);
            return list;
        }
        leftNode(left.left,list);
        leftNode(left.right,list);
        list.add(left.val);
        return list;
    }
}
```

------

### 答案思路

#### 1）递归法

思想差不多，没有用到数组，节省空间，而是之间比较。

主要说明**只能用后序遍历**~

代码：

```java
/**
* 递归法
*/
public boolean isSymmetric1(TreeNode root) {
  return compare(root.left, root.right);
}

private boolean compare(TreeNode left, TreeNode right) {

  if (left == null && right != null) {
    return false;
  }
  if (left != null && right == null) {
    return false;
  }

  if (left == null && right == null) {
    return true;
  }
  if (left.val != right.val) {
    return false;
  }
  // 比较外侧
  boolean compareOutside = compare(left.left, right.right);
  // 比较内侧
  boolean compareInside = compare(left.right, right.left);
  return compareOutside && compareInside;
}
```



#### 2）迭代法---队列

对称是层序关系，不是前中后序的关系。

![](https://code-thinking.cdn.bcebos.com/gifs/101.%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91.gif)

代码实现：

```java
    /**
     * 迭代法
     * 使用普通队列
     */
    public boolean isSymmetric3(TreeNode root) {
        Queue<TreeNode> deque = new LinkedList<>();
        deque.offer(root.left);
        deque.offer(root.right);
        while (!deque.isEmpty()) {
            TreeNode leftNode = deque.poll();
            TreeNode rightNode = deque.poll();
            if (leftNode == null && rightNode == null) {
                continue;
            }
//            if (leftNode == null && rightNode != null) {
//                return false;
//            }
//            if (leftNode != null && rightNode == null) {
//                return false;
//            }
//            if (leftNode.val != rightNode.val) {
//                return false;
//            }
            // 以上三个判断条件合并
            if (leftNode == null || rightNode == null || leftNode.val != rightNode.val) {
                return false;
            }
            // 这里顺序与使用Deque不同
            deque.offer(leftNode.left);
            deque.offer(rightNode.right);
            deque.offer(leftNode.right);
            deque.offer(rightNode.left);
        }
        return true;
    }
```





```java
    /**
     * 迭代法
     * 使用双端队列，相当于两个栈
     */
    public boolean isSymmetric2(TreeNode root) {
        Deque<TreeNode> deque = new LinkedList<>();
        deque.offerFirst(root.left);
        deque.offerLast(root.right);
        while (!deque.isEmpty()) {
            TreeNode leftNode = deque.pollFirst();
            TreeNode rightNode = deque.pollLast();
            if (leftNode == null && rightNode == null) {
                continue;
            }
//            if (leftNode == null && rightNode != null) {
//                return false;
//            }
//            if (leftNode != null && rightNode == null) {
//                return false;
//            }
//            if (leftNode.val != rightNode.val) {
//                return false;
//            }
            // 以上三个判断条件合并
            if (leftNode == null || rightNode == null || leftNode.val != rightNode.val) {
                return false;
            }
            deque.offerFirst(leftNode.left);
            deque.offerFirst(leftNode.right);
            deque.offerLast(rightNode.right);
            deque.offerLast(rightNode.left);
        }
        return true;
    }
```



## 七、二叉树的最大深度

###题目

![](https://raw.githubusercontent.com/vankykoo/javaStudy/cf150e88bd4bce597c6ceb7223445b02c9301f93/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E9%A2%98%E7%9B%AE/%E4%BA%8C%E5%8F%89%E6%A0%91/%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6.png)

------

###我的思路

①使用递归

②如果节点为空就直接返回当前数据

③如果不为空，将数据加1，然后左右节点递归，最后返回较大的数值

### 我的代码

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public int maxDepth(TreeNode root) {
        if(root == null){
            return 0;
        }
        return deep(root,0);
    }

    public int deep(TreeNode node, int index){
        if(node == null){
            return index;
        }
        index++;
        int right = deep(node.right,index);
        int left = deep(node.left,index);
        return right > left ? right : left;
    }
}
```



------

### 二刷

```java
class Solution {
    int res = 0;
    public int maxDepth(TreeNode root) {
        traversal(0, root);
        return res;
    }
  
    public void traversal(int num, TreeNode root){
        if(root == null){
            res = Math.max(num, res);
            return;
        }
        num++;
      
        traversal(num, root.left);
        traversal(num, root.right);
    }
}
```





### 答案思路

高度：从叶子节点向上数

深度：从根结点向下数

※①后序遍历------求高度

②前序遍历-------求深度

但是这里用哪个都行，因为二叉树最大深度等于根结点高度

* 单层递归逻辑：先求它的左子树的深度，再求右子树的深度，最后取左右深度最大的数值再加一，（加1是因为算上当前中间节点）就是目前节点为根结点的深度。

```java
class solution {
    /**
     * 递归法
     */
    public int maxDepth(TreeNode root) {
        if (root == null) {
            return 0;
        }
        int leftDepth = maxDepth(root.left);
        int rightDepth = maxDepth(root.right);
        return Math.max(leftDepth, rightDepth) + 1;
    }
}
```



```java
class Solution {
  /**
   * 递归法(求深度法)
   */
    //定义最大深度
    int maxnum = 0;

    public int maxDepth(TreeNode root) {
        ans(root,0);
        return maxnum;
    }
    
    //递归求解最大深度
    void ans(TreeNode tr,int tmp){
        if(tr==null) return;
        tmp++;
        maxnum = maxnum<tmp?tmp:maxnum;
        ans(tr.left,tmp);
        ans(tr.right,tmp);
        tmp--;
    }
}
```



#### 迭代法

使用层序遍历（队列）

![](https://code-thinking-1253855093.file.myqcloud.com/pics/20200810193056585.png)

```java
class solution {
    /**
     * 迭代法，使用层序遍历
     */
    public int maxDepth(TreeNode root) {
        if(root == null) {
            return 0;
        }
        Deque<TreeNode> deque = new LinkedList<>();
        deque.offer(root);
        int depth = 0;
        while (!deque.isEmpty()) {
            int size = deque.size();
            depth++;
            for (int i = 0; i < size; i++) {
                TreeNode node = deque.poll();
                if (node.left != null) {
                    deque.offer(node.left);
                }
                if (node.right != null) {
                    deque.offer(node.right);
                }
            }
        }
        return depth;
    }
}
```



## 八、最小深度

### 题目

![](https://raw.githubusercontent.com/vankykoo/javaStudy/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E9%A2%98%E7%9B%AE/%E4%BA%8C%E5%8F%89%E6%A0%91/%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A61.png)

![](https://raw.githubusercontent.com/vankykoo/javaStudy/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E9%A2%98%E7%9B%AE/%E4%BA%8C%E5%8F%89%E6%A0%91/%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A62.png)

------

### 我的思路

①和上一题差不多，把大于号变成小于号

②除此之外，还要主要一个特殊情况，就是根结点没有左孩子或者右孩子时，不能返回1，因为题目说明了叶子节点是指没有子节点的节点。

③所以说，**如果没有左孩子，直接返回右孩子的返回值；如果没有右孩子，直接返回左孩子的返回值。**

### 我的代码

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public int minDepth(TreeNode root) {
        if(root == null){
            return 0;
        }
        return deep(root,0);
    }

    public int deep(TreeNode node, int index){
        if(node == null){
            return index;
        }
        int right = deep(node.right,index);
        int left = deep(node.left,index);
        if(right == 0){
            return ++left;
        }else if (left == 0){
            return ++right;
        }
        return right < left ? ++right : ++left;
    }
}
```

------

### 二刷

```java
class Solution {
  
    int res = Integer.MAX_VALUE;
  
    public int minDepth(TreeNode root) {
        // 如果根节点为空，树的深度为0
        if(root == null){
            return 0;
        }
        traversal(1, root);
      
        return res;
    }

    public void traversal(int num, TreeNode root){
        if(root == null){
            return;
        }

        // 如果当前节点是叶子节点，更新最小深度
        if(root.left == null && root.right == null){
            res = Math.min(num, res);
        }
        num++;

        traversal(num, root.left);
        traversal(num, root.right);
    }
}

```









### 答案思路

#### 递归法

思路差不多，直接看代码

```java
class Solution {
    /**
     * 递归法，相比求MaxDepth要复杂点
     * 因为最小深度是从根节点到最近**叶子节点**的最短路径上的节点数量
     */
    public int minDepth(TreeNode root) {
        if (root == null) {
            return 0;
        }
        int leftDepth = minDepth(root.left);
        int rightDepth = minDepth(root.right);
        if (root.left == null) {
            return rightDepth + 1;
        }
        if (root.right == null) {
            return leftDepth + 1;
        }
        // 左右结点都不为null
        return Math.min(leftDepth, rightDepth) + 1;
    }
}
```



#### 递归法

可以使用层序遍历的方式来解决，思路一样。

需要注意的是，只有当左右孩子都为空的时候，才说明遍历到最低点了。如果其中一个孩子不为空则不是最低点。

```java
class Solution {
   /**
     * 迭代法，层序遍历
     */
    public int minDepth(TreeNode root) {
        if (root == null) {
            return 0;
        }
        Deque<TreeNode> deque = new LinkedList<>();
        deque.offer(root);
        int depth = 0;
        while (!deque.isEmpty()) {
            int size = deque.size();
            depth++;
            for (int i = 0; i < size; i++) {
                TreeNode poll = deque.poll();
                if (poll.left == null && poll.right == null) {
                    // 是叶子结点，直接返回depth，因为从上往下遍历，所以该值就是最小值
                    return depth;
                }
                if (poll.left != null) {
                    deque.offer(poll.left);
                }
                if (poll.right != null) {
                    deque.offer(poll.right);
                }
            }
        }
        return depth;
    }
}
```





##九、完全二叉树的节点个数

### 题目

![](https://raw.githubusercontent.com/vankykoo/javaStudy//bc9c872083dd82f8effd323f15868f057ca9f957/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E9%A2%98%E7%9B%AE/%E4%BA%8C%E5%8F%89%E6%A0%91/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0.png)

------

###我的思路

①使用递归，前序遍历

* 返回条件：节点为空
* 执行操作：数量加1
* 返回值：sum

### 我的代码

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public int countNodes(TreeNode root) {
        if(root == null){
            return 0;
        }
        int num = 0;
        return count(root,num);
    }
    
    public int count(TreeNode node,int sum){
        if(node == null){
            return sum;
        }
        sum++;
        sum = count(node.left,sum);
        sum = count(node.right,sum);
        return sum;
    }
}
```

------

### 二刷

```java
class Solution {

    int num = 0;

    public int countNodes(TreeNode root) {
        traversal(root);

        return num;
    }

    public void traversal(TreeNode root){
        if(root == null){
            return;
        }

        num++;
        traversal(root.left);
        traversal(root.right);
    }
}
```







###完全二叉树

![](https://code-thinking-1253855093.file.myqcloud.com/pics/20200920221638903-20230310123444151.png)

------

### 答案解法

```java
class Solution {
    // 通用递归解法
    public int countNodes(TreeNode root) {
        if(root == null) {
            return 0;
        }
        return countNodes(root.left) + countNodes(root.right) + 1;
    }
}
```





```java
class Solution {
    // 迭代法
    public int countNodes(TreeNode root) {
        if (root == null) return 0;
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        int result = 0;
        while (!queue.isEmpty()) {
            int size = queue.size();
            while (size -- > 0) {
                TreeNode cur = queue.poll();
                result++;
                if (cur.left != null) queue.offer(cur.left);
                if (cur.right != null) queue.offer(cur.right);
            }
        }
        return result;
    }
}
```



```java
class Solution {
    /**
     * 针对完全二叉树的解法
     *
     * 满二叉树的结点数为：2^depth - 1
     */
    public int countNodes(TreeNode root) {
        if (root == null) return 0;
        TreeNode left = root.left;
        TreeNode right = root.right;
        int leftDepth = 0, rightDepth = 0; // 这里初始为0是有目的的，为了下面求指数方便
        while (left != null) {  // 求左子树深度
            left = left.left;
            leftDepth++;
        }
        while (right != null) { // 求右子树深度
            right = right.right;
            rightDepth++;
        }
        if (leftDepth == rightDepth) {
            return (2 << leftDepth) - 1; // 注意(2<<1) 相当于2^2，所以leftDepth初始为0
        }
        return countNodes(root.left) + countNodes(root.right) + 1;
    }
}
```



## 十、平衡二叉树

### 题目

![](https://raw.githubusercontent.com/vankykoo/javaStudy/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E9%A2%98%E7%9B%AE/%E4%BA%8C%E5%8F%89%E6%A0%91/1.png)

------

### 二刷

```java
class Solution {
    public boolean isBalanced(TreeNode root) {
        return traversal(root) != -1;
    }

    public int traversal(TreeNode root){
        if(root == null){
            return 0;
        }
        int left = traversal(root.left);
        int right = traversal(root.right);

        if(left == -1 || right == -1){
            return -1;
        }

        if(Math.abs(left - right) > 1){
            return -1;
        }

        return Math.max(left, right) + 1;
    }
}
```







### 思路

1）高度和深度

①高度：指从该节点到叶子节点的最长简单路径边的条数。（后序遍历

②深度：指从根结点到该节点的最长简单路径边的条数。（前序遍历

![](https://code-thinking-1253855093.file.myqcloud.com/pics/20210203155515650.png)



2）思路

①使用递归，传入节点，返回二叉树高度

②遇到空节点返回0

③分别求出其左右子树高度，如果差值小于等于1，则返回当前二叉树的高度，否则返回-1，表示已经不是平衡二叉树。

### 代码

####递归法

```java
class Solution {
   /**
     * 递归法
     */
    public boolean isBalanced(TreeNode root) {
        return getHeight(root) != -1;
    }

    private int getHeight(TreeNode root) {
        if (root == null) {
            return 0;
        }
        int leftHeight = getHeight(root.left);
        if (leftHeight == -1) {
            return -1;
        }
        int rightHeight = getHeight(root.right);
        if (rightHeight == -1) {
            return -1;
        }
        // 左右子树高度差大于1，return -1表示已经不是平衡树了
        if (Math.abs(leftHeight - rightHeight) > 1) {
            return -1;
        }
        return Math.max(leftHeight, rightHeight) + 1;
    }
}
```

#### 迭代法

```java
class Solution {
   /**
     * 迭代法，效率较低，计算高度时会重复遍历
     * 时间复杂度：O(n^2)
     */
    public boolean isBalanced(TreeNode root) {
        if (root == null) {
            return true;
        }
        Stack<TreeNode> stack = new Stack<>();
        TreeNode pre = null;
        while (root!= null || !stack.isEmpty()) {
            while (root != null) {
                stack.push(root);
                root = root.left;
            }
            TreeNode inNode = stack.peek();
            // 右结点为null或已经遍历过
            if (inNode.right == null || inNode.right == pre) {
                // 比较左右子树的高度差，输出
                if (Math.abs(getHeight(inNode.left) - getHeight(inNode.right)) > 1) {
                    return false;
                }
                stack.pop();
                pre = inNode;
                root = null;// 当前结点下，没有要遍历的结点了
            } else {
                root = inNode.right;// 右结点还没遍历，遍历右结点
            }
        }
        return true;
    }

    /**
     * 层序遍历，求结点的高度
     */
    public int getHeight(TreeNode root) {
        if (root == null) {
            return 0;
        }
        Deque<TreeNode> deque = new LinkedList<>();
        deque.offer(root);
        int depth = 0;
        while (!deque.isEmpty()) {
            int size = deque.size();
            depth++;
            for (int i = 0; i < size; i++) {
                TreeNode poll = deque.poll();
                if (poll.left != null) {
                    deque.offer(poll.left);
                }
                if (poll.right != null) {
                    deque.offer(poll.right);
                }
            }
        }
        return depth;
    }
}

class Solution {
   /**
     * 优化迭代法，针对暴力迭代法的getHeight方法做优化，利用TreeNode.val来保存当前结点的高度，这样就不会有重复遍历
     * 获取高度算法时间复杂度可以降到O(1)，总的时间复杂度降为O(n)。
     * 时间复杂度：O(n)
     */
    public boolean isBalanced(TreeNode root) {
        if (root == null) {
            return true;
        }
        Stack<TreeNode> stack = new Stack<>();
        TreeNode pre = null;
        while (root != null || !stack.isEmpty()) {
            while (root != null) {
                stack.push(root);
                root = root.left;
            }
            TreeNode inNode = stack.peek();
            // 右结点为null或已经遍历过
            if (inNode.right == null || inNode.right == pre) {
                // 输出
                if (Math.abs(getHeight(inNode.left) - getHeight(inNode.right)) > 1) {
                    return false;
                }
                stack.pop();
                pre = inNode;
                root = null;// 当前结点下，没有要遍历的结点了
            } else {
                root = inNode.right;// 右结点还没遍历，遍历右结点
            }
        }
        return true;
    }

    /**
     * 求结点的高度
     */
    public int getHeight(TreeNode root) {
        if (root == null) {
            return 0;
        }
        int leftHeight = root.left != null ? root.left.val : 0;
        int rightHeight = root.right != null ? root.right.val : 0;
        int height = Math.max(leftHeight, rightHeight) + 1;
        root.val = height;// 用TreeNode.val来保存当前结点的高度
        return height;
    }
}
```





## 十一、二叉树的所有路径

### 题目

![](https://raw.githubusercontent.com/vankykoo/javaStudy/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E9%A2%98%E7%9B%AE/%E4%BA%8C%E5%8F%89%E6%A0%91/2.png)

------

### 思路

①使用递归，传入参数：node节点，已经经过的节点的路径字符串，结果集合list

②



### 我的代码

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public List<String> binaryTreePaths(TreeNode root) {
        List<String> list = new LinkedList<String>();
        if(root == null){
            return list;
        }
        String s = "";
        paths(root,s,list);
        return list;
    }
    public void paths(TreeNode node,String sb,List<String> list){
      //每次递归都要创建一个新的字符串，存已经经过的节点
        StringBuilder sb2 = new StringBuilder();
      //一开始是一个空串，加上之前已经遍历过的结点。
        sb2 = sb2.append(sb);
        if(node.left == null && node.right == null){//如果左右孩子都为空，则为尽头
            sb2.append("->" + node.val);//添加当前结点
            sb2.delete(0,2);//删除重复的字符串
            list.add(sb2.toString());//加入到结果集
            return;
        }

        sb2.append("->" + node.val);//添加当前结点值
        if(node.left != null){
            paths(node.left,sb2.toString(),list);
        }
        if(node.right != null){
            paths(node.right,sb2.toString(),list);
        }
    }
}
```





### 二刷

```java
class Solution {

    List<String> res = new ArrayList<>();
    StringBuilder sb = new StringBuilder();

    public List<String> binaryTreePaths(TreeNode root) {
        if(root == null){
            return res;
        }
      //先把头结点加进去
        sb.append(root.val + "->");
        traversal(root);

        return res;
    }

    public void traversal(TreeNode root){
        if(root == null){
            return;
        }

        if(root.left == null && root.right == null){
            //遇到叶子节点就增加一条路径
            res.add(sb.substring(0, sb.length() - 2));
            return;
        }

        if(root.left != null){
            String s = root.left.val + "->";
            sb.append(s);
            traversal(root.left);
            sb.delete(sb.length() - s.length(), sb.length());
        }
        
        if(root.right != null){
            String s = root.right.val + "->";
            sb.append(s);
            traversal(root.right);
            sb.delete(sb.length() - s.length(), sb.length());
        }
    }
}
```



------

### 答案思路

递归+回溯

![](https://code-thinking-1253855093.file.myqcloud.com/pics/20210204151702443.png)

### 答案代码

```java
//解法一
class Solution {
    /**
     * 递归法
     */
    public List<String> binaryTreePaths(TreeNode root) {
        List<String> res = new ArrayList<>();// 存最终的结果
        if (root == null) {
            return res;
        }
        List<Integer> paths = new ArrayList<>();// 作为结果中的路径
        traversal(root, paths, res);
        return res;
    }

    private void traversal(TreeNode root, List<Integer> paths, List<String> res) {
        paths.add(root.val);// 前序遍历，中
        // 遇到叶子结点
        if (root.left == null && root.right == null) {
            // 输出
            StringBuilder sb = new StringBuilder();// StringBuilder用来拼接字符串，速度更快
            for (int i = 0; i < paths.size() - 1; i++) {
                sb.append(paths.get(i)).append("->");
            }
            sb.append(paths.get(paths.size() - 1));// 记录最后一个节点
            res.add(sb.toString());// 收集一个路径
            return;
        }
        // 递归和回溯是同时进行，所以要放在同一个花括号里
        if (root.left != null) { // 左
            traversal(root.left, paths, res);
            paths.remove(paths.size() - 1);// 回溯
        }
        if (root.right != null) { // 右
            traversal(root.right, paths, res);
            paths.remove(paths.size() - 1);// 回溯
        }
    }
}
```



迭代法

```java
// 解法2
class Solution {
    /**
     * 迭代法
     */
    public List<String> binaryTreePaths(TreeNode root) {
        List<String> result = new ArrayList<>();
        if (root == null)
            return result;
        Stack<Object> stack = new Stack<>();
        // 节点和路径同时入栈
        stack.push(root);
        stack.push(root.val + "");
        while (!stack.isEmpty()) {
            // 节点和路径同时出栈
            String path = (String) stack.pop();
            TreeNode node = (TreeNode) stack.pop();
            // 若找到叶子节点
            if (node.left == null && node.right == null) {
                result.add(path);
            }
            //右子节点不为空
            if (node.right != null) {
                stack.push(node.right);
                stack.push(path + "->" + node.right.val);
            }
            //左子节点不为空
            if (node.left != null) {
                stack.push(node.left);
                stack.push(path + "->" + node.left.val);
            }
        }
        return result;
    }
}
```





## 十二、左叶子之和

### 题目

![](https://raw.githubusercontent.com/vankykoo/javaStudy/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E9%A2%98%E7%9B%AE/%E4%BA%8C%E5%8F%89%E6%A0%91/3.png)

------

### 我的思路

* 使用递归，参数：
  * 结点node
  * 总和sum
  * 判断是不是左节点isLeft
* 如果左右孩子都为空，则为叶子结点，若参数isLeft为TRUE的话，则有左叶子结点，结果加到sum中。

### 我的代码

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public int sumOfLeftLeaves(TreeNode root) {
        int sum = 0;
        if(root == null || (root.left == null && root.right == null)){
            return 0;
        }
        return getSum(root,sum,false);
    }
    public int getSum(TreeNode node,int sum,boolean isLeft){
        if(node.left == null && node.right == null){
            if(isLeft){
                sum += node.val;
            }
            return sum;
        }

        if(node.left != null){
            sum = getSum(node.left,sum,true);
        }

        if(node.right != null){
            sum = getSum(node.right,sum,false);
        }

        return sum;
    }
}
```



### 二刷

```java
class Solution {

    int res = 0;
    public int sumOfLeftLeaves(TreeNode root) {
        traversal(root);

        return res;
    }

    public void traversal(TreeNode root){
        if(root == null){
            return;
        }

        if(root.left != null){
            TreeNode left = root.left;
            if(left.left == null && left.right == null){
              //如果是左叶子节点
                res += left.val;
            }else{
                traversal(root.left);
            }
        }

        traversal(root.right);
        
    }
}
```





### 答案代码

```java
//递归
class Solution {
    public int sumOfLeftLeaves(TreeNode root) {
        if (root == null) return 0;
        int leftValue = sumOfLeftLeaves(root.left);    // 左
        int rightValue = sumOfLeftLeaves(root.right);  // 右
                                                       
        int midValue = 0;
        if (root.left != null && root.left.left == null && root.left.right == null) { 
            midValue = root.left.val;
        }
        int sum = midValue + leftValue + rightValue;  // 中
        return sum;
    }
}
```



```java
//迭代
class Solution {
    public int sumOfLeftLeaves(TreeNode root) {
        if (root == null) return 0;
        Stack<TreeNode> stack = new Stack<> ();
        stack.add(root);
        int result = 0;
        while (!stack.isEmpty()) {
            TreeNode node = stack.pop();
            if (node.left != null && node.left.left == null && node.left.right == null) {
                result += node.left.val;
            }
            if (node.right != null) stack.add(node.right);
            if (node.left != null) stack.add(node.left);
        }
        return result;
    }
}


// 层序遍历迭代法
class Solution {
    public int sumOfLeftLeaves(TreeNode root) {
        int sum = 0;
        if (root == null) return 0;
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        while (!queue.isEmpty()) {
            int size = queue.size();
            while (size -- > 0) {
                TreeNode node = queue.poll();
                if (node.left != null) { // 左节点不为空
                    queue.offer(node.left);
                    if (node.left.left == null && node.left.right == null){ // 左叶子节点
                        sum += node.left.val;
                    }
                }
                if (node.right != null) queue.offer(node.right);
            }
        }
        return sum;
    }
}
```





## 十三、找树左下角的值

![](https://raw.githubusercontent.com/vankykoo/javaStudy/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E9%A2%98%E7%9B%AE/%E4%BA%8C%E5%8F%89%E6%A0%91/4.png)



------

### 我的思路

使用层序遍历，最后一层的第一个就是树左下角的值。

------

### 二刷

```java
class Solution {
    public int findBottomLeftValue(TreeNode root) {
        Deque<TreeNode> queue = new LinkedList<>();

        //当前层的个数
        int cur;
        //下一层的个数
        int next = 1;
        int res = root.val;

        queue.add(root);

        //层序遍历
        while(next > 0){
            cur = next;
            next = 0;
            res = queue.peek().val;
            while(cur > 0){
                //遍历当前层
                TreeNode node = queue.pop();
                if(node.left != null){
                    queue.add(node.left);
                    next++;
                }
                if(node.right != null){
                    queue.add(node.right);
                    next++;
                }
                cur--;
            }
        }

        return res;
    }
}
```







### 答案思路

①使用递归

②确定递归参数和返回值，参数：结点，深度depth；返回值void。要定义两个全局变量，最大深度maxDepth和result。

③确定终止条件：遇到叶子结点

④确定单层逻辑：深度加一，调用递归，深度减一（回溯）。

### 答案代码

```java
//递归法
class Solution{
  private int Deep = -1;//最大深度
  private int value = 0;
  public int findBottomLeftValue(TreeNode root){
    value = root.val;
    findLeftValue(root,0);
    return value;
  }
  
  private void findLeftValue(TreeNode root,int deep){
    if(root == null) {
      return;
    }
    if(root.left == null && root.right == null){
      if(deep > Deep){
        value = root.val;
        Deep = deep;
      }
    }
    if(root.left != null){
      //因为这里是在参数中加1，所以不用回溯减一
      findLeftValue(root.left,deep + 1);
    }
    if(root.right != null){
      findLeftValue(root.right,deep + 1);
    }
  }
}
```



```java
//递归法：用队列层序遍历
class Solution{
  public int findBottomLeftValue(TreeNode root){
    Queue<TreeNode> queue = new LinkedList<>();
    queue.offer(root);//第一层的根结点
    int res = 0;//结果
    while(!queue.isEmpty()){//当队列不为空
      int size = queue.size();
      for(int i=0;i < size;i++){
        TreeNode poll = queue.poll();//出队列
        if(i == 0){
          res = poll.val;//每一层最左边的数值记录到结果里
        }
        if(poll.left != null){
          queue.offer(poll.left);
        }
        if(poll.right != null){
          queue.offer(poll.right);
        }
      }
    }
    return res;
  }
}
```





## 十四、路径总和

![](https://raw.githubusercontent.com/vankykoo/javaStudy/060a467247bf563ba3abc3c21bb7eab3f8568c78/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E9%A2%98%E7%9B%AE/%E4%BA%8C%E5%8F%89%E6%A0%91/5.png)

![](https://raw.githubusercontent.com/vankykoo/javaStudy/060a467247bf563ba3abc3c21bb7eab3f8568c78/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E9%A2%98%E7%9B%AE/%E4%BA%8C%E5%8F%89%E6%A0%91/6.png)

------

### 我的思路

①使用递归

②传入参数：结点node，目标总和targetSum，目前总和sum

③返回值：boolean是否存在

④逻辑：如果到叶子结点并且sum等于targetSum就返回true

### 我的代码

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public boolean hasPathSum(TreeNode root, int targetSum) {
        if(root == null){
            return false;
        }

        return sum(root,targetSum,root.val);
    }

    public boolean sum(TreeNode node,int targetSum,int sum){
        if(node.left == null && node.right == null && sum == targetSum){
            return true;
        }
        if(node.left != null){
            boolean isLeft = sum(node.left,targetSum,sum + node.left.val);
          //注意上面这个递归函数有一个返回值，如果返回值为true，则需要一直回溯给根结点
          //返回给最终结果
            if(isLeft){
                return true;
            }
        }
        if(node.right != null){
            boolean isRight = sum(node.right,targetSum,sum + node.right.val);
            if(isRight){
                return true;
            }
        }

        return false;
    }
}
```

------

### 答案思路

①思路差不多，但是是使用从总和减去路过的结点，如果最终结果为0则为true。

### 答案代码

```java
//递归写法
class solution {
   public boolean haspathsum(treenode root, int targetsum) {
        if (root == null) {
            return false;
        }
        targetsum -= root.val;
        // 叶子结点
        if (root.left == null && root.right == null) {
            return targetsum == 0;
        }
        if (root.left != null) {
            boolean left = haspathsum(root.left, targetsum);
            if (left) {      // 已经找到
                return true;
            }
        }
        if (root.right != null) {
            boolean right = haspathsum(root.right, targetsum);
            if (right) {     // 已经找到
                return true;
            }
        }
        return false;
    }
}

// lc112 简洁方法
class solution {
    public boolean haspathsum(treenode root, int targetsum) {

        if (root == null) return false; // 为空退出

        // 叶子节点判断是否符合
        if (root.left == null && root.right == null) return root.val == targetsum;

        // 求两侧分支的路径和
        return haspathsum(root.left, targetsum - root.val) || haspathsum(root.right, targetsum - root.val);
    }
}
```

```java
//迭代写法
class solution {
    public boolean haspathsum(treenode root, int targetsum) {
        if(root == null) return false;
        stack<treenode> stack1 = new stack<>();
        stack<integer> stack2 = new stack<>();
        stack1.push(root);
        stack2.push(root.val);
        while(!stack1.isempty()) {
            int size = stack1.size();

            for(int i = 0; i < size; i++) {
                treenode node = stack1.pop();
                int sum = stack2.pop();

                // 如果该节点是叶子节点了，同时该节点的路径数值等于sum，那么就返回true
                if(node.left == null && node.right == null && sum == targetsum) {
                    return true;
                }
                // 右节点，压进去一个节点的时候，将该节点的路径数值也记录下来
                if(node.right != null){
                    stack1.push(node.right);
                    stack2.push(sum + node.right.val);
                }
                // 左节点，压进去一个节点的时候，将该节点的路径数值也记录下来
                if(node.left != null) {
                    stack1.push(node.left);
                    stack2.push(sum + node.left.val);
                }
            }
        }
        return false;
    }
}
```



## 十五、从中序与后序遍历序列构造二叉树

### 思路

①如果数组大小为零，说明是空节点了

②如果不为空，那么取后序数组最后一个元素作为节点元素。

③如果找到后序数组最后一个元素在中序数组的位置，将其作为切割点。

④切割中序数组，切成中序左数组和中序右数组。

⑤切割后序数组，切成后序左数组和后序右数组。

⑥递归处理左区间和右区间

## 代码

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
Map<Integer,Integer> map;
    public TreeNode buildTree(int[] inorder, int[] postorder) {
        map = new HashMap<>();   //方便根据数值查找位置
        int i;
        for(i=0;i < inorder.length;i++){
            map.put(inorder[i],i);
        }

        return findNode(inorder, 0, inorder.length,postorder,0, postorder.length);//前闭后开
    }

    public TreeNode findNode(int[] inorder, int inBegin, int inEnd,int[] postorder, int postBegin, int postEnd){
        //参数里的范围都是前闭后开
        if(inBegin >= inEnd || postBegin >= postEnd){//不满足左闭右开，说明没有元素，返回空树
            return null;
        }
        int rootIndex = map.get(postorder[postEnd - 1]);//找到后序遍历的最后一个元素在中序遍历中的位置
        TreeNode root = new TreeNode(inorder[rootIndex]);//构造结点
        int lenOfLeft = rootIndex - inBegin; //保存中序左子树个数，用来确定后序数列的个数
        root.left = findNode(inorder, inBegin, rootIndex, postorder, postBegin, postBegin + lenOfLeft);
        root.right = findNode(inorder, rootIndex + 1, inEnd, postorder, postBegin + lenOfLeft, postEnd - 1);

        return root;
    }
}
```





## 十五、最大二叉树

### 题目

![](https://raw.githubusercontent.com/vankykoo/javaStudy/2b5853d79de31d61f460269659709fc1c128ce13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E9%A2%98%E7%9B%AE/%E4%BA%8C%E5%8F%89%E6%A0%91/7.png))

![](https://raw.githubusercontent.com/vankykoo/javaStudy/2b5853d79de31d61f460269659709fc1c128ce13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E9%A2%98%E7%9B%AE/%E4%BA%8C%E5%8F%89%E6%A0%91/8.png)

### 我的思路

* 使用递归
  * 传入的参数：根结点node，数组nums，左边开始的索引leftBegin，左边结束的索引leftEnd，右边开始的索引，右边结束的索引
  * 返回值：根结点
  * 递归结束的标志：当左右两边都没有数值时结束
  * 递归思路：找到数组中 最大的数值，如果是在左边就为左子树，右边就在右子树。
* 创建一个map用于查找最大值索引

### 我的代码

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    Map<Integer,Integer> map;
    public TreeNode constructMaximumBinaryTree(int[] nums) {
        map = new LinkedHashMap<>();

        for(int i=0;i<nums.length;i++){
            map.put(nums[i],i);
        }
        int i = findBig(nums,0,nums.length);
        TreeNode root = new TreeNode(nums[i]);

        return traversal(root,nums,0,i,i+1,nums.length);
    }

    public TreeNode traversal(TreeNode node,int[] nums,int leftBegin,int leftEnd,int rightBegin,int rightEnd)
    {
        if(leftBegin == leftEnd && rightBegin == rightEnd){
            return node;
        }

        if(leftBegin != leftEnd){
          //求最大值索引
            int index = findBig(nums,leftBegin,leftEnd);
          //创建一个新节点
            TreeNode root = new TreeNode(nums[index]);
          //左边放在左子树
            node.left = root;
          //递归
            traversal(root,nums,leftBegin,index,index + 1,leftEnd);
        }

        if(rightBegin != rightEnd){
            int index = findBig(nums,rightBegin,rightEnd);
            TreeNode root = new TreeNode(nums[index]);
            node.right = root;
            traversal(root,nums,rightBegin,index,index+1,rightEnd);
        }

        return node;
    }

  //返回最大值索引
    public Integer findBig(int[] arr,int begin,int end){
        int big = arr[begin];
        for(int i=begin + 1;i<end;i++){
            if(arr[i] > big){
                big = arr[i];
            }
        }

        return map.get(big);
    }
}
```



### 二刷

```java
class Solution {
    public TreeNode constructMaximumBinaryTree(int[] nums) {
        return traversal(nums, 0, nums.length);
    }

    public TreeNode traversal(int[] nums, int start, int end){
        if(start >= end){
            return null;
        }
        //找出最大值的索引
        int index = findMax(nums, start, end);
        //创建根结点
        TreeNode root = new TreeNode(nums[index]);

        //左子树
        root.left = traversal(nums, start, index);
        //右子树
        root.right = traversal(nums, index + 1, end);

        return root;
    }

    public int findMax(int[] nums, int start, int end){
        int maxNum = nums[start];
        int index = start;

        for(int i = start + 1; i < end; i++){
            if(nums[i] > maxNum){
                maxNum = nums[i];
                index = i;
            }
        }

        return index;
    }
}
```





### 答案代码

只需要使用一个区间就可以实现！

```java
class Solution {
    public TreeNode constructMaximumBinaryTree(int[] nums) {
		return constructMaximumBinaryTree1(nums,0,nums.length);
    }
  
  public TreeNode constructMaximumBinaryTree1(int[] nums,int leftIndex,int rightIndex){
    if(rightIndex - leftIndex < 1){//没有元素
      return null;
    }
    if(rightIndex - leftIndex == 1){//只有一个元素
      return new TreeNode(nums[leftIndex]);
    }
    int maxIndex = leftIndex;	//最大值所在位置
    int maxVal = nums[maxIndex];//最大值
    for(int i=leftIndex + 1; i < rightIndex;i++){
      if(nums[i] > maxVal){
        maxVal = nums[i];
        maxIndex = i;
      }
    }
    TreeNode root = new TreeNode(maxVal);
    //根据maxIndex划分左右子树
    root.left = constructMaximumBinaryTree1(nums,leftIndex,maxIndex);
    root.right = constructMaximumBinaryTree1(nums,maxIndex+1,rightIndex);
    return root;
  }
}
```







## 十六、合并二叉树

## 题目

![](https://raw.githubusercontent.com/vankykoo/javaStudy/2dcf2fffd27801da5cdb978f19efea93fd054549/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E9%A2%98%E7%9B%AE/%E4%BA%8C%E5%8F%89%E6%A0%91/9.png)



------

### 思路

* 使用递归
  * 递归函数的参数：两个根结点
  * 返回值：合并后的根结点
  * 终止条件：如果node1为空，返回node2；如果node2为空，返回node1；都为空返回null。
  * 递归逻辑：结点的数值为两个结点的数值相加。



### 代码

```java
//递归
class Solution {
    // 递归
    public TreeNode mergeTrees(TreeNode root1, TreeNode root2) {
        if (root1 == null) return root2;
        if (root2 == null) return root1;

        root1.val += root2.val;
        root1.left = mergeTrees(root1.left,root2.left);
        root1.right = mergeTrees(root1.right,root2.right);
        return root1;
    }
}
```



### 二刷

```java
class Solution {
    public TreeNode mergeTrees(TreeNode root1, TreeNode root2) {
        if(root1 == null && root2 == null){
            return null;
        }

        TreeNode node = new TreeNode(0);

        if(root1 != null){
            node.val += root1.val;
        }

        if(root2 != null){
            node.val += root2.val;
        }

        node.left = mergeTrees(root1 == null? null : root1.left, root2 == null? null : root2.left);
        node.right = mergeTrees(root1 == null? null : root1.right, root2 == null? null : root2.right);

        return node;
    }
}
```



### 答案

```java
class Solution {
    // 使用栈迭代
    public TreeNode mergeTrees(TreeNode root1, TreeNode root2) {
        if (root1 == null) {
            return root2;
        }
        if (root2 == null) {
            return root1;
        }
        Stack<TreeNode> stack = new Stack<>();
        stack.push(root2);
        stack.push(root1);
        while (!stack.isEmpty()) {
            TreeNode node1 = stack.pop();
            TreeNode node2 = stack.pop();
            node1.val += node2.val;
            if (node2.right != null && node1.right != null) {
                stack.push(node2.right);
                stack.push(node1.right);
            } else {
                if (node1.right == null) {
                    node1.right = node2.right;
                }
            }
            if (node2.left != null && node1.left != null) {
                stack.push(node2.left);
                stack.push(node1.left);
            } else {
                if (node1.left == null) {
                    node1.left = node2.left;
                }
            }
        }
        return root1;
    }
}
```



```java
class Solution {
    // 使用队列迭代
    public TreeNode mergeTrees(TreeNode root1, TreeNode root2) {
        if (root1 == null) return root2;
        if (root2 ==null) return root1;
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root1);
        queue.offer(root2);
        while (!queue.isEmpty()) {
            TreeNode node1 = queue.poll();
            TreeNode node2 = queue.poll();
            // 此时两个节点一定不为空，val相加
            node1.val = node1.val + node2.val;
            // 如果两棵树左节点都不为空，加入队列
            if (node1.left != null && node2.left != null) {
                queue.offer(node1.left);
                queue.offer(node2.left);
            }
            // 如果两棵树右节点都不为空，加入队列
            if (node1.right != null && node2.right != null) {
                queue.offer(node1.right);
                queue.offer(node2.right);
            }
            // 若node1的左节点为空，直接赋值
            if (node1.left == null && node2.left != null) {
                node1.left = node2.left;
            }
            // 若node1的右节点为空，直接赋值
            if (node1.right == null && node2.right != null) {
                node1.right = node2.right;
            }
        }
        return root1;
    }
}
```





## 十七、二叉搜索树中的搜索

### 题目

![](https://raw.githubusercontent.com/vankykoo/javaStudy/1d1644336db2f4f6fdc08425aa16865d3854acf0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E9%A2%98%E7%9B%AE/%E4%BA%8C%E5%8F%89%E6%A0%91/10.png)

### 我的思路

* 使用递归
  * 参数：目标结点root，node遍历结点，val目标数值
  * 返回值：目标结点root
  * 终止条件：node为空或root不为空
  * 递归逻辑：当找到时，将结点node赋值给root，使root不为空，返回。



### 我的代码

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public TreeNode searchBST(TreeNode root, int val) {
        return traversal(null,root,val);
    }

    public TreeNode traversal(TreeNode root,TreeNode node,int val){
        if(node == null){
            return null;
        }
        if(node.val == val){
            root = node;
        }
        if(root == null){
            root = traversal(root,node.left,val);
        }
        if(root == null){
            root = traversal(root,node.right,val);
        }

        return root;
    }

}
```



### 二刷

````java
class Solution {
    public TreeNode searchBST(TreeNode root, int val) {
        if(root == null){
            return null;
        }

        if(root.val == val){
            return root;
        }

        TreeNode left = searchBST(root.left, val);
        if(left != null){
            return left;
        }

        TreeNode right = searchBST(root.right, val);
        if(right != null){
            return right;
        }
        
        return null;
    }
}
````





### 答案思路

题目说该二叉树是二叉搜索树，二叉搜索树是一个有序树：

- 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；
- 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；
- 它的左、右子树也分别为二叉搜索树



### 答案代码

我的代码是普通二叉树的写法，二叉搜索树写法如下

```java
class Solution {
    // 递归，利用二叉搜索树特点，优化
    public TreeNode searchBST(TreeNode root, int val) {
        if (root == null || root.val == val) {
            return root;
        }
        if (val < root.val) {
            return searchBST(root.left, val);
        } else {
            return searchBST(root.right, val);
        }
    }
}
```



```java
class Solution {
    //迭代，普通二叉树
    public TreeNode searchBST(TreeNode root, int val) {
        if(root == null || root.val == val){
            return root;
        }
        Stack<TreeNode> stack = new Stack<>();
        stack.push(root);
        while(!stack.isEmpty()){
            TreeNode pop = stack.pop();
            if(pop.val == val){
                return pop;
            }
            if(pop.right != null){
                stack.push(pop.right);
            }
            if(pop.left != null){
                stack.push(pop.left);
            }
        }
        return null;
    }
}
```



```java
class Solution {
    //迭代，二叉搜索树
    public TreeNode searchBST(TreeNode root, int val) {
        while(root != null){
            if(val < root.val) root = root.left;
            else if(val > root.val) root = root.right;
            else return root;
        }
        return null;
    }
}
```





## 十八、验证二叉搜索树

### 题目

![](https://raw.githubusercontent.com/vankykoo/javaStudy/028dd9b3d356006156e373a90e257ae8e6bb5de3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E9%A2%98%E7%9B%AE/%E4%BA%8C%E5%8F%89%E6%A0%91/11.png)



### 二刷

```java
class Solution {
    TreeNode pre;
    public boolean isValidBST(TreeNode root) {
        if(root == null){
            return true;
        }
        //左
        boolean left = isValidBST(root.left);
        if(!left){
            return false;
        }
        //中
        if(pre != null && pre.val >= root.val){
            return false;
        }
        pre = root;
        //右
        boolean right = isValidBST(root.right);
        return right;
    }
}
```





### 思路

* **中序遍历下，输出的二叉搜索树节点的数值是有序序列**
  * 相当于判断一个序列是不是递增的
* 递归法：
  * **确定递归函数，返回值以及参数**：要定义一个longlong的全局变量，用来比较遍历的节点是否有序，因为后台测试数据中有int最小值，所以定义为longlong的类型，初始化为longlong最小值。
  * **确定终止条件**：如果是空节点就返回true
  * **确定单层逻辑**：中序遍历，一直更新maxVal，一旦发现maxVal >= root->val，就返回false，注意元素相同的时候也要返回false。



### 代码

```java
//递归
class Solution{
  TreeNode max;
  public boolean isValidBST(TreeNode root){
    if(root == null){
      return true;
    }
    //左
    boolean left = isValidBST(root.left);
    if(!left){
      return false;
    }
    //中
    if(max != null && root.val <= max.val){
      return false;
    }
    max = root;
    //右
    boolean right = isValidBST(root.right);
    return right;
  }
}
```

```java
//迭代
class Solution{
  public boolean isValidBST(TreeNode root){
    if(root == null){
      return true;
    }
    Stack<TreeNode> stack = new Stack<>();
    TreeNode pre = null;
    while(root != null || !stack.isEmpty()){
      while(root != null){
        stack.push(root);
      	root = root.left; //左
      }
      //中
      TreeNode pop = stack.pop();
      if(pre != null && pop.val <= pre.val){
        return false;
      }
      pre = pop;
      
      root = pop.right;//右
    }
    return true;
    
  }
}
```





##十九、二叉搜索树的最小绝对差

### 题目

![](https://raw.githubusercontent.com/vankykoo/javaStudy/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E9%A2%98%E7%9B%AE/%E4%BA%8C%E5%8F%89%E6%A0%91/12.png)

## 我的思路

中序遍历，放在list集合中，比较前后差值，记录最小差值返回

### 我的代码

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public int getMinimumDifference(TreeNode root) {
        List<Integer> list = new LinkedList<>();
        traversal(root,list);
        int out = list.get(1) - list.get(0);
        for(int i=2;i < list.size();i++){
            int res = list.get(i) - list.get(i-1);
            if(res < out){
                out = res;
            }
        }

        return out;
    }

    public void traversal(TreeNode node,List<Integer> list){
        if(node == null){
            return;
        }

        traversal(node.left,list);

        list.add(node.val);

        traversal(node.right,list);

        return;
    }
}
```



### 二刷

```java
class Solution {
    int pre = -1;
    int res = Integer.MAX_VALUE;
    public int getMinimumDifference(TreeNode root) {
        traversal(root);

        return res;
    }

    public void traversal(TreeNode root){
        if(root == null){
            return;
        }
        //左
        traversal(root.left);
        //中
        if(pre != -1){
            res = Math.min(res, root.val - pre);
        }
        //记录上一个节点
        pre = root.val;
        //右
        traversal(root.right);
    }
}
```





### 答案思路

使用双指针

![](https://code-thinking-1253855093.file.myqcloud.com/pics/20210204153247458.png)



### 答案代码

递归

```java
class Solution{
  TreeNode pre;//记录上一个遍历的结点
  int result = Integer.MAX_VALUE;
  public int getMinimumDifference(TreeNode root){
    traversal(root);
    return result;
  }
  
  public void traversal(TreeNode root){
    if(root == null) return;
    //左
    traversal(root.left);
    //中
    if(pre != null){
      result = Math.min(result,root.val - pre.val);
    }
    pre = root;
    //右
    traversal(root.right);
  }
}
```



迭代

```java
class Solution {
    TreeNode pre;
    Stack<TreeNode> stack;
    public int getMinimumDifference(TreeNode root) {
        if (root == null) return 0;
        stack = new Stack<>();
        TreeNode cur = root;
        int result = Integer.MAX_VALUE;
        while (cur != null || !stack.isEmpty()) {
            if (cur != null) {
                stack.push(cur); // 将访问的节点放进栈
                cur = cur.left; // 左
            }else {
                cur = stack.pop(); 
                if (pre != null) { // 中
                    result = Math.min(result, cur.val - pre.val);
                }
                pre = cur;
                cur = cur.right; // 右
            }
        }
        return result;
    }
}
```





##二十、二叉搜索树中的众数

### 题目

![](https://raw.githubusercontent.com/vankykoo/javaStudy/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E9%A2%98%E7%9B%AE/%E4%BA%8C%E5%8F%89%E6%A0%91/13.png)

### 思路

* 使用双指针递归遍历
* 定义全局遍历pre指针，maxcount记录众数，count记录目前数
* 思路：
  * 如果count等于maxcount，把这个元素加入到结果集中（result数组）
  * 如果count大于maxcount的时候，不仅要更新maxcount，而且要清空结果集。



### 代码

```java
class Solution{
  ArrayList<Integer> resList;
  int maxCount;
  int count;
  TreeNode pre;
  
  public int[] findMode(TreeNode root){
    resList = new ArrayList<>();
    maxCount = 0;
    count = 0;
    pre = null;
    findMode1(root);
    int[] res = new int[resList.size()];
    for(int i = 0;i < resList.size();i++){
      res[i] = resList.get(i);
    }
    return res;
  }
  
  public void findMode1(TreeNode root){
    if(root == null){
      return;
    }
    findMode1(root.left);
    
    int rootValue = root.val;
    //计数
    if(pre == null || rootValue != pre.val){
      count = 1;
    }else{
      count++;
    }
    //更新结果以及maxCount
    if(count > maxCount){
      resList.clear();
      resList.add(rootValue);
      maxCount = count;
    }else if(count == maxCount){
      resList.add(rootValue);
    }
    pre = root;
    
    findMode1(root.right);
  }
}
```



```java
//迭代法
class Solution {
    public int[] findMode(TreeNode root) {
        TreeNode pre = null;
        Stack<TreeNode> stack = new Stack<>();
        List<Integer> result = new ArrayList<>();
        int maxCount = 0;
        int count = 0;
        TreeNode cur = root;
        while (cur != null || !stack.isEmpty()) {
            if (cur != null) {
                stack.push(cur);
                cur =cur.left;
            }else {
                cur = stack.pop();
                // 计数
                if (pre == null || cur.val != pre.val) {
                    count = 1;
                }else {
                    count++;
                }
                // 更新结果
                if (count > maxCount) {
                    maxCount = count;
                    result.clear();
                    result.add(cur.val);
                }else if (count == maxCount) {
                    result.add(cur.val);
                }
                pre = cur;
                cur = cur.right;
            }
        }
        return result.stream().mapToInt(Integer::intValue).toArray();
    }
}
```





## 二十一、二叉树的最近公共祖先

### 题目

![](https://raw.githubusercontent.com/vankykoo/javaStudy/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E9%A2%98%E7%9B%AE/%E4%BA%8C%E5%8F%89%E6%A0%91/14.png)



### 思路

* 利用回溯从二叉树底部向上查找
* 情况一：一个结点左子树出现结点p，右子树出现结点q，或者左子树出现结点q，右子树出现结点p。那么该节点就是结点p和q的最近公共祖先。
  *  如果递归遍历遇到q，就将q返回，遇到p 就将p返回，那么如果 左右子树的返回值都不为空，说明此时的中节点，一定是q 和p 的最近祖先。
* 情况二：结点本身p(q)，它拥有一个子孙结点q(p)。



搜索一条边的写法：

```java
if (递归函数(root->left)) return ;

if (递归函数(root->right)) return ;
```

搜索整个树的写法：

```java
left = 递归函数(root->left);  // 左
right = 递归函数(root->right); // 右
left与right的逻辑处理;         // 中 
```

区别：在递归函数有返回值的情况下：如果要搜索一条边，递归函数返回值不为空的时候，立刻返回，如果搜索整个树，直接用一个变量left、right接住返回值，这个left、right后序还有逻辑处理的需要，也就是后序遍历中间结点的逻辑（也是回溯）。



![](https://code-thinking-1253855093.file.myqcloud.com/pics/202102041512582.png)



### 代码

```java
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if (root == null || root == p || root == q) { // 递归结束条件
            return root;
        }

        // 后序遍历
        TreeNode left = lowestCommonAncestor(root.left, p, q);
        TreeNode right = lowestCommonAncestor(root.right, p, q);

        if(left == null && right == null) { // 若未找到节点 p 或 q
            return null;
        }else if(left == null && right != null) { // 若找到一个节点
            return right;
        }else if(left != null && right == null) { // 若找到一个节点
            return left;
        }else { // 若找到两个节点
            return root;
        }
    }
}
```





## 二十二、搜索二叉树的最近公共结点

### 题目

![](https://raw.githubusercontent.com/vankykoo/javaStudy/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E9%A2%98%E7%9B%AE/%E4%BA%8C%E5%8F%89%E6%A0%91/15.png)



### 思路

* 从根结点向下遍历


* 如果p、q的value都大于root的value，说明p、q都在root的右子树中，相反，如果p、q的value都小于root的value，说明p、q都在root的左子树中。
* 如果p、q分别在root的左右子树中，则说明root则为最近公共结点。



* 特殊的：如果p == root 或q == root，则root也为最近公共结点。





### 代码

```java
//我的代码
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if(root == null || root == p || root == q){
            return root;
        }

        if(p.val > root.val && q.val > root.val){
            return lowestCommonAncestor(root.right,p,q);
        }

        if(p.val < root.val && q.val < root.val){
            return lowestCommonAncestor(root.left,p,q);
        }

        return root;
    }
}
```



```java
//答案递归版
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if (root.val > p.val && root.val > q.val) return lowestCommonAncestor(root.left, p, q);
        if (root.val < p.val && root.val < q.val) return lowestCommonAncestor(root.right, p, q);
        return root;
    }
}
```

```java
//答案迭代版
class Solution{
  public TreeNode lowestCommonAncestor(TreeNode root,TreeNode p,TreeNode q){
    while(true){
      if(root.val > p.val && root.val > q.val){
        root = root.left;
      }else if(root.val < p.val && root.val < q.val){
        root = root.right;
      }else {
        break;
      }
    }
    return root;
  }
}
```







## 二十三、二叉搜索树中的插入操作

### 题目



## 思路

其实插入的结点都会插入到原二叉树的叶子结点中，所以不用改变原二叉树的结构！

![](https://code-thinking.cdn.bcebos.com/gifs/701.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C.gif)

使用递归

* 确定递归函数的参数以及返回值
  * 参数：根结点，插入元素
  * 返回值：可有可无。如果有，可以利用新插入的结点作为返回值。
* 确定终止条件：
  * 如果结点为null，则在此插入，并返回新插入的结点。
* 单层递归逻辑
  * 应该能感受到，如何通过递归函数返回值完成了新加入节点的父子关系赋值操作了，下一层将加入节点返回，本层用root->left或者root->right将其接住。





### 代码

```java
//我的代码
class Solution {
    public TreeNode insertIntoBST(TreeNode root, int val) {
        if(root == null){
            return new TreeNode(val);
        }

        return traversal(root,root,val);
    }

    public TreeNode traversal(TreeNode root,TreeNode node, int val){
        if(node.val < val && node.right == null){
            node.right = new TreeNode(val);
            return root;
        }
        if(node.val < val && node.right != null){
            traversal(root,node.right,val);
        }

        if(node.val > val && node.left == null){
            node.left = new TreeNode(val);
            return root;
        }
        if(node.val > val && node.left != null){
            traversal(root,node.left,val);
        }

        return root;
    }
}
```



```java
//答案代码递归版
class Solution {
    public TreeNode insertIntoBST(TreeNode root, int val) {
        if (root == null) // 如果当前节点为空，也就意味着val找到了合适的位置，此时创建节点直接返回。
            return new TreeNode(val);
            
        if (root.val < val){
            root.right = insertIntoBST(root.right, val); // 递归创建右子树
        }else if (root.val > val){
            root.left = insertIntoBST(root.left, val); // 递归创建左子树
        }
        return root;
    }
}
```



```java
//迭代版
class Solution {
    public TreeNode insertIntoBST(TreeNode root, int val) {
        if (root == null) return new TreeNode(val);
        TreeNode newRoot = root;
        TreeNode pre = root;
        while (root != null) {
            pre = root;
            if (root.val > val) {
                root = root.left;
            } else if (root.val < val) {
                root = root.right;
            } 
        }
        if (pre.val > val) {
            pre.left = new TreeNode(val);
        } else {
            pre.right = new TreeNode(val);
        }

        return newRoot;
    }
}
```







## 二十四、删除二叉搜索树中的节点

### 题目

![](https://raw.githubusercontent.com/vankykoo/javaStudy/b6cf15f787b348250a27fa355deff29e8ac9727b/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E9%A2%98%E7%9B%AE/%E4%BA%8C%E5%8F%89%E6%A0%91/16.png)





### 我的思路

定义全局变量：上一个节点pre



分为五种情况

- 没找到结点，返回nowRoot
- 左右孩子都为空，即叶子结点，直接让pre指向null
- 删除节点的左孩子为空，右孩子不为空，让pre指向当前节点的左孩子或右孩子（看key和root.val的比较）
- 删除节点的右孩子为空，左孩子不为空，让pre指向当前节点的左孩子或右孩子（看key和root.val的比较）
- 左右孩子都不为空，则将删除节点左子树头结点（左孩子）放到删除节点的右子树的最左面节点的左孩子上，让pre指向当前节点的左孩子或右孩子（看key和root.val的比较）



### 我的代码

```java
class Solution {
    TreeNode nowRoot = null;
    TreeNode pre = null;

    public TreeNode deleteNode(TreeNode root, int key) {
        pre = root;
        if(root == null){
            return root;
        }
        if(root.val == key){
            if(root.right == null){
                return root.left;
            }
            TreeNode newNode = findNode(root.right);
            newNode.left = root.left;

            return root.right;
        }

        traversal(root,key);

        return root;
    }

    public TreeNode traversal(TreeNode root, int key){
        if(root == null){
            return null;
        }

        if(root.val == key){

            //如果左右孩子都为空（即叶子节点）
            //让pre指向null
            if(root.right == null && root.left == null){

                if(pre.val > key){
                    pre.left = null;
                }else{
                    pre.right = null;
                }
            }

            //如果左孩子为空，右孩子不为空
            if(root.left == null && root.right != null){
                if(pre.val > key){
                    pre.left = root.right;
                }else{
                    pre.right = root.right; 
                }
            }

            //如果右孩子为空，左孩子不为空
            if(root.left != null && root.right == null){
                if(pre.val > key){
                    pre.left = root.left;
                }else{
                    pre.right = root.left; 
                }
            }

            //如果都不为空
            //则将左孩子放到右孩子的左孩子的左孩子的左孩子。。。。
            if(root.left != null && root.right != null){
                if(pre.val > key){
                    pre.left = root.right;
                }
                if(pre.val < key){
                    pre.right = root.right;
                }

                TreeNode newNode = findNode(root.right);
                newNode.left = root.left;
            }
            
            return root;
        }
        pre = root;
        TreeNode right = traversal(root.right,key);
        pre = root;
        TreeNode left = traversal(root.left,key);

        if(right != null){
            return right;
        }
        if(left != null){
            return left;
        }
        return null;
    }

    //用来找最左的孩子
    public TreeNode findNode(TreeNode node){
        while(node.left != null){
            node = node.left;
        }

        return node;
    }
}
```





### 答案思路

* 分为五种情况
  * 没找到结点，遍历到空节点直接返回了
  * 左右孩子都为空，即叶子结点，直接删除结点，返回null为根结点
  * 删除节点的左孩子为空，右孩子不为空，删除节点，右孩子补位，返回右孩子为根结点。
  * 删除节点的右孩子为空，左孩子不为空，删除节点，左孩子补位，返回左孩子为根结点。
  * 左右孩子都不为空，则将删除节点左子树头结点（左孩子）放到删除节点的右子树的最左面节点的左孩子上，返回删除节点右孩子为新的根结点。

![第五种情况](https://code-thinking.cdn.bcebos.com/gifs/450.%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9.gif)







### 代码

```java
class Solution {
    public TreeNode deleteNode(TreeNode root, int key) {
        root = delete(root,key);
        return root;
    }

    private TreeNode delete(TreeNode root, int key) {
        if (root == null) return null;

        if (root.val > key) {
            root.left = delete(root.left,key);
        } else if (root.val < key) {
            root.right = delete(root.right,key);
        } else {
            if (root.left == null) return root.right;
            if (root.right == null) return root.left;
            TreeNode tmp = root.right;
            while (tmp.left != null) {
                tmp = tmp.left;
            }
            root.val = tmp.val;
            root.right = delete(root.right,tmp.val);
        }
        return root;
    }
}
```



```java
class Solution {
  public TreeNode deleteNode(TreeNode root, int key) {
    if (root == null) return root;
    if (root.val == key) {
      if (root.left == null) {
        return root.right;
      } else if (root.right == null) {
        return root.left;
      } else {
        TreeNode cur = root.right;
        while (cur.left != null) {
          cur = cur.left;
        }
        cur.left = root.left;
        root = root.right;
        return root;
      }
    }
    if (root.val > key) root.left = deleteNode(root.left, key);
    if (root.val < key) root.right = deleteNode(root.right, key);
    return root;
  }
}
```







## 二十五、修建二叉树

### 题目



## 我的思路

* 使用递归
* 如果root.val等于low，就让root的左孩子为空，否则递归获取左孩子的值；如果root.val等于high，就让root的右孩子为空，否则递归获取右孩子的值。
* 如果root.val小于low，就返回root的右孩子；如果root.val等于high，就返回root的左孩子。
* 最后返回root。

## 我的代码

```java
class Solution {
    public TreeNode trimBST(TreeNode root, int low, int high) {
        if(root == null){
            return null;
        }

        if(root.val == low){
            root.left = null;
        }else{
            root.left = trimBST(root.left,low,high);
        }

        if(root.val == high){
            root.right = null;
        }else{
            root.right = trimBST(root.right,low,high);
        }

        if(root.val < low){
            return root.right;
        }

        if(root.val > high){
            return root.left;
        }

        return root;
    }
}
```



### 答案思路

发现节点0并不符合区间要求，那么将节点0的右孩子 节点2 直接赋给 节点3的左孩子就可以了（就是把节点0从二叉树中移除），如图：

![](https://code-thinking-1253855093.file.myqcloud.com/pics/20210204155327203.png)



* 递归逻辑：
  * 如果root（当前节点）的元素小于low的数值，那么应该递归右子树，并返回右子树符合条件的头结点。
  * 如果root(当前节点)的元素大于high的，那么应该递归左子树，并返回左子树符合条件的头结点。



### 答案代码

```java
//递归
class Solution {
    public TreeNode trimBST(TreeNode root, int low, int high) {
        if (root == null) {
            return null;
        }
        if (root.val < low) {
            return trimBST(root.right, low, high);
        }
        if (root.val > high) {
            return trimBST(root.left, low, high);
        }
        // root在[low,high]范围内
        root.left = trimBST(root.left, low, high);
        root.right = trimBST(root.right, low, high);
        return root;
    }
}
```



```java
//迭代
// 将root移动到[L, R] 范围内，注意是左闭右闭区间
// 剪枝左子树
// 剪枝右子树
class Solution {
    //iteration
    public TreeNode trimBST(TreeNode root, int low, int high) {
        if(root == null)
            return null;
        while(root != null && (root.val < low || root.val > high)){
            if(root.val < low)
                root = root.right;
            else
                root = root.left;
        }

        TreeNode curr = root;
        
        //deal with root's left sub-tree, and deal with the value smaller than low.
        while(curr != null){
            while(curr.left != null && curr.left.val < low){
                curr.left = curr.left.right;
            }
            curr = curr.left;
        }
        //go back to root;
        curr = root;

        //deal with root's righg sub-tree, and deal with the value bigger than high.
        while(curr != null){
            while(curr.right != null && curr.right.val > high){
                curr.right = curr.right.left;
            }
            curr = curr.right;
        }
        return root;
    }
}
```







## 二十六、将有序数组转换为搜索二叉树

### 题目

![](https://raw.githubusercontent.com/vankykoo/javaStudy/095c2dfe98e331290f921d7095b6038d2cf9c5fc/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E9%A2%98%E7%9B%AE/%E4%BA%8C%E5%8F%89%E6%A0%91/17.png)



###我的思路

* 使用递归
* 递归逻辑：[begin,end]左闭右闭
  * 数组的中间节点【index = (begin + end) / 2】作为中间节点root。
  * 将begin和index-1作为root的左子树。
  * 将index+1和end作为root的右子树。
* 如果begin > end就返回null。



### 我的代码

```java
class Solution {
    public TreeNode sortedArrayToBST(int[] nums) {
        return traversal(nums,0,nums.length - 1);
    }

    public TreeNode traversal(int[] nums, int begin,int end){
        if(begin > end){
            return null;
        }

        int index = (begin + end) / 2;
        TreeNode root = new TreeNode(nums[index]);

        root.left = traversal(nums,begin,index - 1);
        root.right = traversal(nums,index + 1,end);

        return root;
    }
}
```







## 二十七、把二叉搜索树转换为累加树

### 题目

![](https://raw.githubusercontent.com/vankykoo/javaStudy/c37af5449853f5d25021cba54798f192f19eeb16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E9%A2%98%E7%9B%AE/%E4%BA%8C%E5%8F%89%E6%A0%91/18.png)



### 我的思路

* 使用递归，定义一个全部变量pre保存上一次遍历到的节点
* 使用右左中的顺序递归。
* 中间逻辑，它的上一个pre实际上是右孩子的最左孩子节点。



### 我的代码

```java
class Solution {

    TreeNode pre = null;

    public TreeNode convertBST(TreeNode root) {
        pre = new TreeNode(0);
        return traversal(root);
    }

    public TreeNode traversal(TreeNode root){
        if(root == null){
            return root;
        }

        root.right = traversal(root.right);
        if(root.right != null){
            pre = findLeft(root.right);
        }

        root.val = pre.val + root.val;
        pre = root;

        root.left = traversal(root.left);
        if(root.left != null){
            pre = root.left;
        }

        return root;
    }

    public TreeNode findLeft(TreeNode root){
        while(root.left != null){
            root = root.left;
        }

        return root;
    }
}
```





### 答案思路

全局变量不是记录上一个节点，而是记录累加值，这样更好！



### 答案代码

```java
class Solution {
    int sum;
    public TreeNode convertBST(TreeNode root) {
        sum = 0;
        convertBST1(root);
        return root;
    }

    // 按右中左顺序遍历，累加即可
    public void convertBST1(TreeNode root) {
        if (root == null) {
            return;
        }
        convertBST1(root.right);
        sum += root.val;
        root.val = sum;
        convertBST1(root.left);
    }
}
```



```java
class Solution {
    //DFS iteraion統一迭代法
    public TreeNode convertBST(TreeNode root) {
        int pre = 0;
        Stack<TreeNode> stack = new Stack<>();
        if(root == null) //edge case check
            return null;

        stack.add(root);

        while(!stack.isEmpty()){
            TreeNode curr = stack.peek();
            //curr != null的狀況，只負責存node到stack中
            if(curr != null){ 
                stack.pop();
                if(curr.left != null)       //左
                    stack.add(curr.left);
                stack.add(curr);            //中
                stack.add(null);
                if(curr.right != null)      //右
                    stack.add(curr.right);
            }else{
            //curr == null的狀況，只負責做單層邏輯
                stack.pop();
                TreeNode temp = stack.pop();
                temp.val += pre;
                pre = temp.val;
            }
        }
        return root;
    }
}
```













































