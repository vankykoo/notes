# 暑假算法练习

## 一、字符串

### 一、两数之和

暴力法

```java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        int[] res = new int[2];
        int len = nums.length;
        for(int i = 0; i < len; i++){
            for(int j = i + 1; j < len; j++){
                if(nums[j] == target - nums[i]){
                    res[0] = i;
                    res[1] = j;
                    return res;
                }
            }
        }

        return res;
    }
}
```

空间换时间：使用哈希表

```java
public int[] twoSum(int[] nums, int target) {
        HashMap<Integer, Integer> map = new HashMap<>();
        for(int i = 0; i < nums.length; i++){
            map.put(nums[i], i);
        }

        for(int i = 0; i < nums.length; i++){
            Integer tag = map.get(target - nums[i]);
            if(tag != null && i != tag){
                int[] res = {i, tag};
                return res;
            }
        }

        return null;
    }
```

题解：当没有在hash表中找到匹配的数时，才把当前数插入到哈希表中，这样可以避免匹配一样的数字。

```java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer, Integer> hashtable = new HashMap<Integer, Integer>();
        for (int i = 0; i < nums.length; ++i) {
            if (hashtable.containsKey(target - nums[i])) {
                return new int[]{hashtable.get(target - nums[i]), i};
            }
            hashtable.put(nums[i], i);
        }
        return new int[0];
    }
}
```



### 二、字母异位词分组

```java
class Solution {
    public List<List<String>> groupAnagrams(String[] strs) {
        List<List<String>> res = new ArrayList<>();
        // （一种字符组合，res中对应的下标）
        Map<String, Integer> map = new HashMap<>();

        for(int i = 0; i < strs.length; i++){
            //将字符串进行排序
            String tag = sortString(strs[i]);
            if(map.containsKey(tag)){
                //如果map中有该字符组合，则将原字符串加入到对应的list中。
                res.get(map.get(tag)).add(strs[i]);
            }else{
                //如果map中没有该字符组合，说明是第一次出现
                //创建新的list，并且加入到map中，标记数组下标
                List<String> list = new ArrayList<>();
                list.add(strs[i]);
                res.add(list);
                map.put(tag, res.size()-1);
            }
        }

        return res;
    }

    public String sortString(String str) {
        // 将字符串转换为字符数组
        char[] charArray = str.toCharArray();
        
        // 对字符数组进行排序
        Arrays.sort(charArray);
        
        // 将排序后的字符数组转换回字符串
        return new String(charArray);
    }
}
```



题解：答案是直接在map中存储list数组的。

```java
class Solution {
    public List<List<String>> groupAnagrams(String[] strs) {
        Map<String, List<String>> map = new HashMap<String, List<String>>();
        for (String str : strs) {
            char[] array = str.toCharArray();
            Arrays.sort(array);
            String key = new String(array);
            List<String> list = map.getOrDefault(key, new ArrayList<String>());
            list.add(str);
            map.put(key, list);
        }
        return new ArrayList<List<String>>(map.values());
    }
}
```



### 三、最长连续序列

**题解：简单来说就是每个数都判断一次这个数是不是连续序列的开头那个数**。

- 怎么判断呢，就是用哈希表查找这个数前面一个数是否存在，即num-1在序列中是否存在。存在那这个数肯定不是开头，直接跳过。
- 因此只需要对每个开头的数进行循环，直到这个序列不再连续，因此复杂度是O(n)。 以题解中的序列举例:
  **[100，4，200，1，3，4，2]**
  去重后的哈希序列为：
  **[100，4，200，1，3，2]**
  按照上面逻辑进行判断：

1. 元素100是开头,因为没有99，且以100开头的序列长度为1
2. 元素4不是开头，因为有3存在，过，
3. 元素200是开头，因为没有199，且以200开头的序列长度为1
4. 元素1是开头，因为没有0，且以1开头的序列长度为4，因为依次累加，2，3，4都存在。
5. 元素3不是开头，因为2存在，过，
6. 元素2不是开头，因为1存在，过。

```java

```



## 二、双指针

### 四、移动零

我的

```java
class Solution {
    public void moveZeroes(int[] nums) {
        //第一个零和第一个非零的数交换
        int nzr = 0;    // 非 0

        for(int i = 0; i < nums.length; i++){
            if(nums[i] == 0){
                nzr = i + 1;
                while(nzr < nums.length && nums[nzr] == 0){
                    nzr++;
                }
                if(nzr < nums.length){
                    wrap(nums, nzr, i);
                }
            }
        }
    }

    public void wrap(int[] nums, int a, int b){
        int tag = nums[a];
        nums[a] = nums[b];
        nums[b] = tag;
    }
}
```



题解

![](https://pic.leetcode-cn.com/36d1ac5d689101cbf9947465e94753c626eab7fcb736ae2175f5d87ebc85fdf0-283_2.gif)

```java
class Solution {
    public void moveZeroes(int[] nums) {
        int nzr = 0;    // 移动到非 0 的数值

        for(int i = 0; i < nums.length; i++){
            if(nums[i] != 0){
                int tag = nums[i];
                nums[i] = nums[nzr];
                nums[nzr++] = tag;
            }
        }
    }
}
```



### 五、盛最多水的容器

#### 为什么移动水位较低的指针？

面积 = 长 * 宽。

首先 ，无论移动谁，长都是会变小的。

然后宽是有两个指针水位较低者决定的，如果移动水位较高的指针：得到的新水位比原来低水位指针更低时，此时宽变小了，则面积变小；即使得到的新水位比原来高水位还要高，但是宽还是由原来低水位决定的，此时宽不必，但由于长变小了，则面积还是变小。

所以啊，如果移动水位较高的指针，无论如何面积都是变小。

```java
class Solution {
    public int maxArea(int[] height) {
        int res = 0;
        int left = 0;
        int right = height.length - 1;

        while(left < right){
            //计算
            res = Math.max(res, (right-left) * Math.min(height[left], height[right]));

            //移动水位较低的指针
            if(height[left] < height[right]){
                left++;
            }else{
                right--;
            }
        }

        return res;
    }
}
```

### 六、三数之和

#### 如何去重？

1. 如果当前元素 `nums[i]` 和前一个元素 `nums[i-1]` 相同，那么跳过当前元素以避免产生重复的三元组。
2. 通过两个 `while` 循环分别跳过相同的左指针和右指针的元素，以确保找到的三元组是唯一的。

```java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        List<List<Integer>> res = new ArrayList<>();

        int len = nums.length;
        int left = 0;
        int right = nums.length - 1;
        //排序
        Arrays.sort(nums);
        //最左边的必须要小于等于零
        for(int i = 0; i < len && nums[i] <= 0; i++){
            //去重
            if(i > 0 && nums[i] == nums[i-1]){
                continue;
            }

            left = i + 1;
            right = nums.length - 1;

            //这个是目标值，题目变为找两个和为target的数
            int target = 0 - nums[i];

            while(left < right){
                if(nums[left] + nums[right] < target){
                    //和太小
                    left++;
                }else if(nums[left] + nums[right] > target){
                    //和太大
                    right--;
                }else{
                    //和 等于 target
                    res.add(Arrays.asList(nums[i], nums[left], nums[right]));

                    //一次找完所有等于target的两个数
                    //去重
                    while(left < right && nums[left] == nums[left+1]){
                        left++;
                    }
                    while(left < right && nums[right] == nums[right-1]){
                        right--;
                    }

                    left++;
                    right--;
                }
            }
        }

        return res;
    }
}
```



### 七、接雨水（困难）

题解

```java
class Solution {
    public int trap(int[] height) {
        if (height == null || height.length == 0) {
            return 0;
        }
	//左右指针下标
        int left = 0, right = height.length - 1;
      //左右边最大高度
        int leftMax = height[left], rightMax = height[right];
        int res = 0;

        while (left < right) {
            if (leftMax < rightMax) {
              //如果左边最大高度小于右边最大高度
              //1.左指针右移（用于更新最大高度，或是计算能接的雨水
              //1.1 第一种情况：更新后高度大于原来的最大高度，则接不到雨水，用于更新最大高度
              //1.2 第二种情况：更新后高度小于原来的最大高度，既然小于较小的最大高度，
              //				那接到的雨水就是与较小最大高度的差值，且不更新高度
                left++;
                leftMax = Math.max(leftMax, height[left]);
              //如果更新了最大高度，这里 leftMax = height[left] 即 res += 0;
                res += leftMax - height[left];
            } else {
                right--;
                rightMax = Math.max(rightMax, height[right]);
                res += rightMax - height[right];
            }
        }

        return res;
    }
}
```



## 三、滑动窗口

### 八、无重复字符的最长子串

```java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        int len = s.length();
        Set<Character> set = new HashSet<>();
        int res = 0, begin = 0, end = 0;
        
        while (begin < len && end < len) {
            if (!set.contains(s.charAt(end))) {
                // 如果字符不重复，添加到集合中
                set.add(s.charAt(end++));
                // 更新最长长度
                res = Math.max(res, end - begin);
            } else {
                // 如果字符重复，从左边开始移除字符
                set.remove(s.charAt(begin++));
            }
        }
        
        return res;
    }
}
```



### 九、找到字符串中所有字母异位词

```java
class Solution {
    public List<Integer> findAnagrams(String s, String p) {
        List<Integer> result = new ArrayList<>();
        
        if (s == null || p == null || s.length() < p.length()) {
            return result;
        }
        
        // 记录p的字符频率
        int[] pCount = new int[26];
        for (char c : p.toCharArray()) {
            pCount[c - 'a']++;
        }
        
        // 记录当前窗口内的字符频率
        int[] sCount = new int[26];
        int windowSize = p.length();
        
        // 遍历字符串s
        for (int i = 0; i < s.length(); i++) {
            // 增加当前字符到窗口内
            sCount[s.charAt(i) - 'a']++;
            
            // 当窗口大小超过p的长度时，移除最左边的字符（关键）
            if (i >= windowSize) {
                sCount[s.charAt(i - windowSize) - 'a']--;
            }
            
            // 比较两个计数器
            if (isAnagram(pCount, sCount)) {
                result.add(i - windowSize + 1);
            }
        }
        
        return result;
    }
    
    //判断两个计数器是否相等
    private boolean isAnagram(int[] pCount, int[] sCount) {
        for (int i = 0; i < 26; i++) {
            if (pCount[i] != sCount[i]) {
                return false;
            }
        }
        return true;
    }
}
```



## 四、子串

### 十、和为 K 的子数组（前缀和+哈希表）

题解：

### 思路：

1. **前缀和 (Prefix Sum)**：前缀和是指从数组的起始元素到当前元素的所有元素的和。通过前缀和，可以将问题转化为寻找两个前缀和的差值为 K 的问题。
2. **哈希表 (Hash Map)**：使用哈希表来存储前缀和出现的次数。通过查找当前前缀和减去 K 是否存在于哈希表中，可以快速找到满足条件的子数组个数。

### 具体步骤：

1. 初始化一个哈希表 `prefixSumCount`，将前缀和 0 的次数设为 1，因为前缀和为 0 表示从数组起始元素到当前元素的和本身可能等于 K。
2. 遍历数组，计算当前元素的前缀和 `currentSum`。
3. 检查 `currentSum - K` 是否在哈希表中，如果存在，说明从某个位置到当前元素的子数组和为 K，将结果计数器增加相应的次数。
4. 更新哈希表中当前前缀和的出现次数。

```java
class Solution {
    public int subarraySum(int[] nums, int k) {
        // 前缀和哈希表，存储前缀和出现的次数
        HashMap<Integer, Integer> prefixSumCount = new HashMap<>();
        // 初始化前缀和0出现的次数为1
        prefixSumCount.put(0, 1);

        int currentSum = 0;
        int count = 0;

        // 遍历数组
        for (int num : nums) {
            currentSum += num; // 计算当前前缀和
            
            // 检查 currentSum - k 是否在哈希表中
            if (prefixSumCount.containsKey(currentSum - k)) {
                count += prefixSumCount.get(currentSum - k); // 增加满足条件的子数组个数
            }
            
            // 更新哈希表中当前前缀和的出现次数
            prefixSumCount.put(currentSum, prefixSumCount.getOrDefault(currentSum, 0) + 1);
        }

        return count;
    }
}
```



### 十一、滑动窗口最大值（困难）（双端队列）

题解：

1. **双端队列**：使用一个双端队列保存当前窗口中的元素索引，队列中的元素从头到尾递减，队首元素为当前窗口的最大值。
2. **保持队列递减**：在遍历数组时，如果新元素大于队尾元素，则将队尾元素移除，直到新元素不再大于队尾元素。
3. **移除过期元素**：如果队首元素的索引已经不在当前窗口范围内，则将其移除。
4. **记录最大值**：当窗口大小达到 k 时，将队首元素对应的值记录到结果数组中。

```java
class Solution {
    public int[] maxSlidingWindow(int[] nums, int k) {
        if (nums == null || nums.length < 2) {
            return nums;
        }

        // 双端队列，存储元素的索引
        Deque<Integer> deque = new LinkedList<>();
        // 结果数组
        int[] result = new int[nums.length - k + 1];

        for (int i = 0; i < nums.length; i++) {
            // 移除不在窗口范围内的元素
            while (!deque.isEmpty() && deque.peekFirst() < i - k + 1) {
                deque.pollFirst();
            }
            // 移除队列中小于当前元素的元素
            while (!deque.isEmpty() && nums[deque.peekLast()] < nums[i]) {
                deque.pollLast();
            }
            // 将当前元素添加到队列中
            deque.offerLast(i);
            // 当窗口大小达到 k 时，记录当前窗口的最大值
            if (i >= k - 1) {
                result[i - k + 1] = nums[deque.peekFirst()];
            }
        }

        return result;
    }
}
```



### 十二、最小覆盖子串（困难）（滑动窗口+哈希表）

题解：

1. 初始化两个哈希表 `tFreq` 和 `windowFreq`，分别记录 `t` 中的字符及其出现次数和当前窗口中的字符及其出现次数。
2. 使用两个指针 `left` 和 `right` 初始化滑动窗口的左右边界，`right` 指针用于扩展窗口，`left` 指针用于收缩窗口。
3. 右指针移动，扩展窗口，更新窗口内字符的出现次数。如果窗口内字符数量满足 `t` 的要求，尝试收缩窗口以找到最小子串。
4. 左指针移动，收缩窗口，更新窗口内字符的出现次数。如果当前窗口不再满足 `t` 的要求，停止收缩，继续扩展窗口。
5. 在整个过程中记录满足条件的最小子串。

```java
class Solution {
    public String minWindow(String s, String t) {
        if (s == null || t == null || s.length() < t.length()) {
            return "";
        }

        // 记录 t 中各字符的出现次数
        HashMap<Character, Integer> tFreq = new HashMap<>();
        for (char c : t.toCharArray()) {
            tFreq.put(c, tFreq.getOrDefault(c, 0) + 1);
        }

        // 滑动窗口中各字符的出现次数
        HashMap<Character, Integer> windowFreq = new HashMap<>();
        int left = 0, right = 0;
        int required = tFreq.size(); // 需要匹配的字符种类数
        int formed = 0; // 当前窗口内匹配的字符种类数
        int[] ans = {-1, 0, 0}; // 记录结果，格式为{窗口长度, 左边界, 右边界}

        // 移动右指针
        while (right < s.length()) {
            char c = s.charAt(right);
            windowFreq.put(c, windowFreq.getOrDefault(c, 0) + 1);

            // 如果当前字符在 t 中，且窗口内该字符的数量与 t 中要求的数量相同，则 formed 加 1
            if (tFreq.containsKey(c) && windowFreq.get(c).intValue() == tFreq.get(c).intValue()) {
                formed++;
            }

            // 尝试收缩窗口
            while (left <= right && formed == required) {
                c = s.charAt(left);

                // 更新最小窗口，如果当前窗口的长度小于之前记录的最小长度，则更新结果
                if (ans[0] == -1 || right - left + 1 < ans[0]) {
                    ans[0] = right - left + 1;
                    ans[1] = left;
                    ans[2] = right;
                }

                // 左指针右移，缩小窗口
                windowFreq.put(c, windowFreq.get(c) - 1);
                if (tFreq.containsKey(c) && windowFreq.get(c).intValue() < tFreq.get(c).intValue()) {
                    formed--;
                }

                left++;
            }

            right++;
        }

        // 返回最小覆盖子串，如果 ans[0] 未更新过，说明未找到满足条件的子串，返回空字符串
        return ans[0] == -1 ? "" : s.substring(ans[1], ans[2] + 1);
    }
}
```



## 五、普通数组

### 十三、最大子数组和

```java
class Solution {
    public int maxSubArray(int[] nums) {
        int res = Integer.MIN_VALUE;
        int sum = 0;

        for(int i = 0; i < nums.length; i++){
            sum += nums[i];
            res = Math.max(sum, res);

          //如果和已经小于零，那么只会让后面的和更小，直接置零
            if(sum < 0){
                sum = 0;
            }
        }

        return res;
    }
}
```



### 十四、合并区间

栈

```java
//类似于下面的方法，没有用左右边界，因为左边界其实用不到，那就把右边界作为栈顶。
class Solution {
    public int[][] merge(int[][] intervals) {
        if(intervals.length == 0){
            return null;
        }

        Arrays.sort(intervals, (a,b) -> {return a[0] - b[0];});

        Stack<Integer> stack = new Stack<>();

        for(int i = 0; i < intervals.length; i++){
            if(!stack.empty() && stack.peek() >= intervals[i][0]){
                if(stack.peek() < intervals[i][1]){
                    stack.pop();
                    stack.push(intervals[i][1]);
                }
            } else{
                stack.push(intervals[i][0]);
                stack.push(intervals[i][1]);
            }
        }

        int size = stack.size() / 2;
        int[][] res = new int[size][2];

        for(int i = size-1; i >= 0; i--){
            res[i][1] = stack.pop();
            res[i][0] = stack.pop();
        }

        return res;
    }
}
```



左右边界

```java
class Solution {
    public int[][] merge(int[][] intervals) {
        if(intervals.length == 0){
            return null;
        }

        Arrays.sort(intervals, (a,b) -> {return a[0] - b[0];});

        List<int[]> res = new ArrayList<>();
      //记录左右边界
        int left = intervals[0][0];
        int right = intervals[0][1];

        for(int i = 1; i < intervals.length; i++){
            if(intervals[i][0] <= right){
              //为什么不在外面的if 用 && 符？有种情况是 被完全包含在里面，即子集，这种不用做处理
                if(intervals[i][1] >= right){
                  //可以合并
                    right = intervals[i][1];
                }
            }else{
              //不可以合并了，添加到结果集，更新左右边界
                res.add(new int[]{left, right});
                left = intervals[i][0];
                right = intervals[i][1];
            }
        }
        res.add(new int[]{left, right});

        return res.toArray(new int[0][2]);
    }
}
```



这两种方法的前提都是根据原数组的第一个数进行从小到大排序。



### 十五、轮转数组

题解：

使用三次翻转：

例：{1,2,3,4,5,6,7} ，k = 3

第一次翻转：下标[0,6] ====> {7,6,5,4,3,2,1}

第二次翻转：下标[0,2] ====> {5,6,7,4,3,2,1}

第三次翻转：下标[3,6] ====> {5,6,7,1,2,3,4}

```java
class Solution {
    public void rotate(int[] nums, int k) {
        k %= nums.length;
        reverse(nums, 0, nums.length - 1);
        reverse(nums, 0, k - 1);
        reverse(nums, k, nums.length - 1);
    }

    public void reverse(int[] nums, int start, int end) {
        while (start < end) {
            int temp = nums[start];
            nums[start] = nums[end];
            nums[end] = temp;
            start += 1;
            end -= 1;
        }
    }
}
```



### 十六、除自身以外数组的乘积

思路：

1. 先计算前缀积，就是除自身以外，前面的元素的乘积。
2. 再计算后缀积，除自身以外，后面的元素的乘积。
3. 将他们对位相乘。

第一位的前缀积为1，最后一位的后缀积为1。

例：[1,2,3,4]

1. 前缀积：[1,1,2,6]。
2. 后缀积：[24,12,4,1]
3. 对位相乘：[24,12,8,6]

```java
class Solution {
    public int[] productExceptSelf(int[] nums) {
        int[] result = new int[nums.length];

        int current = 1;
        //初始化
        for(int i = 0; i < nums.length; i++){
            result[i] = 1;
        }

        //前缀积
        for(int i = 1; i < nums.length; i++){
            current *= nums[i - 1];
            result[i] *= current;
        }

        current = 1;

        //后缀积
        for(int i = nums.length - 2; i >= 0; i--){
            current *= nums[i + 1];
            result[i] *= current;
        }
        
        return result;
    }
}
```



### 十七、缺失的第一个正数

```java
class Solution {
    public int firstMissingPositive(int[] nums) {
        int length = nums.length;

        // 将负数和大于数组长度的数变为 n + 1
        for(int i = 0; i < length; i++){
            if(nums[i] > length || nums[i] <= 0){
                nums[i] = length + 1;
            }
        }

        // 将出现的正整数标记
        for(int i = 0; i < length; i++){
            int num = Math.abs(nums[i]);
            if(num > length) continue;
            num--;
            if(nums[num] > 0){
                nums[num] = -nums[num];
            }
        }

        // 找出第一个正数
        for(int i = 0; i < length; i++){
            if(nums[i] > 0){
                return i + 1;
            }
        }

        return length + 1;
    }
}
```

**在标记出现的元素的时候，不会把出现的数组覆盖掉吗？**

在标记出现的元素时，我们使用负数来标记某个索引对应的元素是否出现过，这种方法不会覆盖掉数组的原始值，因为我们只改变了它们的符号，而没有改变它们的绝对值。



## 六、矩阵

### 十八、矩阵置零

解1：空间复杂度：O(m + n)

```java
class Solution {
    public void setZeroes(int[][] matrix) {
        //记录要设为0的行和列
        int[] row = new int[matrix.length];
        int[] column = new int[matrix[0].length];

        for(int i = 0; i < matrix.length; i++){
            for(int j = 0; j < matrix[0].length; j++){
                if(matrix[i][j] == 0){
                    row[i] = 1;
                    column[j] = 1;
                }
            }
        }

        //设置一行为0
        for(int i = 0; i < row.length; i++){
            if(row[i] == 1){
                setRowZero(matrix, i);
            }
        }

        //设置一列为0
        for(int i = 0; i < column.length; i++){
            if(column[i] == 1){
                setColumnZero(matrix, i);
            }
        }
    }

    public void setRowZero(int[][] matrix, int row){
        for(int i = 0; i < matrix[0].length; i++){
            matrix[row][i] = 0;
        }
    }

    public void setColumnZero(int[][] matrix, int column){
        for(int i = 0; i < matrix.length; i++){
            matrix[i][column] = 0;
        }
    }
}
```



优化：要在 O(1) 空间复杂度内完成任务，可以利用矩阵的第一行和第一列来存储要置零的行和列的信息。在开始处理矩阵之前，先扫描第一行和第一列，确定是否需要将它们置零。在处理完其余元素后，最后根据标记的结果置零第一行和第一列。

题解：

```java
public class Solution {
    public void setZeroes(int[][] matrix) {
        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {
            return;
        }
        
        int m = matrix.length;
        int n = matrix[0].length;
        boolean rowZero = false;
        boolean colZero = false;
        
        // Step 1: Determine if the first row or first column needs to be zero
        for (int i = 0; i < m; i++) {
            if (matrix[i][0] == 0) {
                colZero = true;
                break;
            }
        }
        
        for (int j = 0; j < n; j++) {
            if (matrix[0][j] == 0) {
                rowZero = true;
                break;
            }
        }
        
        // Step 2: Use first row and first column as markers
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                if (matrix[i][j] == 0) {
                    matrix[i][0] = 0;
                    matrix[0][j] = 0;
                }
            }
        }
        
        // Step 3: Set matrix elements to zero based on markers
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                if (matrix[i][0] == 0 || matrix[0][j] == 0) {
                    matrix[i][j] = 0;
                }
            }
        }
        
        // Step 4: Zero out the first row and column if needed
        if (rowZero) {
            for (int j = 0; j < n; j++) {
                matrix[0][j] = 0;
            }
        }
        
        if (colZero) {
            for (int i = 0; i < m; i++) {
                matrix[i][0] = 0;
            }
        }
    }
}
```



### 十九、螺旋矩阵

```java
class Solution {
    public List<Integer> spiralOrder(int[][] matrix) {
        int direction = 0;
        int num = matrix.length * matrix[0].length;

        List<Integer> result = new ArrayList<>();
        int row = 0;
        int column = 0;

        while(result.size() != num){    //当数组中所有元素都收集到时就结束
            while(row >= 0 && row < matrix.length && column >= 0 && column < matrix[0].length && matrix[row][column] != 101){
                switch(direction){
                    case 0:
                        //向右
                        result.add(matrix[row][column]);
                        matrix[row][column] = 101;
                        column++;
                        break;
                    case 1:
                        //向下
                        result.add(matrix[row][column]);
                        matrix[row][column] = 101;
                        row++;
                        break;
                    case 2:
                        //向左
                        result.add(matrix[row][column]);
                        matrix[row][column] = 101;
                        column--;
                        break;
                    case 3:
                        //向上
                        result.add(matrix[row][column]);
                        matrix[row][column] = 101;
                        row--;
                        break;
                }
            }
            //改变方向
            switch(direction){
                case 0:
                    column--;
                    row++;
                    direction = 1;
                    break;
                case 1:
                    row--;
                    column--;
                    direction = 2;
                    break;
                case 2:
                    column++;
                    row--;
                    direction = 3;
                    break;
                case 3:
                    row++;
                    column++;
                    direction = 0;
                    break;
            }
        }

        return result;
    }
}
```



### 二十、旋转图像

```java
class Solution {
    public void rotate(int[][] matrix) {
        int n = matrix.length;

        // 1. 行列转换，第一行变为第一列
        for (int i = 0; i < n; i++) {
            for (int j = i; j < n; j++) {
                int temp = matrix[i][j];
                matrix[i][j] = matrix[j][i];
                matrix[j][i] = temp;
            }
        }

        // 2. 将每一行的元素前后倒置
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n / 2; j++) {
                int temp = matrix[i][j];
                matrix[i][j] = matrix[i][n - 1 - j];
                matrix[i][n - 1 - j] = temp;
            }
        }
    }
}
```



### 二十一、搜索二维矩阵 II

使用递归

```java
class Solution {
    public boolean searchMatrix(int[][] matrix, int target) {
        return traversal(matrix, target, 0, 0);
    }

    public boolean traversal(int[][] matrix, int target, int row, int column){
        if(row < 0 || row >= matrix.length || column < 0 || column >= matrix[0].length || matrix[row][column] == Integer.MAX_VALUE){
            return false;
        }

        boolean tag1 = false;
        boolean tag2 = false;

        if(matrix[row][column] == target){
            return true;
        }else if(matrix[row][column] < target){
            //搜索过的做个标记，防止栈溢出
            matrix[row][column] = Integer.MAX_VALUE;
            //右
            tag1 = traversal(matrix, target, row, column + 1);
            //下
            tag2 = traversal(matrix, target, row + 1, column);
        }else{
            matrix[row][column] = Integer.MAX_VALUE;
            //左
            tag1 = traversal(matrix, target, row, column - 1);
            //上
            tag2 = traversal(matrix, target, row - 1, column);
        }

        return tag1 || tag2;
    }
}
```

题解：

利用矩阵的有序性，可以从矩阵的右上角开始进行搜索：

1. 如果当前元素等于目标值，则返回 true。
2. 如果当前元素大于目标值，则向左移动一列。
3. 如果当前元素小于目标值，则向下移动一行。

```java
public boolean searchMatrix(int[][] matrix, int target) {
  if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {
    return false;
  }

  int rows = matrix.length;
  int cols = matrix[0].length;

  // 从右上角开始
  int row = 0;
  int col = cols - 1;

  while (row < rows && col >= 0) {
    if (matrix[row][col] == target) {
      return true;
    } else if (matrix[row][col] > target) {
      col--;
    } else {
      row++;
    }
  }

  return false;
}
```



## 七、链表

### 二十二、相交链表

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        ListNode node1 = headA;
        ListNode node2 = headB;
        int length1 = 0;
        int length2 = 0;
        //计算相差的长度
        while(node1 != null){
            length1++;
            node1 = node1.next;
        }
        while(node2 != null){
            length2++;
            node2 = node2.next;
        }
        //去掉相差的长度
        int diff = Math.abs(length1 - length2);
        while(length1 != length2){
            if(length1 > length2){
                headA = headA.next;
                length1--;
            }else{
                headB = headB.next;
                length2--;
            }
        }
        //找第一个相交点
        while(headA != null && headB != null){
            if(headA == headB){
                return headA;
            }else{
                headA = headA.next;
                headB = headB.next;
            }
        }

        return null;
    }
}
```



题解：

```java
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        if (headA == null || headB == null) {
            return null;
        }

        ListNode a = headA;
        ListNode b = headB;

        // 在这里通过两个指针遍历两个链表。如果指针a到达链表末尾，则将其指向链表b的头部；反之亦然
        // 这样当两个指针相遇时，要么是在交点，要么是两个都到达了末尾(null)
        // 为了让他们走相同的长度
        while (a != b) {
            a = (a == null) ? headB : a.next;
            b = (b == null) ? headA : b.next;
        }

        // 返回相交的节点或者null（如果没有相交节点）
        return a;
    }
}

```



### 二十三、反转链表

```java
class Solution {
    public ListNode reverseList(ListNode head) {
        if(head == null || head.next == null){
            return head;
        }

        ListNode r = null;
        ListNode p = head;
        ListNode q = head.next;

        while(true){
            p.next = r;
            r = p;
            p = q;
            if(q == null){
                return r;
            }else{
                q = q.next;
            }
        }
    }
}
```



题解：

```java
public class Solution {
    public ListNode reverseList(ListNode head) {
        ListNode prev = null;
        ListNode curr = head;

        while (curr != null) {
            ListNode next = curr.next; // 暂存下一个节点
            curr.next = prev; // 反转当前节点的指针
            prev = curr; // 前移指针
            curr = next; // 前移指针
        }

        return prev;
    }
}
```



### 二十四、回文链表

```java
class Solution {
    public boolean isPalindrome(ListNode head) {
        ListNode fast = head.next;
        ListNode slow = head;
        //慢指针定位到中间
        while(fast != null && fast.next != null){
            fast = fast.next.next;
            slow = slow.next;
        }
        //反转后面链表
        ListNode last;
        if(fast == null){
            last = reverseList(slow.next, slow);
        }else{
            last = reverseList(slow.next, null);
        }
        //比较是否为回文链表
        while(last != null && head != null && head != last){
            if(head.val == last.val){
                last = last.next;
                head = head.next;
            }else{
                return false;
            }
        }

        return true;
    }

    public ListNode reverseList(ListNode head, ListNode pre) {
        ListNode prev = pre;
        ListNode curr = head;

        while (curr != null) {
            ListNode next = curr.next; // 暂存下一个节点
            curr.next = prev; // 反转当前节点的指针
            prev = curr; // 前移指针
            curr = next; // 前移指针
        }

        return prev;
    }
}
```



### 二十五、环形链表

快慢指针

```java
public class Solution {
    public boolean hasCycle(ListNode head) {
        if(head == null){
            return false;
        }

        ListNode fast = head.next;
        ListNode slow = head;

        while(fast != null && fast.next != null && slow != null){
            if(fast == slow){
                // 相遇就返回 true
                return true;
            }
            fast = fast.next.next;
            slow = slow.next;
        }

        // 有一个到达尾部就返回false
        return false;
    }
}
```



### 二十六、环形链表 Ⅱ

1. 假设从链表头部到环起点的距离为 `L`，从环起点到相遇点的距离为 `X`，环的长度为 `C`。
2. 当 `slow` 和 `fast` 相遇时，`slow` 走了 `L + X`，`fast` 走了 `2(L + X)`，且 `fast` 多走的部分必然是环的整数倍，即 `L + X + nC`（其中 n 是环的完整圈数）。
3. 根据上述关系，`2(L + X) = L + X + nC`，化简得 `L + X = nC`。
4. 因此，从相遇点开始，`slow` 再走 `L` 步正好到达环的起点。同时从头开始的 `slow` 也走 `L` 步到达环的起点，所以它们会在环的起点相遇。

```java
public class Solution {
    public ListNode detectCycle(ListNode head) {
        if (head == null || head.next == null) {
            return null;
        }

        ListNode slow = head;
        ListNode fast = head;

        // 找到相遇点
        while (fast != null && fast.next != null) {
            slow = slow.next;
            fast = fast.next.next;
            if (slow == fast) {
                break;
            }
        }

        // 不存在环
        if (fast == null || fast.next == null) {
            return null;
        }

        // 走到环的起始点
        slow = head;
        while (slow != fast) {
            slow = slow.next;
            fast = fast.next;
        }

        return slow;
    }
}
```



### 二十七、合并两个有序链表

```java
class Solution {
    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {
        if(list1 == null){
            return list2;
        }else if(list2 == null){
            return list1;
        }

        // 合并后的头节点
        ListNode head;
        // 记录新链表的当前节点
        ListNode curr;

        //初始化
        if(list1.val >= list2.val){
            head = list2;
            curr = list2;
            list2 = list2.next;
        }else{
            head = list1;
            curr = list1;
            list1 = list1.next;
        }

        // 如果 list1 的值大于等于 list2 的值，就选 list1 的节点拼接
        // 反之选 list2 的节点
        while(list1 != null && list2 != null){
            if(list1.val >= list2.val){
                curr.next = list2;
                curr = curr.next;
                list2 = list2.next;
            }else{
                curr.next = list1;
                curr = curr.next;
                list1 = list1.next;
            }
        }

        //如果有一个节点到尾了，就把另一个链表的尾部拼到新链表后面
        if(list1 == null){
            curr.next = list2;
        }else if(list2 == null){
            curr.next = list1;
        }

        return head;
    }
}
```



### 二十八、两数相加

```java
class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        if(l1 == null || l2 == null){
            return l1 == null ? l2 : l1;
        }

        ListNode head1 = l1;
        ListNode head2 = l2;
        // 是否需要进位
        boolean carried = false;

        // 先拼成一样长的
        while(l1.next != null || l2.next != null){
            if(l1.next != null && l2.next == null){
                l2.next = new ListNode(0);
            }else if(l1.next == null && l2.next != null){
                l1.next = new ListNode(0);
            }

            l1 = l1.next;
            l2 = l2.next;
        }

        ListNode pre = null;
        l1 = head1;
        l2 = head2;

        // 逐位相加
        while(l1 != null && l2 != null){
            int res = l1.val + l2.val;
            //如果需要进位，结果加一
            if(carried){
                res++;
            }
            //检查是否需要进位
            carried = res > 9 ? true : false;

            l1.val = (res % 10);

            pre = l1;
            l1 = l1.next;
            l2 = l2.next;
        }

        //检查是否需要添多一位
        if(carried){
            pre.next = new ListNode(1);
        }

        return head1;
    }
}
```



### 二十九、删除链表的倒数第 N 个数

1. 创建两个指针，`first` 和 `second`，都指向链表的头部。
2. 让 `first` 先移动 N 步。
3. 然后同时移动 `first` 和 `second`，直到 `first` 到达链表的末尾。
4. 此时，`second` 正好指向倒数第 N 个节点的前一个节点。
5. 修改 `second` 的 `next` 指针，跳过倒数第 N 个节点，从而实现删除。

```java
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        // 创建一个哑结点，方便处理边界情况
        ListNode dummy = new ListNode(0);
        dummy.next = head;
        ListNode first = dummy;
        ListNode second = dummy;
        
        // 让 first 先前进 n+1 步
        for (int i = 0; i <= n; i++) {
            first = first.next;
        }
        
        // 让 first 和 second 同时前进，直到 first 到达链表末尾
        while (first != null) {
            first = first.next;
            second = second.next;
        }
        
        // 此时 second 指向倒数第 N 个节点的前一个节点，删除倒数第 N 个节点
        second.next = second.next.next;
        
        // 返回头结点
        return dummy.next;
    }
}
```



### 三十、两两交换链表中的节点

```java
class Solution {
    public ListNode swapPairs(ListNode head) {
        if(head == null || head.next == null){
            return head;
        }

        ListNode dummy = new ListNode(0);
        dummy.next = head;
        ListNode cur = head;
        ListNode post = head.next;
        ListNode pre = dummy;

        while(cur != null && post != null){
            pre.next = post;
            cur.next = post.next;
            post.next = cur;

            pre = cur;
            cur = cur.next;
            if(cur == null){
                break;
            }
            post = cur.next;
        }

        return dummy.next;
    }
}
```



### 三十一、K 个一组翻转链表

```java
class Solution {
    public ListNode reverseKGroup(ListNode head, int k) {
        if(k == 1){
            return head;
        }

        ListNode dummy = new ListNode(0, head);
        ListNode pre = dummy;
        ListNode cur = head;

        while(true){
            // 先遍历到k个节点，有 k 个节点再交换
            for(int i = 0; i < k; i++){
                if(cur == null){
                    return dummy.next;
                }else{
                    cur = cur.next;
                }
            }
            ListNode post = cur;
            cur = pre.next;
            ListNode res = swap(cur, k);
            pre.next = res;
            cur.next = post;

            pre = cur;
            cur = pre.next;
        }
    }

    // 倒置 k 个节点的方法
    // node：第一个节点
    // 返回：倒置后的第一个节点
    public ListNode swap(ListNode node, int k){
        ListNode dummy = new ListNode(0);
        dummy.next = node;
        ListNode pre = dummy;
        ListNode cur = node;
        ListNode post = cur.next;

        for(int i = 0; i < k; i++){
            cur.next = pre;
            pre = cur;
            cur = post;
            if(cur == null){
                break;
            }
            post = cur.next;
        }

        return pre;
    }
}
```



### 三十二、随机链表的复制

```java
class Node {
    int val;
    Node next;
    Node random;

    public Node(int val) {
        this.val = val;
        this.next = null;
        this.random = null;
    }
}

public class Solution {
    public Node copyRandomList(Node head) {
        if (head == null) {
            return null;
        }

        // 在原链表的每个节点后面创建一个新节点。新节点的值与原节点相同。
        Node current = head;
        while (current != null) {
            Node newNode = new Node(current.val);
            newNode.next = current.next;
            current.next = newNode;
            current = newNode.next;
        }

        // 设置新节点的随机指针。新节点的随机指针指向原节点随机指针所指向节点的下一个节点。
        current = head;
        while (current != null) {
            if (current.random != null) {
                current.next.random = current.random.next;
            }
            current = current.next.next;
        }

        // 将新节点从原链表中分离出来，从而得到一个独立的深拷贝链表。
        current = head;
        Node newHead = head.next;
        Node copyCurrent = newHead;
        while (current != null) {
            current.next = current.next.next;
            if (copyCurrent.next != null) {
                copyCurrent.next = copyCurrent.next.next;
            }
            current = current.next;
            copyCurrent = copyCurrent.next;
        }

        return newHead;
    }
}
```



更好理解版本：

1. **初始化和空检查**：如果输入的链表为空，直接返回 null。
2. **第一次遍历**：遍历原链表，为每个原节点创建一个新节点，并将它们存储在哈希表中。键是原节点，值是新节点。
3. **第二次遍历**：再次遍历原链表，设置新节点的 `next` 和 `random` 指针。通过查找哈希表中对应的节点来设置。
4. **返回结果**：返回哈希表中原链表头节点对应的新节点。

```java
 public Node copyRandomList(Node head) {
   if(head == null){
     return null;
   }
   Node cur = head;
   HashMap<Node,Node> map = new HashMap<>();
   while(cur!=null){
     map.put(cur,new Node(cur.val));
     cur = cur.next;
   }
   cur=head;
   while(cur!=null){
     map.get(cur).next=map.get(cur.next);
     map.get(cur).random=map.get(cur.random);
     cur=cur.next;
   }
   return map.get(head);
 }
```



### 三十三、排序链表（困难）

```java
class ListNode {
    int val;
    ListNode next;
    ListNode(int x) { val = x; }
}

public class Solution {
    public ListNode sortList(ListNode head) {
        // 如果链表为空或只有一个节点，直接返回头节点
        if (head == null || head.next == null) {
            return head;
        }

        // 使用快慢指针找到链表的中间节点
        ListNode slow = head, fast = head, prev = null;
        while (fast != null && fast.next != null) {
            prev = slow;
            slow = slow.next;
            fast = fast.next.next;
        }
        // 将链表断开成两部分
        prev.next = null;

        // 递归排序两个子链表
        ListNode l1 = sortList(head);
        ListNode l2 = sortList(slow);

        // 合并两个有序链表
        return merge(l1, l2);
    }

    // 合并两个有序链表
    private ListNode merge(ListNode l1, ListNode l2) {
        ListNode dummy = new ListNode(0);
        ListNode current = dummy;

        // 比较两个链表的头节点，选择较小的节点链接到结果链表中
        while (l1 != null && l2 != null) {
            if (l1.val < l2.val) {
                current.next = l1;
                l1 = l1.next;
            } else {
                current.next = l2;
                l2 = l2.next;
            }
            current = current.next;
        }

        // 链接剩余的节点
        if (l1 != null) {
            current.next = l1;
        }
        if (l2 != null) {
            current.next = l2;
        }

        return dummy.next;
    }
}
```



### 三十四、合并 K 个升序链表

```java
class Solution {
    public ListNode mergeKLists(ListNode[] lists) {
        if(lists.length == 0){
            return null;
        }else if(lists.length == 1){
            return lists[0];
        }

        return mergeList(lists, 0, lists.length);
    }

    // 递归合并
    public ListNode mergeList(ListNode[] lists, int start, int end){
        if(end - start == 0){
            return null;
        }else if(end - start == 1){
            return lists[start];
        }else if(end - start == 2){
            return merge(lists[start], lists[start + 1]);
        }

        int mid = (end + start) / 2;
        ListNode l1 = mergeList(lists, start, mid);
        ListNode l2 = mergeList(lists, mid, end);

        return merge(l1, l2);
    }

    // 合并两个节点
    public ListNode merge(ListNode l1, ListNode l2){
        if(l1 == null && l2 == null){
            return null;
        }

        ListNode dummy = new ListNode(0);
        ListNode cur = dummy;

        while(l1 != null && l2 != null){
            if(l1.val <= l2.val){
                cur.next = l1;
                cur = l1;
                l1 = l1.next;
            }else{
                cur.next = l2;
                cur = l2;
                l2 = l2.next;
            }
        }

        if(l1 == null && l2 != null){
            cur.next = l2;
        }
        if(l1 != null && l2 == null){
            cur.next = l1;
        }

        return dummy.next;
    }
}
```



### 三十五、LRU 缓存（困难）

双向链表 + Hash 表

```java
class LRUCache {

    class DLinkedNode {
        int key;
        int value;
        DLinkedNode prev;
        DLinkedNode next;
        public DLinkedNode() {}
        public DLinkedNode(int key, int value) { this.key = key; this.value = value; }
    }

    private Map<Integer, DLinkedNode> cache = new HashMap<>();
    private int size;	// 节点数量
    private int capacity;	// 容量
    private DLinkedNode head, tail;	// 头节点，尾节点

    public LRUCache(int capacity) {
        this.size = 0;
        this.capacity = capacity;
        // 使用伪头部和伪尾部节点
        head = new DLinkedNode();
        tail = new DLinkedNode();
        head.next = tail;
        tail.prev = head;
    }

    public int get(int key) {
        DLinkedNode node = cache.get(key);
        if (node == null) {
            return -1;
        }
        // 如果key存在，先通过哈希表定位，再移到头部
        moveToHead(node);
        return node.value;
    }

    public void put(int key, int value) {
        DLinkedNode node = cache.get(key);
        if (node == null) {
            // 如果key不存在，创建一个新节点
            DLinkedNode newNode = new DLinkedNode(key, value);
            // 添加进哈希表
            cache.put(key, newNode);
            // 添加至双向链表的头部
            addToHead(newNode);
            ++size;
            if (size > capacity) {
                // 如果超出容量，删除双向链表的尾部节点
                DLinkedNode tail = removeTail();
                // 删除哈希表中对应的项
                cache.remove(tail.key);
                --size;
            }
        } else {
            // 如果key存在，先通过哈希表定位，再修改value，并移到头部
            node.value = value;
            moveToHead(node);
        }
    }

    private void addToHead(DLinkedNode node) {
        node.prev = head;
        node.next = head.next;
        head.next.prev = node;
        head.next = node;
    }

    private void removeNode(DLinkedNode node) {
        node.prev.next = node.next;
        node.next.prev = node.prev;
    }

    private void moveToHead(DLinkedNode node) {
        removeNode(node);
        addToHead(node);
    }

    private DLinkedNode removeTail() {
        DLinkedNode res = tail.prev;
        removeNode(res);
        return res;
    }
}
```



## 八、二叉树

### 三十六、中序遍历

```java
class Solution {
    List<Integer> result = new ArrayList<>();

    public List<Integer> inorderTraversal(TreeNode root) {
        traversal(root);

        return result;
    }
	// 递归
    public void traversal(TreeNode root){
        if(root == null){
            return;
        }
        
        traversal(root.left);
        result.add(root.val);
        traversal(root.right);
    }
}
```



### 三十七、二叉树的最大深度

```java
class Solution {
    public int maxDepth(TreeNode root) {
        return traversal(root, 0);
    }

    // 中序遍历 + 递归
    public int traversal(TreeNode root, int depth){
        if(root == null){
            return depth;
        }

        depth++;
        int left = 0, right = 0;
        if(root.left != null){
            left = traversal(root.left, depth);
        }
        if(root.right != null){
            right = traversal(root.right, depth);
        }

        return Math.max(left, Math.max(right, depth));
    }
}
```



### 三十八、翻转二叉树

```java
class Solution {
    public TreeNode invertTree(TreeNode root) {
        if(root == null){
            return null;
        }

        TreeNode right = invertTree(root.left);
        TreeNode left = invertTree(root.right);

        root.right = right;
        root.left = left;

        return root;
    }
}
```



### 三十九、对称二叉树

```java
class Solution {
    public boolean isSymmetric(TreeNode root) {
        return traversal(root.left, root.right);
    }

    public boolean traversal(TreeNode p1, TreeNode p2){
        if(p1 == null && p2 == null){
            return true;
        }
        if(p1 == null || p2 == null){
            return false;
        }

        boolean tag1 = (p1.val == p2.val);
        boolean tag2 = traversal(p1.left, p2.right);
        boolean tag3 = traversal(p1.right, p2.left);

        return tag1 && tag2 && tag3;
    }
}
```



### 四十、二叉树的直径

```java
class Solution {
    int result = 0;
    public int diameterOfBinaryTree(TreeNode root) {
        traversal(root, 0);
        return result;
    }

    public int traversal(TreeNode root, int depth){
        if(root == null){
            return 0;
        }

        int left = traversal(root.left, depth);
        int right = traversal(root.right, depth);
        // 每一个节点都要计算最长路径
        // 节点的最长路径 = 左最深长度 + 右最深长度
        result = Math.max(left + right, result);

        return Math.max(left, Math.max(right, depth)) + 1;
    }
}
```



### 四十一、二叉树的层序遍历

```java
class Solution {
    int cur = 1;
    int next = 0;
    Deque<TreeNode> deque = new LinkedList<>();

    public List<List<Integer>> levelOrder(TreeNode root) {
        List<List<Integer>> res = new ArrayList<>();
        if(root == null){
            return res;
        }

        deque.addLast(root);

        while(deque.size() != 0){
            List<Integer> list = new ArrayList<>();

            while(cur != 0){
                TreeNode node = deque.pollFirst();
                list.add(node.val);
                if(node.left != null){
                    deque.addLast(node.left);
                    next++;
                }
                if(node.right != null){
                    deque.addLast(node.right);
                    next++;
                }
                cur--;
            }

            res.add(list);
            cur = next;
            next = 0;
        }

        return res;
    }
}
```



### 四十二、将有序数组转换为二叉搜索树

```java
class Solution {
    public TreeNode sortedArrayToBST(int[] nums) {
        return traversal(nums, 0, nums.length);
    }

    public TreeNode traversal(int[] nums, int start, int end){
        if(end - start <= 0){
            return null;
        }

        int mid = (start + end) / 2;
        TreeNode left = traversal(nums, start, mid);
        TreeNode right = traversal(nums, mid + 1, end);

        TreeNode root = new TreeNode(nums[mid]);
        root.left = left;
        root.right = right;

        return root;
    }
}
```



### 四十三、验证二叉搜索树

```java
class Solution {
    TreeNode pre;
    public boolean isValidBST(TreeNode root) {
        if(root == null){
            return true;
        }
        //左
        boolean left = isValidBST(root.left);
        if(!left){
            return false;
        }
        //中
        if(pre != null && pre.val >= root.val){
            return false;
        }
        pre = root;
        // 右
        boolean right = isValidBST(root.right);
        return right;
    }
}
```



### 四十四、二叉搜索树中第K 小的元素

```java
class Solution {
    int n = 0;

    public int kthSmallest(TreeNode root, int k) {
        if(root == null){
            return -1;
        }
        
        //左
        int left = kthSmallest(root.left, k);
        if(left != -1){
            return left;
        }

        //中
        n++;
        if(k == n){
            return root.val;
        }

        //右
        int right = kthSmallest(root.right, k);
        return right;
    }
}
```



参考题解：

```java
class Solution {
    public int kthSmallest(TreeNode root, int k) {
        int leftNodes = countNodes(root.left);
        if(leftNodes < k - 1){  //答案存在右子树中
            return kthSmallest(root.right,k - leftNodes - 1);
        }else if(leftNodes == k - 1){
            return root.val;
        }else{
            return kthSmallest(root.left,k);
        }
    }
    //左神递归套路分析左右子树返回信息只需要节点数，因此无需额外定义数据结构
    public int countNodes(TreeNode root){
       //base case返回0
        if(root == null) return 0;
       //递归处理左右子树并接收返回值
        int leftNodes = countNodes(root.left);
        int rightNodes = countNodes(root.right);
       //判断分析本层递归返回值的具体值
        return leftNodes + rightNodes + 1;
    }
}
```



### 四十五、二叉树的右视图

层序遍历中每一层的最后一个数的结果集

```java
class Solution {
    Deque<TreeNode> deque = new LinkedList<>();
    int num = 1;    // 当前层节点数
    int next = 0;   // 下一层节点数

    public List<Integer> rightSideView(TreeNode root) {
        List<Integer> result = new ArrayList<>();

        if(root == null){
            return result;
        }

        deque.add(root);

        while(deque.size() != 0){
            // 遍历每一层，并把下一层元素加入到队列中
            while(num != 0){
                TreeNode node = deque.pollFirst();

                if(node.left != null){
                    deque.addLast(node.left);
                    next++;
                }
                if(node.right != null){
                    deque.addLast(node.right);
                    next++;
                }
                // 把每一层的最后一个数加入到结果集
                if(num == 1){
                    result.add(node.val);
                }

                num--;
            }
            num = next;
            next = 0;
        }

        return result;
    }
}
```



### 四十六、二叉树展开为链表

```java
class Solution {
    TreeNode pre;

    // 反前序遍历
    public void flatten(TreeNode root) {
        if (root == null){
            return;
        }
        // 右
        flatten(root.right);
        // 左
        flatten(root.left);
        // 中
        root.right = pre;
        root.left = null;
        pre = root;
    }
}
```



### 四十七、从前序与中序遍历序列构造二叉树

```java
class Solution {
    public TreeNode buildTree(int[] preorder, int[] inorder) {
        return traversal(preorder, 0, preorder.length,
                        inorder, 0, preorder.length);
    }

    public TreeNode traversal(int[] preorder, int start1, int end1,
                            int[] inorder, int start2, int end2){
        if(end1 - start1 <= 0){
            return null;
        }

        int rootVal = preorder[start1];
        TreeNode root = new TreeNode(rootVal);

        for(int i = start2; i < end2; i++){
            // 遍历中序数组找到根节点
            if(inorder[i] == rootVal){
                // 左节点，(i - start2) 是左子树有多少个节点
                root.left = traversal(preorder, start1 + 1, start1 + 1 + (i - start2),
                                        inorder, start2, i);
                // 右节点
                root.right = traversal(preorder, start1 + 1 + (i - start2), end1,
                                        inorder, i + 1, end2);
                break;
            }
        }

        return root;
    }              
}
```



### 四十八、路径总和Ⅲ

前缀和题解：

```java
class Solution {
    public int pathSum(TreeNode root, int targetSum) {
        Map<Long, Integer> prefix = new HashMap<Long, Integer>();
        prefix.put(0L, 1);
        return dfs(root, prefix, 0, targetSum);
    }

    public int dfs(TreeNode root, Map<Long, Integer> prefix, long curr, int targetSum) {
        if (root == null) {
            return 0;
        }

        int ret = 0;		// 返回结果数
        curr += root.val;	// 计算当前总和
		
        // 计算当前前缀和集合内满足的个数
        ret = prefix.getOrDefault(curr - targetSum, 0);
        // 把当前总和加入到前缀和集合中
        prefix.put(curr, prefix.getOrDefault(curr, 0) + 1);
      	// 计算子节点满足的个数
        ret += dfs(root.left, prefix, curr, targetSum);
        ret += dfs(root.right, prefix, curr, targetSum);
      	// 恢复，因为需要返回到父节点
        prefix.put(curr, prefix.getOrDefault(curr, 0) - 1);

        return ret;
    }
}
```



### 四十九、二叉树的最近公共祖先

```java
class Solution {
    TreeNode result;
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        traversal(root, p.val, q.val);
        return result;
    }

    public int traversal(TreeNode root, int p, int q){
        if(root == null){
            return 0;
        }

        int num = 0;
        // 左
        num += traversal(root.left, p, q);
        // 右
        num += traversal(root.right, p, q);

        // 中
        // 如果左右节点各有一个，那么当前节点为祖先
        if(num == 2){
            result = root;
            return 0;
        }

        if(root.val == p || root.val == q){
            // 如果有一个满足，且当前节点也满足，则当前节点也是祖先
            if(num == 1){
                result = root;
            }
            return 1;
        }

        return num;
    }
}
```





### 五十、二叉树中的最大路径和

```java
class Solution {
    int result = Integer.MIN_VALUE;
    public int maxPathSum(TreeNode root) {
        traversal(root);

        return result;
    }

    public int traversal(TreeNode root){
        if(root == null){
            return 0;
        }

        int num = root.val;
        // 记录左右节点是否被拼接
        boolean tag1 = false, tag2 = false;
        int left = traversal(root.left);
        int right = traversal(root.right);

        if(left > 0){
            num += left;
            tag1 = true;
        }
        if(right > 0){
            num += right;
            tag2 = true;
        }
        // 记录最大值时，可以加上两子节点
        result = Math.max(num, result);

        if(tag1 && tag2){
            // 如果左右节点都被拼接，在返回时，只能选择一边进行返回，所有减去较小的
            num -= left < right ? left : right;
        }

        return num;
    }
}
```



## 九、图论

### 五十一、岛屿数量

```java
class Solution {
    public int numIslands(char[][] grid) {
        int row = grid.length;
        int column = grid[0].length;

        int result = 0;
        for(int i = 0; i < row; i++){
            for(int j = 0; j < column; j++){
                if(grid[i][j] == '1'){
                    result++;
                    islands(grid, i, j);
                }
            }
        }
        
        return result;
    }

    public void islands(char[][] grid, int row, int column){
        grid[row][column] = '2';

        // 上
        if(row > 0 && grid[row-1][column] == '1'){
            islands(grid, row - 1, column);
        }

        // 下
        if(row < grid.length - 1 && grid[row+1][column] == '1'){
            islands(grid, row + 1, column);
        }

        // 左
        if(column > 0 && grid[row][column-1] == '1'){
            islands(grid, row, column - 1);
        }

        // 右
        if(column < grid[0].length - 1 && grid[row][column+1] == '1'){
            islands(grid, row, column + 1);
        }
    }
}
```



深搜改进

```java
class Solution {
    public int numIslands(char[][] grid) {
        int row = grid.length;
        int column = grid[0].length;

        int result = 0;
        for(int i = 0; i < row; i++){
            for(int j = 0; j < column; j++){
                if(grid[i][j] == '1'){
                    result++;
                    islands(grid, i, j);
                }
            }
        }
        
        return result;
    }

    public void islands(char[][] grid, int row, int column){
        if(row < 0 || row >= grid.length || column < 0 || column >= grid[0].length || grid[row][column] == '0'){
            return;
        }

        grid[row][column] = '0';

        islands(grid, row - 1, column);
        islands(grid, row + 1, column);
        islands(grid, row, column - 1);
        islands(grid, row, column + 1);
    }
}
```



### 五十二、腐烂的橘子

```java
class Solution {
    // 统计最长感染时间，用 minutes + 2 表示
    int result = 2;
    public int orangesRotting(int[][] grid) {
        int row = grid.length;
        int column = grid[0].length;

        for(int i = 0; i < row; i++){
            for(int j = 0; j < column; j++){
                if(grid[i][j] == 2){
                    // 遇到已经腐烂的橘子
                    dfs(grid, i + 1, j, 3);
                    dfs(grid, i - 1, j, 3);
                    dfs(grid, i, j + 1, 3);
                    dfs(grid, i, j - 1, 3);
                }
            }
        }

        for(int i = 0; i < row; i++){
            for(int j = 0; j < column; j++){
                if(grid[i][j] == 1){
                    // 遇到未感染的，说明感染不了
                    return -1;
                }
                // 统计感染时间
                result = Math.max(result, grid[i][j]);
            }
        }

        return result - 2;
    }

    public void dfs(int[][] grid, int row, int column, int minutes){
        // 遇到空格子 或 腐烂橘子就返回
        if(row < 0 || row >= grid.length || column < 0 || column >= grid[0].length || 
                                    grid[row][column] == 0 || grid[row][column] == 2){
            return;
        }

        // 遇到已经被感染过 且 时间大于等于感染时间的 也返回
        if(grid[row][column] > 2 && minutes >= grid[row][column]){
            return;
        }

        if(grid[row][column] > 2 && minutes < grid[row][column]){
            // 遇到已经被感染过 且 时间小于感染时间的 重新设置时间
            // 因为它被更近的橘子感染了
            grid[row][column] = minutes;
        }else if(grid[row][column] == 1){
            // 未感染的橘子设置时间
            grid[row][column] = minutes;
        }
        
        dfs(grid, row + 1, column, minutes + 1);
        dfs(grid, row - 1, column, minutes + 1);
        dfs(grid, row, column + 1, minutes + 1);
        dfs(grid, row, column - 1, minutes + 1);
    }
}
```



### 五十三、课程表（难）

DFS 方法通过检测图中是否存在环来判断课程能否完成：

1. **构建图：** 使用邻接表来表示课程之间的依赖关系。
2. DFS 遍历：
   - 使用一个状态数组 `state`，记录每个节点的状态：未访问、正在访问、已访问。
   - 如果在 DFS 遍历过程中，发现某个节点正在访问中，说明存在环。
3. **判断结果：** 如果 DFS 遍历过程中未检测到环，则可以完成所有课程。

```java
public class Solution {
    public boolean canFinish(int numCourses, int[][] prerequisites) {
        // 构建图
        List<List<Integer>> graph = new ArrayList<>();
        for (int i = 0; i < numCourses; i++) {
            graph.add(new ArrayList<>());
        }
        
        for (int[] pre : prerequisites) {
            int course = pre[0];
            int prereq = pre[1];
            graph.get(prereq).add(course);
        }
        
        // 初始化状态数组
        int[] state = new int[numCourses];
        
        // 对每个节点进行DFS
        for (int i = 0; i < numCourses; i++) {
            if (hasCycle(graph, state, i)) {
                return false;
            }
        }
        
        return true;
    }
    
    // 检测环的DFS方法
    private boolean hasCycle(List<List<Integer>> graph, int[] state, int course) {
        if (state[course] == 1) { // 正在访问
            return true;
        }
        if (state[course] == 2) { // 已访问
            return false;
        }
        
        state[course] = 1; // 标记为正在访问
        for (int nextCourse : graph.get(course)) {
            if (hasCycle(graph, state, nextCourse)) {
                return true;
            }
        }
        state[course] = 2; // 标记为已访问
        
        return false;
    }
}
```



### 五十四、实现 Trie（前缀树）

```java
public class Trie {

    private TrieNode root;

    // 初始化 Trie
    public Trie() {
        root = new TrieNode();
    }

    // 插入单词
    public void insert(String word) {
        TrieNode current = root;
        for (char ch : word.toCharArray()) {
            int index = ch - 'a'; // 计算字符在数组中的位置
            if (current.children[index] == null) {
                current.children[index] = new TrieNode();
            }
            current = current.children[index];
        }
        current.isEndOfWord = true; // 标记完整单词
    }

    // 搜索单词
    public boolean search(String word) {
        TrieNode node = searchNode(word);
        return node != null && node.isEndOfWord;
    }

    // 搜索前缀
    public boolean startsWith(String prefix) {
        TrieNode node = searchNode(prefix);
        return node != null;
    }

    // 辅助方法：搜索节点
    private TrieNode searchNode(String str) {
        TrieNode current = root;
        for (char ch : str.toCharArray()) {
            int index = ch - 'a';
            if (current.children[index] == null) {
                return null;
            }
            current = current.children[index];
        }
        return current;
    }
}

class TrieNode {
    // 指向子节点的指针数组，假设只处理小写字母
    TrieNode[] children;
    // 是否为完整单词的标志
    boolean isEndOfWord;

    // 初始化节点
    public TrieNode() {
        // 26 个字母
        children = new TrieNode[26];
        isEndOfWord = false;
    }
}
```





## 十、回溯

### 五十五、全排列

```java
class Solution {
    List<List<Integer>> result = new ArrayList<>();
    List<Integer> path = new LinkedList<>();
    boolean[] used;

    public List<List<Integer>> permute(int[] nums) {
        used = new boolean[nums.length];
        backtracking(nums);

        return result;
    }

    public void backtracking(int[] nums){
        if(path.size() == nums.length){
            result.add(new ArrayList<>(path));
            return;
        }

        for(int i = 0; i < nums.length; i++){
            if(used[i]){
                continue;
            }

            path.add(nums[i]);
            used[i] = true;
            backtracking(nums);
            used[i] = false;
            path.removeLast();
        }
    }
}
```



### 五十六、子集

```java
class Solution {
    List<List<Integer>> result = new ArrayList<>();
    List<Integer> path = new LinkedList<>();

    public List<List<Integer>> subsets(int[] nums) {
        backtracking(nums, 0);

        return result;
    }

    public void backtracking(int[] nums, int index){
        result.add(new LinkedList<>(path));
        
        if(index >= nums.length){
            return;
        }

        for(int i = index; i < nums.length; i++){
            path.add(nums[i]);
            backtracking(nums, i + 1);
            path.removeLast();
        }
    }
}
```



### 五十七、电话号码的字母组合

```java
class Solution {
    char[][] arr = {{}, {}, {'a', 'b', 'c'}, {'d', 'e', 'f'},
            {'g', 'h', 'i'}, {'j', 'k', 'l'}, {'m', 'n', 'o'},
            {'p', 'q', 'r', 's'}, {'t', 'u', 'v'}, {'w', 'x', 'y', 'z'}};

    List<String> result = new ArrayList<>();
    StringBuilder path = new StringBuilder();

    public List<String> letterCombinations(String digits) {
        int length = digits.length();
        if (length == 0) {
            return result;
        }
		// 把传入参数转换为数组
        int[] digitsArray = new int[length];
        for (int i = 0; i < length; i++) {
            digitsArray[i] = digits.charAt(i) - '0';
        }

        backtracking(digitsArray, 0, length);

        return result;
    }

    public void backtracking(int[] num, int index, int len) {
        if (index == len) {
            result.add(path.toString());
            return;
        }

        for (int j = 0; j < arr[num[index]].length; j++) {
            path.append(arr[num[index]][j]);
            backtracking(num, index + 1, len); 
            path.deleteCharAt(path.length() - 1);
        }
    }
}
```



### 五十八、组合总和

```java
class Solution {
    List<List<Integer>> result = new ArrayList<>();
    List<Integer> path = new LinkedList<>();
    int sum = 0;

    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        Arrays.sort(candidates);
        backtracking(candidates, target, 0);

        return result;
    }

    public void backtracking(int[] array, int target, int index){
        if(sum == target){
            result.add(new LinkedList<>(path));
            return;
        }

        if(sum > target){
            return;
        }

        for(int i = index; i < array.length; i++){
            path.add(array[i]);
            sum += array[i];
            backtracking(array, target, i);
            sum -= array[i];
            path.removeLast();
        }
    }
}
```



### 五十九、括号生成

```java
class Solution {
   StringBuffer path = new StringBuffer();
   List<String> res = new ArrayList<>();

   public List<String> generateParenthesis(int n) {
       backtracking(0, 0, n);
       return res;
   }

   void backtracking(int l, int r, int n) {
       if (l > n || l < r) { // 剪枝
           return;
       }
       if (path.length() == 2 * n) {
           res.add(path.toString());
       }
       for (int i = 0; i < 2; i++) { // 将括号看作大小为 2 的数组，求他们的有效组合，括号个数决定了树的深度
           if (i == 0) {
               path.append("(");
               backtracking(l + 1, r, n);
               path.deleteCharAt(path.length() - 1); // 回溯
           }
           if (i == 1) {
               path.append(")");
               backtracking(l, r + 1, n);
               path.deleteCharAt(path.length() - 1); // 回溯
           }
       }
   }
}
```



### 六十、单词搜索

```java
class Solution {
    int number = 0;
    boolean result = false;
    boolean[][] used;

    public boolean exist(char[][] board, String word) {
        int len = word.length();
        int rowLength = board.length;
        int columnLength = board[0].length;

        for(int i = 0; i < rowLength; i++){
            for(int j = 0; j < columnLength; j++){
                if(word.charAt(0) == board[i][j]){  //剪枝
                    used = new boolean[rowLength][columnLength];
                    number = 0;
                    backtracking(board, word, 0, i, j);
                }
            }
            if(result){
                break;
            }
        }

        return result;
    }

    public void backtracking(char[][] board, String word, int index, int row, int column){
        if(number == word.length()){
            result = true;
            return;
        }

        // 判断是否越界
        if(row < 0 || row >= board.length || column < 0 || column >= board[0].length){
            return;
        }

        // 如果 字母已经使用过 或 字母不匹配 就返回
        if(used[row][column] || board[row][column] != word.charAt(index)){
            return;
        }

        number++;
        used[row][column] = true;
        backtracking(board, word, number, row + 1, column);
        backtracking(board, word, number, row - 1, column);
        backtracking(board, word, number, row, column + 1);
        backtracking(board, word, number, row, column - 1);
        used[row][column] = false;
        number--;
    }
}
```



### 六十一、分割回文串

```java
class Solution {
    List<List<String>> result = new ArrayList<>();
    List<String> sub = new LinkedList<>();

    public List<List<String>> partition(String s) {
        int len = s.length();
        backtracking(s, 0);

        return result;
    }

    // 回溯算法
    public void backtracking(String s, int index){
        if(index >= s.length()){
            result.add(new ArrayList<>(sub));
            return;
        }

        for(int i = index; i < s.length(); i++){
            if(isPalindrome(s.substring(index, i + 1))){
                sub.add(s.substring(index, i + 1));
                backtracking(s, i + 1);
                sub.removeLast();
            }
        }
    }

    //判断是否为回文串
    public boolean isPalindrome(String s){
        if(s.length() == 0){
            return false;
        }

        int left = 0, right = s.length() - 1;   // 左右指针

        while(left <= right ){
            if(s.charAt(left) != s.charAt(right)){
                return false;
            }

            left++;
            right--;
        }

        return true;
    }
}
```





### 六十二、N皇后

```java
class Solution {
    List<List<String>> result = new ArrayList<>();
    LinkedList<String> path = new LinkedList<>();
    StringBuilder sb = new StringBuilder();

    public List<List<String>> solveNQueens(int n) {
        for (int i = 0; i < n; i++) {
            sb.append(".");
        }
        backtracking(n, 0, new boolean[n][n]);

        return result;
    }

    public void backtracking(int n, int floor, boolean[][] used) {
        if (path.size() == n) {
            result.add(new ArrayList<>(path));
            return;
        }

        for (int i = 0; i < n; i++) {
            if (!used[floor][i]) {
                sb.setCharAt(i, 'Q');   // 放的地方设置为 Q
                path.add(sb.toString());    
                sb.setCharAt(i, '.');   // 恢复
                backtracking(n, floor + 1, put(i, floor, n, used));
                path.remove(path.size() - 1);
            }
        }
    }

    // 下棋，将横竖，斜线都设置为true
    public boolean[][] put(int x, int y, int n, boolean[][] used) {
        //主要是这里要创建一个新的数组，不然都直接传引用，直接共用一个了
        boolean[][] used2 = new boolean[n][n];

        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                used2[i][j] = used[i][j];
            }
        }

        //竖
        for (int i = 0; i < n; i++) {
            used2[i][x] = true;
        }

        //左上
        for (int i = x,j = y; i >= 0 && j >= 0; i--,j--) {
            used2[j][i] = true;
        }

        //左下
        for (int i = x, j = y; i >= 0 && j < n; i--, j++) {
            used2[j][i] = true;
        }

        //右上
        for (int i = x, j = y; i < n && j >= 0; i++, j--) {
            used2[j][i] = true;
        }

        //右下
        for (int i = x,  j = y; i < n && j < n; i++,  j++) {
            used2[j][i] = true;
        }

        return used2;
    }
}
```







## 十一、二分查找

### 六十三、搜索插入位置

```java
class Solution {
    public int searchInsert(int[] nums, int target) {
        int len = nums.length;
        int left = 0, right = len - 1;

        while(left <= right){
            int mid = (left + right) / 2;
            if(nums[mid] < target){
                left = mid + 1;
            }else{
                right = mid - 1;
            }
        }

        return left;
    }
}
```





### 六十四、搜索二维矩阵

```java
class Solution {
    public boolean searchMatrix(int[][] matrix, int target) {
        int m = matrix.length;
        int n = matrix[0].length;
        int left = 0;
        int right = m * n - 1;

        while (left <= right) {
            int mid = left + (right - left) / 2;
            int midValue = matrix[mid / n][mid % n];

            if (midValue == target) {
                return true;
            } else if (midValue < target) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }

        return false;
    }
}
```



### 六十五、在排序数组中查找元素的第一个和最后一个位置

```java
class Solution {
    public int[] searchRange(int[] nums, int target) {
        int left = 0;
        int right = nums.length - 1;
        int first = -1;
        int last = -1;
        // 找第一个等于target的位置
        while (left <= right) {
            int middle = (left + right) / 2;
            if (nums[middle] == target) {
                first = middle;
                right = middle - 1; //重点
            } else if (nums[middle] > target) {
                right = middle - 1;
            } else {
                left = middle + 1;
            }
        }

        // 最后一个等于target的位置
        left = 0;
        right = nums.length - 1;
        while (left <= right) {
            int middle = (left + right) / 2;
            if (nums[middle] == target) {
                last = middle;
                left = middle + 1; //重点
            } else if (nums[middle] > target) {
                right = middle - 1;
            } else {
                left = middle + 1;
            }
        }

        return new int[]{first, last};
    }
}
```



### 六十六、搜索旋转排序数组

```java
class Solution {
    public int search(int[] nums, int target) {
        int start = 0;
        int end = nums.length - 1;

        while (start <= end) {
            int mid = start + (end - start) / 2;

            if (nums[mid] == target) {
                return mid;
            }

            // 判断哪一边是有序的
            if (nums[start] <= nums[mid]) { // 左边有序
                if (target >= nums[start] && target < nums[mid]) { // 目标值在左边
                    end = mid - 1;
                } else { // 目标值在右边
                    start = mid + 1;
                }
            } else { // 右边有序
                if (target > nums[mid] && target <= nums[end]) { // 目标值在右边
                    start = mid + 1;
                } else { // 目标值在左边
                    end = mid - 1;
                }
            }
        }

        return -1; // 目标值不存在
    }
}
```



### 六十七、寻找旋转排序数组中的最小值

```java
class Solution {
    public int findMin(int[] nums) {
        int left = 0, right = nums.length - 1;
        int min = Integer.MAX_VALUE;

        while(left <= right){
            int mid = (left + right) / 2;

            if(nums[mid] <= nums[right]){
                min = Math.min(min, nums[mid]);
                right = mid - 1;
            }else if(nums[mid] > nums[right]){
                left = mid + 1;
            }
        }

        return min;
    }
}
```



### 六十八、寻找两个正序数组的中位数（困难）

```java
class Solution {
    public double findMedianSortedArrays(int[] nums1, int[] nums2) {
        // 保证 nums1 是较短的数组
        if (nums1.length > nums2.length) {
            int[] temp = nums1;
            nums1 = nums2;
            nums2 = temp;
        }

        int x = nums1.length;
        int y = nums2.length;
        int low = 0;
        int high = x;

        while (low <= high) {
            // 分割位置
            int partitionX = (low + high) / 2;
            int partitionY = (x + y + 1) / 2 - partitionX;

            // 边界值处理
            int maxX = (partitionX == 0) ? Integer.MIN_VALUE : nums1[partitionX - 1];
            int minX = (partitionX == x) ? Integer.MAX_VALUE : nums1[partitionX];

            int maxY = (partitionY == 0) ? Integer.MIN_VALUE : nums2[partitionY - 1];
            int minY = (partitionY == y) ? Integer.MAX_VALUE : nums2[partitionY];

            // 检查是否找到正确的分割点
            if (maxX <= minY && maxY <= minX) {
                // 如果总数是奇数
                if ((x + y) % 2 == 1) {
                    return Math.max(maxX, maxY);
                } else {
                    // 如果总数是偶数
                    return (Math.max(maxX, maxY) + Math.min(minX, minY)) / 2.0;
                }
            } else if (maxX > minY) {
                // 移动 high 向左
                high = partitionX - 1;
            } else {
                // 移动 low 向右
                low = partitionX + 1;
            }
        }

        return 0;
    }
}
```



## 十二、栈

### 六十九、有效的括号

```java
class Solution {
    public boolean isValid(String s) {
        int len = s.length();
        if(len == 1){
            return false;
        }

        Stack<Character> stack = new Stack<>();

        for(int i = 0; i < len; i++){
            char c = s.charAt(i);

            if(c == '[' || c == '(' || c == '{'){
                stack.push(c);
            }else if(c == ']' && (stack.empty() || stack.pop() != '[')){
                return false;
            }else if(c == ')' && (stack.empty() || stack.pop() != '(')){
                return false;
            }else if(c == '}' && (stack.empty() || stack.pop() != '{')){
                return false;
            }
        }

        return stack.empty();
    }
}
```





### 七十、最小栈

```java
class MinStack {

    Stack<Integer> stack;
    int minVal;

    public MinStack() {
        stack = new Stack<>();
        minVal = Integer.MAX_VALUE;
    }
    
    public void push(int val) {
        // 入栈前保存当前最小值【将当前最小值入栈】
        stack.push(minVal);
        stack.push(val);
        minVal = Math.min(minVal, val);
    }
    
    public void pop() {
        // 出栈时，恢复上一个最小值
        stack.pop();
        int val = stack.pop();
        minVal = val;
    }
    
    public int top() {
        return stack.peek();
    }
    
    public int getMin() {
        return minVal;
    }
}
```



### 七十一、字符串解码（难）

```java
class Solution {
   public String decodeString(String s) {
   Deque<Integer> countStack = new ArrayDeque<>(); // 存储数字
   Deque<String> stringStack = new ArrayDeque<>(); // 存储字符串
   String currentString = ""; // 当前解码字符串
   int k = 0; // 当前的倍数

   for (char ch : s.toCharArray()) {
       if (Character.isDigit(ch)) {
           k = k * 10 + (ch - '0'); // 处理多位数
       } else if (ch == '[') {
           // 遇到 '['，将当前的字符串和数字推入各自的栈
           countStack.push(k);
           stringStack.push(currentString);
           currentString = ""; // 重置当前字符串
           k = 0; // 重置倍数
       } else if (ch == ']') {
           // 遇到 ']'，解码
           StringBuilder temp = new StringBuilder(stringStack.pop());
           int repeatTimes = countStack.pop();
           for (int i = 0; i < repeatTimes; i++) {
               temp.append(currentString); // 重复当前字符串
           }
           currentString = temp.toString(); // 更新当前字符串
       } else {
           // 如果是字母，直接加到当前字符串
           currentString += ch;
       }
   }

   return currentString;
}
```





### 七十二、每日温度

```java
class Solution {
    public int[] dailyTemperatures(int[] temperatures) {
        Deque<Integer> stack=new LinkedList<>();
        int len = temperatures.length;
        int[] answer = new int[len];

        for(int i = 0; i < len; i++){
            while(!stack.isEmpty() && temperatures[stack.peek()] < temperatures[i]){
                // 如果当前温度大于前面存入的温度
                // 取出，并计算距离
                answer[stack.peek()] = i - stack.peek();
                stack.pop();
            }
            // 入栈的是温度的下标，而不是温度，因为后面要计算距离
            stack.push(i);
        }

        return answer;
    }
}
```



### 七十三、柱状图中最大的矩形

```java
class Solution {

    // 遍历柱子
    // 比栈顶大的直接入栈，比栈顶小的取出计算面积，取出后此时栈顶就是左边的界限
    // 就是，左边第一个比当前高度小的元素，因为实现的是单调栈

    public int largestRectangleArea(int[] heights) {
        // 创建一个栈来存储柱子的索引
        Stack<Integer> stack = new Stack<>();
        int maxArea = 0; // 用于存储最大矩形面积
        int n = heights.length; // 柱子的数量
        
        // 遍历所有柱子，包括最后一个哨兵柱子
        for (int i = 0; i <= n; i++) {
            // 在数组末尾添加一个高度为0的柱子，确保所有元素都能被弹出处理
            int currentHeight = (i == n) ? 0 : heights[i];
            
            // 当栈不为空且当前柱子高度小于栈顶柱子高度时，进行弹栈处理
            while (!stack.isEmpty() && heights[stack.peek()] > currentHeight) {
                // 获取并移除栈顶元素
                int height = heights[stack.pop()];
                
                // 计算矩形的宽度
                int width = stack.isEmpty() ? i : i - stack.peek() - 1;
                
                // 计算当前最大面积并更新最大矩形面积
                maxArea = Math.max(maxArea, height * width);
            }
            
            // 将当前柱子的索引推入栈
            stack.push(i);
        }
        
        return maxArea;
    }
}
```



## 十三、堆

### 七十四、数组中的第K个最大元素（难）

```java
import java.util.Random;

class Solution {
    public int findKthLargest(int[] nums, int k) {
        int len = nums.length;
        int target = len - k;
        int left = 0;
        int right = len - 1;

        while(true){
            Random random = new Random();
            // 基准下标
            int pivotIndex = left + random.nextInt(right - left + 1);
            // 分治函数
            pivotIndex = partition(nums, left, right, pivotIndex);

            if (target == pivotIndex) {
                return nums[target];
            } else if (target < pivotIndex) {
                // 缩小范围
                right = pivotIndex - 1;
            } else {
                // 缩小范围
                left = pivotIndex + 1;
            }
        }
    }

    // 分治函数，在[left,right]内，把比基准数小的数放到基准左边，比基准数大的放到基准右边
    private int partition(int[] nums, int left, int right, int pivotIndex) {
        int pivot = nums[pivotIndex];
        // 先把基准数移到最右边
        swap(nums, pivotIndex, right);
        int storeIndex = left;

        for (int i = left; i <= right; i++) {
            if (nums[i] < pivot) {
                // 比基准小，放到左边
                swap(nums, storeIndex, i);
                storeIndex++;
            }
        }

        // 把基准数放到正确的位置
        swap(nums, storeIndex, right);
        return storeIndex;
    }

    private void swap(int[] nums, int i, int j) {
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
}
```



### 七十五、前 K 个高频元素（难）

**1. 统计频率**：首先需要统计每个元素出现的频率。这可以通过使用哈希表（`HashMap`）来实现。

**2. 维护一个优先队列（小根堆）**：使用优先队列来维护频率最高的 `k` 个元素。

**3. 输出结果**：从优先队列中提取出 `k` 个元素，这些元素就是数组中出现频率最高的 `k` 个元素。

```java
class Solution {
    public int[] topKFrequent(int[] nums, int k) {
        // 使用哈希表统计每个数字出现的频率
        Map<Integer, Integer> frequencyMap = new HashMap<>();
        for (int num : nums) {
            frequencyMap.put(num, frequencyMap.getOrDefault(num, 0) + 1);
        }

        // 创建一个优先队列（小根堆）用于存储频率最高的K个元素
        PriorityQueue<Map.Entry<Integer, Integer>> minHeap = 
            new PriorityQueue<>((a, b) -> a.getValue() - b.getValue());

        // 遍历频率表，维护一个大小为K的小根堆
        for (Map.Entry<Integer, Integer> entry : frequencyMap.entrySet()) {
            minHeap.add(entry);
            // 如果堆的大小超过K，移除堆顶元素（频率最小的元素）
            if (minHeap.size() > k) {
                minHeap.poll();
            }
        }

        // 提取堆中的元素，存入结果列表
        List<Integer> resultList = new ArrayList<>();
        while (!minHeap.isEmpty()) {
            resultList.add(minHeap.poll().getKey());
        }

        // 将结果列表转换为数组并返回
        int[] result = new int[resultList.size()];
        for (int i = 0; i < result.length; i++) {
            result[i] = resultList.get(i);
        }
        
        return result;
    }
}
```



### 七十六、数据流的中位数（难）

```java
class MedianFinder {

    private PriorityQueue<Integer> maxHeap; // 最大堆（存储较小的一半）
    private PriorityQueue<Integer> minHeap; // 最小堆（存储较大的一半）

    public MedianFinder() {
        // 初始化最大堆为降序排列
        maxHeap = new PriorityQueue<>((a, b) -> b - a);
        // 初始化最小堆为升序排列
        minHeap = new PriorityQueue<>();
    }

    public void addNum(int num) {
        // 先将数字加入最大堆
        maxHeap.offer(num);
        
        // 保证最大堆的堆顶元素小于等于最小堆的堆顶元素
        if (!minHeap.isEmpty() && maxHeap.peek() > minHeap.peek()) {
            minHeap.offer(maxHeap.poll());
        }

        // 保证两个堆的大小平衡，最大堆可以比最小堆多一个元素
        if (maxHeap.size() > minHeap.size() + 1) {
            minHeap.offer(maxHeap.poll());
        } else if (minHeap.size() > maxHeap.size()) {
            maxHeap.offer(minHeap.poll());
        }
    }

    public double findMedian() {
        // 如果最大堆的大小大于最小堆，说明总数是奇数
        if (maxHeap.size() > minHeap.size()) {
            return maxHeap.peek();
        }
        // 否则，总数是偶数
        return (maxHeap.peek() + minHeap.peek()) / 2.0;
    }
}
```





## 十四、贪心算法

### 七十七、买卖股票的最佳时机

```java
class Solution {
    public int maxProfit(int[] prices) {
        int[] dp = new int[2];
        dp[0] -= prices[0];
        dp[1] = 0;

        for(int i = 1; i < prices.length; i++){
            //第i天不持有股票
            //【卖掉 第i-1天的股票】 和 【保持第i-1天不持有股票状态】 取最大
            dp[1] = Math.max(dp[1], dp[0] + prices[i]);
            //第i天持有股票
            //【买第i天的股票】 和 【保持第i-1天持有股票状态】 取最大
            dp[0] = Math.max(dp[0], -prices[i]);
        }

        return dp[1];
    }
}
```



### 七十八、跳跃游戏

```java
class Solution {
    public boolean canJump(int[] nums) {
        if(nums.length == 1){
            return true;
        }

        // 可以到达的最远距离
        int range = nums[0];

        for(int i = 0; i <= range; i++){
            // 更新最远距离
            range = Math.max(i + nums[i], range);
            
            if(range >= nums.length - 1){
                return true;
            }
        }

        return false;
    }
}
```



### 七十九、跳跃游戏Ⅱ

```java
class Solution {
    public int jump(int[] nums) {
        if(nums.length == 1) return 0;

        int step = 1;
        int lastFarthest = nums[0];
        int farthest = nums[0];

        for(int i=0;i < nums.length;i++){
            if(i > lastFarthest) {
                lastFarthest = farthest;
                step++;
            }

            farthest = Math.max(nums[i] + i, farthest);

            if(lastFarthest >= nums.length - 1){
                return step;
            }
        }

        return step;
    }
}
```



### 八十、划分字母区间（难）

```java
class Solution {
    public List<Integer> partitionLabels(String s) {
        List<Integer> list = new LinkedList<>();
        // 这个数组记录每个字符出现的最远下标
        int[] edge = new int[26];

        char[] chars = s.toCharArray();

        for (int i = 0; i < chars.length; i++) {
            edge[chars[i] - 'a'] = i;
        }

        // 记录遍历的下标
        int idx = 0;
        // 记录上一串字符的结尾下标，方便计算长度
        int last = -1;
        for (int i = 0; i < chars.length; i++) {
            idx = Math.max(idx,edge[chars[i] - 'a']);
            if (i == idx) {
                list.add(i - last);
                last = i;
            }
        }
        return list;
    }
}
```



## 十五、动态规划

### 八十一、爬楼梯

```java
class Solution {
    public int climbStairs(int n) {
        int[] dp = new int[n + 1];
        dp[0] = 1;
        dp[1] = 1;

        for(int i = 2; i <= n; i++){
            dp[i] = dp[i-1] + dp[i-2];
        }

        return dp[n];
    }
}
```



### 八十二、杨辉三角

```java
class Solution {
    public List<List<Integer>> generate(int numRows) {
        List<List<Integer>> result = new ArrayList<>();
        List<Integer> path = new LinkedList<>();

        path.add(1);
        result.add(new LinkedList<>(path));

        if(numRows == 1){
            return result;
        }
        path.clear();

        for(int i = 2; i <= numRows; i++){
            // 通过上一行计算到下一行的中间部分
            for(int j = 0; j < path.size() - 1; j++){
                path.set(j, path.get(j) + path.get(j + 1));

                if(j == path.size() - 2){
                    path.removeLast();
                }
            }
            // 添加上前后的1
            path.addFirst(1);
            path.addLast(1);

            result.add(new LinkedList<>(path));
        }

        return result;
    }
}
```





### 八十三、打家劫舍

```java
class Solution {
    public int rob(int[] nums) {
        int len = nums.length;
        if(len == 1){
            return nums[0];
        }

        int[] dp = new int[len];

        dp[0] = nums[0];
        dp[1] = Math.max(nums[0], nums[1]);

        for(int i = 2; i < len; i++){
            // 偷当前房子：dp[i-2] + nums[i]
            // 不偷当前房子：dp[i - 1]
            dp[i] = Math.max(dp[i - 2] + nums[i], dp[i - 1]);
        }

        return dp[len-1];
    }
}
```





### 八十四、完全平方数

```java
class Solution {
    public int numSquares(int n) {
        int[] dp = new int[n + 1];

        // 把完全平方数置为 1
        for(int i = 1; i <= n; i++){
            if(i * i > n){
                break;
            }
            dp[i * i] = 1; 
        }

        for(int i = 1; i <= n; i++){
            // 如果是完全平方数就跳过
            if(dp[i] == 1){
                continue;
            }
            // 先置为最大值
            dp[i] = Integer.MAX_VALUE;

            for(int j = 1; j < i / 2 + 1; j++){
                dp[i] = Math.min(dp[i], dp[j] + dp[i - j]);
            }
        }

        return dp[n];
    }
}
```

官方题解

```java
class Solution {
    public int numSquares(int n) {
        int[] dp = new int[n + 1];
        for (int i = 1; i <= n; i++) {
            int minn = Integer.MAX_VALUE;
            for (int j = 1; j * j <= i; j++) {
                minn = Math.min(minn, dp[i - j * j]);
            }
          // 因为上面计算的时候减去了 j * j 这个完全平方数组合，所以最后要加上
            dp[i] = minn + 1;
        }
        return dp[n];
    }
}
```



### 八十五、零钱兑换

```java
class Solution {
    public int coinChange(int[] coins, int amount) {
        Arrays.sort(coins);
        int[] dp = new int[amount + 1];
        dp[0] = 0;

        for(int i = 1; i <= amount; i++){
            // 将dp数组初始化为最大值
            dp[i] = Integer.MAX_VALUE;
            // 遍历每个钱币
            for(int j = 0; j < coins.length; j++){
                if(coins[j] > i){   // 如果钱币比目标值大，就 break
                    break;
                }
                // 如果前面的目标值没有匹配项，就跳过
                if(dp[i - coins[j]] == -1){
                    continue;
                }

                dp[i] = Math.min(dp[i], dp[i - coins[j]] + 1);
            }
            // 如果还是初始化值，说明不能匹配
            if(dp[i] == Integer.MAX_VALUE){
                dp[i] = -1;
            }
        }

        return dp[amount];
    }
}
```





### 八十六、单词拆分（背包问题）难

```java
public class Solution {
    public boolean wordBreak(String s, List<String> wordDict) {
        Set<String> wordDictSet = new HashSet(wordDict);
        boolean[] dp = new boolean[s.length() + 1];
        dp[0] = true;
        for (int i = 1; i <= s.length(); i++) {
            for (int j = 0; j < i; j++) {
                if (dp[j] && wordDictSet.contains(s.substring(j, i))) {
                    dp[i] = true;
                    break;
                }
            }
        }
        return dp[s.length()];
    }
}
```



### 八十七、最长递增子序列

```java
class Solution {
    public int lengthOfLIS(int[] nums) {
        int[] dp = new int[nums.length];
        int res = 1;

        for(int i = 0; i < nums.length; i++){
            // 初始化为1，表示自身
            dp[i] = 1;

            for(int j = 0; j < i; j++){
                // 从头遍历到当前元素，如果比当前元素小的，都可以算为递增，则+1
                if(nums[j] < nums[i]){
                    dp[i] = Math.max(dp[i], dp[j] + 1);
                }
            }
            // 更新结果
            res = Math.max(dp[i], res);
        }

        return res;
    }
}
```



### 八十八、乘积最大子数组

1. **初始化：**
   - `maxProduct` 和 `minProduct` 分别存储当前子数组中乘积的最大值和最小值。它们都初始化为数组的第一个元素。
   - `result` 记录全局的最大乘积。
2. **遍历数组：**
   - 从第二个元素开始遍历数组。
   - 如果当前元素是负数，由于负数乘以一个较大的正数会变成较小的负数，而乘以一个较小的负数会变成较大的正数，因此需要交换 `maxProduct` 和 `minProduct`。
   - 更新 `maxProduct` 和 `minProduct`：它们要么继续扩展当前的子数组（乘以当前元素），要么重新从当前元素开始。
   - 更新 `result`，使其保存全局的最大乘积。
3. **返回结果：**
   - 最后返回 `result`，即乘积最大的子数组的乘积。

```java
public class Solution {
    public int maxProduct(int[] nums) {
        // 初始化
        int maxProduct = nums[0];
        int minProduct = nums[0];
        int result = nums[0];

        // 遍历数组
        for (int i = 1; i < nums.length; i++) {
            int current = nums[i];

            // 如果当前数为负数，则交换最大值和最小值
            if (current < 0) {
                int temp = maxProduct;
                maxProduct = minProduct;
                minProduct = temp;
            }

            // 更新最大值和最小值
            maxProduct = Math.max(current, maxProduct * current);
            minProduct = Math.min(current, minProduct * current);

            // 更新结果
            result = Math.max(result, maxProduct);
        }

        return result;
    }
}
```



### 八十九、分割等和子集

```java
class Solution {
    public boolean canPartition(int[] nums) {
        if(nums == null || nums.length == 0) return false;
        int n = nums.length;
        int sum = 0;
        for(int num : nums) {
            sum += num;
        }
        //总和为奇数，不能平分
        if(sum % 2 != 0) return false;
        int target = sum / 2;
        int[] dp = new int[target + 1];

        // 先遍历物品
        for(int i = 0; i < n; i++) {
            // 再遍历背包，且为倒序
            for(int j = target; j >= nums[i]; j--) {
                //物品 i 的重量是 nums[i]，其价值也是 nums[i]
                dp[j] = Math.max(dp[j], dp[j - nums[i]] + nums[i]);
            }
           
            //剪枝
            if(dp[target] == target)
                return true;
        }
        return dp[target] == target;
    }
}
```



### 九十、最长有效括号

1. **动态规划数组初始化：**
   - `dp[i]` 表示以 `s[i]` 结尾的最长有效括号长度。初始化时所有元素都为0。
2. **遍历字符串：**
   - 从索引 `1` 开始遍历字符串，因为单个字符肯定无法构成有效的括号。
   - 如果 `s[i]` 是 `)` ，有两种情况需要考虑：
     - **情况1**：如果前一个字符 `s[i-1]` 是 `(`，即形成了一个直接的“()”，那么 `dp[i]`=`dp[i-2] + 2`，其中 `dp[i-2] 是前面子串的最长有效括号长度。
     - **情况2**：如果前一个字符 `s[i-1]` 是 `)`，且在 `s[i-1]` 所形成的最长有效括号的前一个字符是 `(`，那么可以将当前的 `)` 与它匹配，并加上之前的长度。
3. **更新最大长度：**
   - 每次更新 `maxLen` 为当前的最大值。
4. **返回结果：**
   - 遍历完字符串后，`maxLen` 即为最长有效括号子串的长度。

```java
public class Solution {
    public int longestValidParentheses(String s) {
        int maxLen = 0;
        int n = s.length();
        int[] dp = new int[n]; // dp[i] 表示以 s[i] 结尾的最长有效括号长度

        for (int i = 1; i < n; i++) {
            if (s.charAt(i) == ')') {
                if (s.charAt(i - 1) == '(') {
                    // 情况1：直接匹配 "()" 形式
                    dp[i] = (i >= 2 ? dp[i - 2] : 0) + 2;
                } else if (i - dp[i - 1] > 0 && s.charAt(i - dp[i - 1] - 1) == '(') {
                    // 情况2：匹配类似 "...))" 的形式
                    dp[i] = dp[i - 1] + ((i - dp[i - 1]) >= 2 ? dp[i - dp[i - 1] - 2] : 0) + 2;
                }
                maxLen = Math.max(maxLen, dp[i]);
            }
        }

        return maxLen;
    }
}

```



### 九十一、不同路径

```java
class Solution {
    public int uniquePaths(int m, int n) {
        int[][] dp = new int[m][n];
        // 第一行和第一列初始化为 1
        for(int i = 0; i < m; i++){
            dp[i][0] = 1;
        }

        for(int i = 0; i < n; i++){
            dp[0][i] = 1;
        }

        for(int i = 1; i < m; i++){
            for(int j = 1; j < n; j++){
                // 到达当前格子的路 =【到达上面的格子的路径种数 + 到达左边格子的路径种数】
                dp[i][j] = dp[i][j-1] + dp[i-1][j];
            }
        }

        return dp[m-1][n-1];
    }
}
```



### 九十二、最小路径和

```java
class Solution {
    public int minPathSum(int[][] grid) {
        int row = grid.length;
        int column = grid[0].length;

        for(int i = 1; i < row; i++){
            grid[i][0] += grid[i-1][0];
        }

        for(int i = 1; i < column; i++){
            grid[0][i] += grid[0][i-1];
        }

        for(int i = 1; i < row; i++){
            for(int j = 1; j < column; j++){
                // 选择较小的一条路径
                grid[i][j] += Math.min(grid[i-1][j], grid[i][j-1]);
            }
        }

        return grid[row-1][column-1];
    }
}
```



### 九十三、最长回文子串（难）

使用一个二维数组 `dp[i][j]` 表示子串 `s[i...j]` 是否是回文串

```java
public class Solution {
    public String longestPalindrome(String s) {
        int n = s.length();
        if (n < 2) return s;

        boolean[][] dp = new boolean[n][n];
        int start = 0, maxLength = 1;

        for (int i = 0; i < n; i++) {
            dp[i][i] = true; // 单个字符是回文串
        }

        for (int j = 1; j < n; j++) {
            for (int i = 0; i < j; i++) {
                if (s.charAt(i) == s.charAt(j)) {
                    if (j - i < 3) {
                        dp[i][j] = true; // 处理长度为2或3的子串
                    } else {
                        dp[i][j] = dp[i + 1][j - 1]; // 更长的子串依赖于内层子串是否回文
                    }
                }

                if (dp[i][j] && j - i + 1 > maxLength) {
                    maxLength = j - i + 1;
                    start = i;
                }
            }
        }

        return s.substring(start, start + maxLength);
    }
}
```

