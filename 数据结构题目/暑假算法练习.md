# 暑假算法练习

## 一、两数之和

暴力法

```java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        int[] res = new int[2];
        int len = nums.length;
        for(int i = 0; i < len; i++){
            for(int j = i + 1; j < len; j++){
                if(nums[j] == target - nums[i]){
                    res[0] = i;
                    res[1] = j;
                    return res;
                }
            }
        }

        return res;
    }
}
```

空间换时间：使用哈希表

```java
public int[] twoSum(int[] nums, int target) {
        HashMap<Integer, Integer> map = new HashMap<>();
        for(int i = 0; i < nums.length; i++){
            map.put(nums[i], i);
        }

        for(int i = 0; i < nums.length; i++){
            Integer tag = map.get(target - nums[i]);
            if(tag != null && i != tag){
                int[] res = {i, tag};
                return res;
            }
        }

        return null;
    }
```

题解：当没有在hash表中找到匹配的数时，才把当前数插入到哈希表中，这样可以避免匹配一样的数字。

```java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer, Integer> hashtable = new HashMap<Integer, Integer>();
        for (int i = 0; i < nums.length; ++i) {
            if (hashtable.containsKey(target - nums[i])) {
                return new int[]{hashtable.get(target - nums[i]), i};
            }
            hashtable.put(nums[i], i);
        }
        return new int[0];
    }
}
```



## 二、字母异位词分组

```java
class Solution {
    public List<List<String>> groupAnagrams(String[] strs) {
        List<List<String>> res = new ArrayList<>();
        // （一种字符组合，res中对应的下标）
        Map<String, Integer> map = new HashMap<>();

        for(int i = 0; i < strs.length; i++){
            //将字符串进行排序
            String tag = sortString(strs[i]);
            if(map.containsKey(tag)){
                //如果map中有该字符组合，则将原字符串加入到对应的list中。
                res.get(map.get(tag)).add(strs[i]);
            }else{
                //如果map中没有该字符组合，说明是第一次出现
                //创建新的list，并且加入到map中，标记数组下标
                List<String> list = new ArrayList<>();
                list.add(strs[i]);
                res.add(list);
                map.put(tag, res.size()-1);
            }
        }

        return res;
    }

    public String sortString(String str) {
        // 将字符串转换为字符数组
        char[] charArray = str.toCharArray();
        
        // 对字符数组进行排序
        Arrays.sort(charArray);
        
        // 将排序后的字符数组转换回字符串
        return new String(charArray);
    }
}
```



题解：答案是直接在map中存储list数组的。

```java
class Solution {
    public List<List<String>> groupAnagrams(String[] strs) {
        Map<String, List<String>> map = new HashMap<String, List<String>>();
        for (String str : strs) {
            char[] array = str.toCharArray();
            Arrays.sort(array);
            String key = new String(array);
            List<String> list = map.getOrDefault(key, new ArrayList<String>());
            list.add(str);
            map.put(key, list);
        }
        return new ArrayList<List<String>>(map.values());
    }
}
```



## 三、最长连续序列

**题解：简单来说就是每个数都判断一次这个数是不是连续序列的开头那个数**。

- 怎么判断呢，就是用哈希表查找这个数前面一个数是否存在，即num-1在序列中是否存在。存在那这个数肯定不是开头，直接跳过。
- 因此只需要对每个开头的数进行循环，直到这个序列不再连续，因此复杂度是O(n)。 以题解中的序列举例:
  **[100，4，200，1，3，4，2]**
  去重后的哈希序列为：
  **[100，4，200，1，3，2]**
  按照上面逻辑进行判断：

1. 元素100是开头,因为没有99，且以100开头的序列长度为1
2. 元素4不是开头，因为有3存在，过，
3. 元素200是开头，因为没有199，且以200开头的序列长度为1
4. 元素1是开头，因为没有0，且以1开头的序列长度为4，因为依次累加，2，3，4都存在。
5. 元素3不是开头，因为2存在，过，
6. 元素2不是开头，因为1存在，过。

```java

```





## 四、移动零（双指针）

我的

```java
class Solution {
    public void moveZeroes(int[] nums) {
        //第一个零和第一个非零的数交换
        int nzr = 0;    // 非 0

        for(int i = 0; i < nums.length; i++){
            if(nums[i] == 0){
                nzr = i + 1;
                while(nzr < nums.length && nums[nzr] == 0){
                    nzr++;
                }
                if(nzr < nums.length){
                    wrap(nums, nzr, i);
                }
            }
        }
    }

    public void wrap(int[] nums, int a, int b){
        int tag = nums[a];
        nums[a] = nums[b];
        nums[b] = tag;
    }
}
```



题解

![](https://pic.leetcode-cn.com/36d1ac5d689101cbf9947465e94753c626eab7fcb736ae2175f5d87ebc85fdf0-283_2.gif)

```java
class Solution {
    public void moveZeroes(int[] nums) {
        int nzr = 0;    // 移动到非 0 的数值

        for(int i = 0; i < nums.length; i++){
            if(nums[i] != 0){
                int tag = nums[i];
                nums[i] = nums[nzr];
                nums[nzr++] = tag;
            }
        }
    }
}
```



## 五、盛最多水的容器

### 为什么移动水位较低的指针？

面积 = 长 * 宽。

首先 ，无论移动谁，长都是会变小的。

然后宽是有两个指针水位较低者决定的，如果移动水位较高的指针：得到的新水位比原来低水位指针更低时，此时宽变小了，则面积变小；即使得到的新水位比原来高水位还要高，但是宽还是由原来低水位决定的，此时宽不必，但由于长变小了，则面积还是变小。

所以啊，如果移动水位较高的指针，无论如何面积都是变小。

```java
class Solution {
    public int maxArea(int[] height) {
        int res = 0;
        int left = 0;
        int right = height.length - 1;

        while(left < right){
            //计算
            res = Math.max(res, (right-left) * Math.min(height[left], height[right]));

            //移动水位较低的指针
            if(height[left] < height[right]){
                left++;
            }else{
                right--;
            }
        }

        return res;
    }
}
```



## 六、三数之和

### 如何去重？

1. 如果当前元素 `nums[i]` 和前一个元素 `nums[i-1]` 相同，那么跳过当前元素以避免产生重复的三元组。
2. 通过两个 `while` 循环分别跳过相同的左指针和右指针的元素，以确保找到的三元组是唯一的。

```java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        List<List<Integer>> res = new ArrayList<>();

        int len = nums.length;
        int left = 0;
        int right = nums.length - 1;
        //排序
        Arrays.sort(nums);
        //最左边的必须要小于等于零
        for(int i = 0; i < len && nums[i] <= 0; i++){
            //去重
            if(i > 0 && nums[i] == nums[i-1]){
                continue;
            }

            left = i + 1;
            right = nums.length - 1;

            //这个是目标值，题目变为找两个和为target的数
            int target = 0 - nums[i];

            while(left < right){
                if(nums[left] + nums[right] < target){
                    //和太小
                    left++;
                }else if(nums[left] + nums[right] > target){
                    //和太大
                    right--;
                }else{
                    //和 等于 target
                    res.add(Arrays.asList(nums[i], nums[left], nums[right]));

                    //一次找完所有等于target的两个数
                    //去重
                    while(left < right && nums[left] == nums[left+1]){
                        left++;
                    }
                    while(left < right && nums[right] == nums[right-1]){
                        right--;
                    }

                    left++;
                    right--;
                }
            }
        }

        return res;
    }
}
```

