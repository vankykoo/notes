# 暑假算法练习

## 一、两数之和

暴力法

```java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        int[] res = new int[2];
        int len = nums.length;
        for(int i = 0; i < len; i++){
            for(int j = i + 1; j < len; j++){
                if(nums[j] == target - nums[i]){
                    res[0] = i;
                    res[1] = j;
                    return res;
                }
            }
        }

        return res;
    }
}
```

空间换时间：使用哈希表

```java
public int[] twoSum(int[] nums, int target) {
        HashMap<Integer, Integer> map = new HashMap<>();
        for(int i = 0; i < nums.length; i++){
            map.put(nums[i], i);
        }

        for(int i = 0; i < nums.length; i++){
            Integer tag = map.get(target - nums[i]);
            if(tag != null && i != tag){
                int[] res = {i, tag};
                return res;
            }
        }

        return null;
    }
```

题解：当没有在hash表中找到匹配的数时，才把当前数插入到哈希表中，这样可以避免匹配一样的数字。

```java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer, Integer> hashtable = new HashMap<Integer, Integer>();
        for (int i = 0; i < nums.length; ++i) {
            if (hashtable.containsKey(target - nums[i])) {
                return new int[]{hashtable.get(target - nums[i]), i};
            }
            hashtable.put(nums[i], i);
        }
        return new int[0];
    }
}
```



## 二、字母异位词分组

```java
class Solution {
    public List<List<String>> groupAnagrams(String[] strs) {
        List<List<String>> res = new ArrayList<>();
        // （一种字符组合，res中对应的下标）
        Map<String, Integer> map = new HashMap<>();

        for(int i = 0; i < strs.length; i++){
            //将字符串进行排序
            String tag = sortString(strs[i]);
            if(map.containsKey(tag)){
                //如果map中有该字符组合，则将原字符串加入到对应的list中。
                res.get(map.get(tag)).add(strs[i]);
            }else{
                //如果map中没有该字符组合，说明是第一次出现
                //创建新的list，并且加入到map中，标记数组下标
                List<String> list = new ArrayList<>();
                list.add(strs[i]);
                res.add(list);
                map.put(tag, res.size()-1);
            }
        }

        return res;
    }

    public String sortString(String str) {
        // 将字符串转换为字符数组
        char[] charArray = str.toCharArray();
        
        // 对字符数组进行排序
        Arrays.sort(charArray);
        
        // 将排序后的字符数组转换回字符串
        return new String(charArray);
    }
}
```



题解：答案是直接在map中存储list数组的。

```java
class Solution {
    public List<List<String>> groupAnagrams(String[] strs) {
        Map<String, List<String>> map = new HashMap<String, List<String>>();
        for (String str : strs) {
            char[] array = str.toCharArray();
            Arrays.sort(array);
            String key = new String(array);
            List<String> list = map.getOrDefault(key, new ArrayList<String>());
            list.add(str);
            map.put(key, list);
        }
        return new ArrayList<List<String>>(map.values());
    }
}
```



## 三、最长连续序列

**题解：简单来说就是每个数都判断一次这个数是不是连续序列的开头那个数**。

- 怎么判断呢，就是用哈希表查找这个数前面一个数是否存在，即num-1在序列中是否存在。存在那这个数肯定不是开头，直接跳过。
- 因此只需要对每个开头的数进行循环，直到这个序列不再连续，因此复杂度是O(n)。 以题解中的序列举例:
  **[100，4，200，1，3，4，2]**
  去重后的哈希序列为：
  **[100，4，200，1，3，2]**
  按照上面逻辑进行判断：

1. 元素100是开头,因为没有99，且以100开头的序列长度为1
2. 元素4不是开头，因为有3存在，过，
3. 元素200是开头，因为没有199，且以200开头的序列长度为1
4. 元素1是开头，因为没有0，且以1开头的序列长度为4，因为依次累加，2，3，4都存在。
5. 元素3不是开头，因为2存在，过，
6. 元素2不是开头，因为1存在，过。

```java

```

