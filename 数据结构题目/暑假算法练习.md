# 暑假算法练习

## 一、字符串

### 一、两数之和

暴力法

```java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        int[] res = new int[2];
        int len = nums.length;
        for(int i = 0; i < len; i++){
            for(int j = i + 1; j < len; j++){
                if(nums[j] == target - nums[i]){
                    res[0] = i;
                    res[1] = j;
                    return res;
                }
            }
        }

        return res;
    }
}
```

空间换时间：使用哈希表

```java
public int[] twoSum(int[] nums, int target) {
        HashMap<Integer, Integer> map = new HashMap<>();
        for(int i = 0; i < nums.length; i++){
            map.put(nums[i], i);
        }

        for(int i = 0; i < nums.length; i++){
            Integer tag = map.get(target - nums[i]);
            if(tag != null && i != tag){
                int[] res = {i, tag};
                return res;
            }
        }

        return null;
    }
```

题解：当没有在hash表中找到匹配的数时，才把当前数插入到哈希表中，这样可以避免匹配一样的数字。

```java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer, Integer> hashtable = new HashMap<Integer, Integer>();
        for (int i = 0; i < nums.length; ++i) {
            if (hashtable.containsKey(target - nums[i])) {
                return new int[]{hashtable.get(target - nums[i]), i};
            }
            hashtable.put(nums[i], i);
        }
        return new int[0];
    }
}
```



### 二、字母异位词分组

```java
class Solution {
    public List<List<String>> groupAnagrams(String[] strs) {
        List<List<String>> res = new ArrayList<>();
        // （一种字符组合，res中对应的下标）
        Map<String, Integer> map = new HashMap<>();

        for(int i = 0; i < strs.length; i++){
            //将字符串进行排序
            String tag = sortString(strs[i]);
            if(map.containsKey(tag)){
                //如果map中有该字符组合，则将原字符串加入到对应的list中。
                res.get(map.get(tag)).add(strs[i]);
            }else{
                //如果map中没有该字符组合，说明是第一次出现
                //创建新的list，并且加入到map中，标记数组下标
                List<String> list = new ArrayList<>();
                list.add(strs[i]);
                res.add(list);
                map.put(tag, res.size()-1);
            }
        }

        return res;
    }

    public String sortString(String str) {
        // 将字符串转换为字符数组
        char[] charArray = str.toCharArray();
        
        // 对字符数组进行排序
        Arrays.sort(charArray);
        
        // 将排序后的字符数组转换回字符串
        return new String(charArray);
    }
}
```



题解：答案是直接在map中存储list数组的。

```java
class Solution {
    public List<List<String>> groupAnagrams(String[] strs) {
        Map<String, List<String>> map = new HashMap<String, List<String>>();
        for (String str : strs) {
            char[] array = str.toCharArray();
            Arrays.sort(array);
            String key = new String(array);
            List<String> list = map.getOrDefault(key, new ArrayList<String>());
            list.add(str);
            map.put(key, list);
        }
        return new ArrayList<List<String>>(map.values());
    }
}
```



### 三、最长连续序列

**题解：简单来说就是每个数都判断一次这个数是不是连续序列的开头那个数**。

- 怎么判断呢，就是用哈希表查找这个数前面一个数是否存在，即num-1在序列中是否存在。存在那这个数肯定不是开头，直接跳过。
- 因此只需要对每个开头的数进行循环，直到这个序列不再连续，因此复杂度是O(n)。 以题解中的序列举例:
  **[100，4，200，1，3，4，2]**
  去重后的哈希序列为：
  **[100，4，200，1，3，2]**
  按照上面逻辑进行判断：

1. 元素100是开头,因为没有99，且以100开头的序列长度为1
2. 元素4不是开头，因为有3存在，过，
3. 元素200是开头，因为没有199，且以200开头的序列长度为1
4. 元素1是开头，因为没有0，且以1开头的序列长度为4，因为依次累加，2，3，4都存在。
5. 元素3不是开头，因为2存在，过，
6. 元素2不是开头，因为1存在，过。

```java

```



## 二、双指针

### 四、移动零

我的

```java
class Solution {
    public void moveZeroes(int[] nums) {
        //第一个零和第一个非零的数交换
        int nzr = 0;    // 非 0

        for(int i = 0; i < nums.length; i++){
            if(nums[i] == 0){
                nzr = i + 1;
                while(nzr < nums.length && nums[nzr] == 0){
                    nzr++;
                }
                if(nzr < nums.length){
                    wrap(nums, nzr, i);
                }
            }
        }
    }

    public void wrap(int[] nums, int a, int b){
        int tag = nums[a];
        nums[a] = nums[b];
        nums[b] = tag;
    }
}
```



题解

![](https://pic.leetcode-cn.com/36d1ac5d689101cbf9947465e94753c626eab7fcb736ae2175f5d87ebc85fdf0-283_2.gif)

```java
class Solution {
    public void moveZeroes(int[] nums) {
        int nzr = 0;    // 移动到非 0 的数值

        for(int i = 0; i < nums.length; i++){
            if(nums[i] != 0){
                int tag = nums[i];
                nums[i] = nums[nzr];
                nums[nzr++] = tag;
            }
        }
    }
}
```



### 五、盛最多水的容器

#### 为什么移动水位较低的指针？

面积 = 长 * 宽。

首先 ，无论移动谁，长都是会变小的。

然后宽是有两个指针水位较低者决定的，如果移动水位较高的指针：得到的新水位比原来低水位指针更低时，此时宽变小了，则面积变小；即使得到的新水位比原来高水位还要高，但是宽还是由原来低水位决定的，此时宽不必，但由于长变小了，则面积还是变小。

所以啊，如果移动水位较高的指针，无论如何面积都是变小。

```java
class Solution {
    public int maxArea(int[] height) {
        int res = 0;
        int left = 0;
        int right = height.length - 1;

        while(left < right){
            //计算
            res = Math.max(res, (right-left) * Math.min(height[left], height[right]));

            //移动水位较低的指针
            if(height[left] < height[right]){
                left++;
            }else{
                right--;
            }
        }

        return res;
    }
}
```

### 六、三数之和

#### 如何去重？

1. 如果当前元素 `nums[i]` 和前一个元素 `nums[i-1]` 相同，那么跳过当前元素以避免产生重复的三元组。
2. 通过两个 `while` 循环分别跳过相同的左指针和右指针的元素，以确保找到的三元组是唯一的。

```java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        List<List<Integer>> res = new ArrayList<>();

        int len = nums.length;
        int left = 0;
        int right = nums.length - 1;
        //排序
        Arrays.sort(nums);
        //最左边的必须要小于等于零
        for(int i = 0; i < len && nums[i] <= 0; i++){
            //去重
            if(i > 0 && nums[i] == nums[i-1]){
                continue;
            }

            left = i + 1;
            right = nums.length - 1;

            //这个是目标值，题目变为找两个和为target的数
            int target = 0 - nums[i];

            while(left < right){
                if(nums[left] + nums[right] < target){
                    //和太小
                    left++;
                }else if(nums[left] + nums[right] > target){
                    //和太大
                    right--;
                }else{
                    //和 等于 target
                    res.add(Arrays.asList(nums[i], nums[left], nums[right]));

                    //一次找完所有等于target的两个数
                    //去重
                    while(left < right && nums[left] == nums[left+1]){
                        left++;
                    }
                    while(left < right && nums[right] == nums[right-1]){
                        right--;
                    }

                    left++;
                    right--;
                }
            }
        }

        return res;
    }
}
```



### 七、接雨水（困难）

题解

```java
class Solution {
    public int trap(int[] height) {
        if (height == null || height.length == 0) {
            return 0;
        }
	//左右指针下标
        int left = 0, right = height.length - 1;
      //左右边最大高度
        int leftMax = height[left], rightMax = height[right];
        int res = 0;

        while (left < right) {
            if (leftMax < rightMax) {
              //如果左边最大高度小于右边最大高度
              //1.左指针右移（用于更新最大高度，或是计算能接的雨水
              //1.1 第一种情况：更新后高度大于原来的最大高度，则接不到雨水，用于更新最大高度
              //1.2 第二种情况：更新后高度小于原来的最大高度，既然小于较小的最大高度，
              //				那接到的雨水就是与较小最大高度的差值，且不更新高度
                left++;
                leftMax = Math.max(leftMax, height[left]);
              //如果更新了最大高度，这里 leftMax = height[left] 即 res += 0;
                res += leftMax - height[left];
            } else {
                right--;
                rightMax = Math.max(rightMax, height[right]);
                res += rightMax - height[right];
            }
        }

        return res;
    }
}
```



## 三、滑动窗口

### 八、无重复字符的最长子串

```java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        int len = s.length();
        Set<Character> set = new HashSet<>();
        int res = 0, begin = 0, end = 0;
        
        while (begin < len && end < len) {
            if (!set.contains(s.charAt(end))) {
                // 如果字符不重复，添加到集合中
                set.add(s.charAt(end++));
                // 更新最长长度
                res = Math.max(res, end - begin);
            } else {
                // 如果字符重复，从左边开始移除字符
                set.remove(s.charAt(begin++));
            }
        }
        
        return res;
    }
}
```



### 九、找到字符串中所有字母异位词

```java
class Solution {
    public List<Integer> findAnagrams(String s, String p) {
        List<Integer> result = new ArrayList<>();
        
        if (s == null || p == null || s.length() < p.length()) {
            return result;
        }
        
        // 记录p的字符频率
        int[] pCount = new int[26];
        for (char c : p.toCharArray()) {
            pCount[c - 'a']++;
        }
        
        // 记录当前窗口内的字符频率
        int[] sCount = new int[26];
        int windowSize = p.length();
        
        // 遍历字符串s
        for (int i = 0; i < s.length(); i++) {
            // 增加当前字符到窗口内
            sCount[s.charAt(i) - 'a']++;
            
            // 当窗口大小超过p的长度时，移除最左边的字符（关键）
            if (i >= windowSize) {
                sCount[s.charAt(i - windowSize) - 'a']--;
            }
            
            // 比较两个计数器
            if (isAnagram(pCount, sCount)) {
                result.add(i - windowSize + 1);
            }
        }
        
        return result;
    }
    
    //判断两个计数器是否相等
    private boolean isAnagram(int[] pCount, int[] sCount) {
        for (int i = 0; i < 26; i++) {
            if (pCount[i] != sCount[i]) {
                return false;
            }
        }
        return true;
    }
}
```



## 四、子串

### 十、和为 K 的子数组（前缀和+哈希表）

题解：

### 思路：

1. **前缀和 (Prefix Sum)**：前缀和是指从数组的起始元素到当前元素的所有元素的和。通过前缀和，可以将问题转化为寻找两个前缀和的差值为 K 的问题。
2. **哈希表 (Hash Map)**：使用哈希表来存储前缀和出现的次数。通过查找当前前缀和减去 K 是否存在于哈希表中，可以快速找到满足条件的子数组个数。

### 具体步骤：

1. 初始化一个哈希表 `prefixSumCount`，将前缀和 0 的次数设为 1，因为前缀和为 0 表示从数组起始元素到当前元素的和本身可能等于 K。
2. 遍历数组，计算当前元素的前缀和 `currentSum`。
3. 检查 `currentSum - K` 是否在哈希表中，如果存在，说明从某个位置到当前元素的子数组和为 K，将结果计数器增加相应的次数。
4. 更新哈希表中当前前缀和的出现次数。

```java
class Solution {
    public int subarraySum(int[] nums, int k) {
        // 前缀和哈希表，存储前缀和出现的次数
        HashMap<Integer, Integer> prefixSumCount = new HashMap<>();
        // 初始化前缀和0出现的次数为1
        prefixSumCount.put(0, 1);

        int currentSum = 0;
        int count = 0;

        // 遍历数组
        for (int num : nums) {
            currentSum += num; // 计算当前前缀和
            
            // 检查 currentSum - k 是否在哈希表中
            if (prefixSumCount.containsKey(currentSum - k)) {
                count += prefixSumCount.get(currentSum - k); // 增加满足条件的子数组个数
            }
            
            // 更新哈希表中当前前缀和的出现次数
            prefixSumCount.put(currentSum, prefixSumCount.getOrDefault(currentSum, 0) + 1);
        }

        return count;
    }
}
```



### 十一、滑动窗口最大值（困难）（双端队列）

题解：

1. **双端队列**：使用一个双端队列保存当前窗口中的元素索引，队列中的元素从头到尾递减，队首元素为当前窗口的最大值。
2. **保持队列递减**：在遍历数组时，如果新元素大于队尾元素，则将队尾元素移除，直到新元素不再大于队尾元素。
3. **移除过期元素**：如果队首元素的索引已经不在当前窗口范围内，则将其移除。
4. **记录最大值**：当窗口大小达到 k 时，将队首元素对应的值记录到结果数组中。

```java
class Solution {
    public int[] maxSlidingWindow(int[] nums, int k) {
        if (nums == null || nums.length < 2) {
            return nums;
        }

        // 双端队列，存储元素的索引
        Deque<Integer> deque = new LinkedList<>();
        // 结果数组
        int[] result = new int[nums.length - k + 1];

        for (int i = 0; i < nums.length; i++) {
            // 移除不在窗口范围内的元素
            while (!deque.isEmpty() && deque.peekFirst() < i - k + 1) {
                deque.pollFirst();
            }
            // 移除队列中小于当前元素的元素
            while (!deque.isEmpty() && nums[deque.peekLast()] < nums[i]) {
                deque.pollLast();
            }
            // 将当前元素添加到队列中
            deque.offerLast(i);
            // 当窗口大小达到 k 时，记录当前窗口的最大值
            if (i >= k - 1) {
                result[i - k + 1] = nums[deque.peekFirst()];
            }
        }

        return result;
    }
}
```



### 十二、最小覆盖子串（困难）（滑动窗口+哈希表）

题解：

1. 初始化两个哈希表 `tFreq` 和 `windowFreq`，分别记录 `t` 中的字符及其出现次数和当前窗口中的字符及其出现次数。
2. 使用两个指针 `left` 和 `right` 初始化滑动窗口的左右边界，`right` 指针用于扩展窗口，`left` 指针用于收缩窗口。
3. 右指针移动，扩展窗口，更新窗口内字符的出现次数。如果窗口内字符数量满足 `t` 的要求，尝试收缩窗口以找到最小子串。
4. 左指针移动，收缩窗口，更新窗口内字符的出现次数。如果当前窗口不再满足 `t` 的要求，停止收缩，继续扩展窗口。
5. 在整个过程中记录满足条件的最小子串。

```java
class Solution {
    public String minWindow(String s, String t) {
        if (s == null || t == null || s.length() < t.length()) {
            return "";
        }

        // 记录 t 中各字符的出现次数
        HashMap<Character, Integer> tFreq = new HashMap<>();
        for (char c : t.toCharArray()) {
            tFreq.put(c, tFreq.getOrDefault(c, 0) + 1);
        }

        // 滑动窗口中各字符的出现次数
        HashMap<Character, Integer> windowFreq = new HashMap<>();
        int left = 0, right = 0;
        int required = tFreq.size(); // 需要匹配的字符种类数
        int formed = 0; // 当前窗口内匹配的字符种类数
        int[] ans = {-1, 0, 0}; // 记录结果，格式为{窗口长度, 左边界, 右边界}

        // 移动右指针
        while (right < s.length()) {
            char c = s.charAt(right);
            windowFreq.put(c, windowFreq.getOrDefault(c, 0) + 1);

            // 如果当前字符在 t 中，且窗口内该字符的数量与 t 中要求的数量相同，则 formed 加 1
            if (tFreq.containsKey(c) && windowFreq.get(c).intValue() == tFreq.get(c).intValue()) {
                formed++;
            }

            // 尝试收缩窗口
            while (left <= right && formed == required) {
                c = s.charAt(left);

                // 更新最小窗口，如果当前窗口的长度小于之前记录的最小长度，则更新结果
                if (ans[0] == -1 || right - left + 1 < ans[0]) {
                    ans[0] = right - left + 1;
                    ans[1] = left;
                    ans[2] = right;
                }

                // 左指针右移，缩小窗口
                windowFreq.put(c, windowFreq.get(c) - 1);
                if (tFreq.containsKey(c) && windowFreq.get(c).intValue() < tFreq.get(c).intValue()) {
                    formed--;
                }

                left++;
            }

            right++;
        }

        // 返回最小覆盖子串，如果 ans[0] 未更新过，说明未找到满足条件的子串，返回空字符串
        return ans[0] == -1 ? "" : s.substring(ans[1], ans[2] + 1);
    }
}
```



# 五、普通数组

## 十三、最大子数组和

```java
class Solution {
    public int maxSubArray(int[] nums) {
        int res = Integer.MIN_VALUE;
        int sum = 0;

        for(int i = 0; i < nums.length; i++){
            sum += nums[i];
            res = Math.max(sum, res);

          //如果和已经小于零，那么只会让后面的和更小，直接置零
            if(sum < 0){
                sum = 0;
            }
        }

        return res;
    }
}
```



## 十四、合并区间

栈

```java
//类似于下面的方法，没有用左右边界，因为左边界其实用不到，那就把右边界作为栈顶。
class Solution {
    public int[][] merge(int[][] intervals) {
        if(intervals.length == 0){
            return null;
        }

        Arrays.sort(intervals, (a,b) -> {return a[0] - b[0];});

        Stack<Integer> stack = new Stack<>();

        for(int i = 0; i < intervals.length; i++){
            if(!stack.empty() && stack.peek() >= intervals[i][0]){
                if(stack.peek() < intervals[i][1]){
                    stack.pop();
                    stack.push(intervals[i][1]);
                }
            } else{
                stack.push(intervals[i][0]);
                stack.push(intervals[i][1]);
            }
        }

        int size = stack.size() / 2;
        int[][] res = new int[size][2];

        for(int i = size-1; i >= 0; i--){
            res[i][1] = stack.pop();
            res[i][0] = stack.pop();
        }

        return res;
    }
}
```



左右边界

```java
class Solution {
    public int[][] merge(int[][] intervals) {
        if(intervals.length == 0){
            return null;
        }

        Arrays.sort(intervals, (a,b) -> {return a[0] - b[0];});

        List<int[]> res = new ArrayList<>();
      //记录左右边界
        int left = intervals[0][0];
        int right = intervals[0][1];

        for(int i = 1; i < intervals.length; i++){
            if(intervals[i][0] <= right){
              //为什么不在外面的if 用 && 符？有种情况是 被完全包含在里面，即子集，这种不用做处理
                if(intervals[i][1] >= right){
                  //可以合并
                    right = intervals[i][1];
                }
            }else{
              //不可以合并了，添加到结果集，更新左右边界
                res.add(new int[]{left, right});
                left = intervals[i][0];
                right = intervals[i][1];
            }
        }
        res.add(new int[]{left, right});

        return res.toArray(new int[0][2]);
    }
}
```



这两种方法的前提都是根据原数组的第一个数进行从小到大排序。



## 十五、轮转数组

题解：

使用三次翻转：

例：{1,2,3,4,5,6,7} ，k = 3

第一次翻转：下标[0,6] ====> {7,6,5,4,3,2,1}

第二次翻转：下标[0,2] ====> {5,6,7,4,3,2,1}

第三次翻转：下标[3,6] ====> {5,6,7,1,2,3,4}

```java
class Solution {
    public void rotate(int[] nums, int k) {
        k %= nums.length;
        reverse(nums, 0, nums.length - 1);
        reverse(nums, 0, k - 1);
        reverse(nums, k, nums.length - 1);
    }

    public void reverse(int[] nums, int start, int end) {
        while (start < end) {
            int temp = nums[start];
            nums[start] = nums[end];
            nums[end] = temp;
            start += 1;
            end -= 1;
        }
    }
}
```









