# 回溯算法

 ### 一、理论基础

### 回溯算法模板

```java
void backtracking(参数){
  if(终止条件){
    存放结果;
    return;
  }
  
  for(选择：本层集合中元素（树中节点孩子的数量就是集合的大小）){
    处理节点;
    backtracking(路径，选择列表);//递归
    回溯，撤销处理结果
  }
}
```

![](https://code-thinking-1253855093.file.myqcloud.com/pics/20210130173631174.png)





## 二、组合问题

### 题目

![](https://raw.githubusercontent.com/vankykoo/javaStudy/e7418312d081de9088cf2abc95094cdee49051f0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E9%A2%98%E7%9B%AE/backtracking/1.png)

### 思路

![](https://code-thinking-1253855093.file.myqcloud.com/pics/20201123195223940.png)

* 回溯三部曲
* 递归函数的返回值以及参数
  * 定义两个全局变量，一个存放符合条件的单一结果，一个用来存放符合条件结果的集合
  * 三个参数：①集合n，取几个数k，还有startIndex用来防止出现重复的组合
* 终止条件
  * path这个数组如果达到k，说明找到了一个子集大小为k的组合。用result把path存起来
* 单层搜索逻辑
  * for循环横向遍历，递归来纵向遍历。![](https://code-thinking-1253855093.file.myqcloud.com/pics/20201123195242899.png)
  * for循环每次从startIndex开始遍历，然后用path保存取到的节点i。
  * backtracking通过不断调用自己一直往深处遍历，总会遇到叶子节点，遇到了叶子节点就要返回。
  * backtracking的下面部分就是回溯操作，撤销本次处理的结果。





* 剪枝优化

![](https://code-thinking-1253855093.file.myqcloud.com/pics/20210130194335207-20230310134409532.png)

* 将for循环中的【i <= n】换成【i <= n - (k - path.size()) + 1】，



* 可以剪枝的地方就在递归中每一层的for循环所选择的起始位置。
* 如果for循环选择的起始位置之后的元素个数已经不足我们需要的元素个数了，那么就没右必要搜索了



### 二刷

```java
class Solution {

    List<List<Integer>> res = new ArrayList<>();
    List<Integer> path = new ArrayList<>();

    public List<List<Integer>> combine(int n, int k) {
        backtracking(n,k,1);
        return res;
    }

    public void backtracking(int n, int k, int index){
        if(path.size() == k){
            res.add(new ArrayList<>(path));
            return;
        }

        for(int i = index; i <= n - (k - path.size()) + 1; i++){
            path.add(i);
            backtracking(n,k,i+1);
            path.removeLast();
        }
    }
}
```





### 代码

```java
//未剪枝优化
class Solution{
  List<List<Integer>> result = new ArrayList<>();
  List<List<Integer>> path = new LinkedList<>();
  public List<List<Integer>> combine(int n,int k){
    backtracking(n,k,1);
    return result;
  }
  
  public void backtracking(int n,int k,int startIndex){
    if(path.size() == k){
      result.add(new ArrayList<>(path));
      return;
    }
    
    for(int i = startIndex;i <= n; i++){
      path.add(i);
      backtracking(n,k,i+1);
      path.removeLast();
    }
  }
}
```



```java
//剪枝后
class Solution {
    List<List<Integer>> result = new ArrayList<>();
    LinkedList<Integer> path = new LinkedList<>();
    public List<List<Integer>> combine(int n, int k) {
        combineHelper(n, k, 1);
        return result;
    }

    /**
     * 每次从集合中选取元素，可选择的范围随着选择的进行而收缩，调整可选择的范围，就是要靠startIndex
     * @param startIndex 用来记录本层递归的中，集合从哪里开始遍历（集合就是[1,...,n] ）。
     */
    private void combineHelper(int n, int k, int startIndex){
        //终止条件
        if (path.size() == k){
            result.add(new ArrayList<>(path));
            return;
        }
        for (int i = startIndex; i <= n - (k - path.size()) + 1; i++){
            path.add(i);
            combineHelper(n, k, i + 1);
            path.removeLast();
        }
    }
}
```





## 三、组合总和Ⅲ

### 题目

![](https://raw.githubusercontent.com/vankykoo/javaStudy/e7418312d081de9088cf2abc95094cdee49051f0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E9%A2%98%E7%9B%AE/backtracking/2.png)



### 思路

定义两个三个全局变量，sum记录总和，result结果集，sumRes集合

* 回溯方法
  * 终止条件：当sum和sumRes.size()同时满足时，把结果加入到结果集中。
  * 传入的参数：n目标总和，k目标数量，start开始坐标
  * 中间逻辑：在for循环中，初始值i = start，把数字i加入到sumRes，然后sum加上数字i，调用回溯方法。结束后sum 减去 i，删除sumRes的最后一个值。



剪枝：如果sum已经大于目标总和，就返回。





### 代码

```java
class Solution {
    List<List<Integer>> result = new ArrayList<>();
    LinkedList<Integer> sumRes = new LinkedList<>();
    int sum = 0;
    public List<List<Integer>> combinationSum3(int k, int n) {
        backtracking(n,k,1);
        return result;
    }

    public void backtracking(int n, int k, int start){
        if(sum == n && sumRes.size() == k){
            result.add(new ArrayList<>(sumRes));
            return;
        }

        for(int i = start;i <= 9;i++){
            sumRes.add(i);
            sum += i;
            backtracking(n,k,i+1);
            sum -= i;
            sumRes.removeLast();
        }
    }
}
```



### 二刷

```java
class Solution {
    List<List<Integer>> res = new ArrayList<>();
    List<Integer> path = new ArrayList<>();
    int sum = 0;

    public List<List<Integer>> combinationSum3(int k, int n) {
        backtracking(k,n,1);
        return res;
    }

    public void backtracking(int k, int n, int index){
        if(path.size() == k){
            if(sum == n){
                res.add(new ArrayList<>(path));
            }
            return;
        }

        for(int i = index; i <= 9 - (k - path.size()) + 1; i++){
            path.add(i);
            sum += i;
            backtracking(k,n,i + 1);
            sum -= i;
            path.removeLast();
        }
    }
}
```





### 答案代码

```java
class Solution {
	List<List<Integer>> result = new ArrayList<>();
	LinkedList<Integer> path = new LinkedList<>();

	public List<List<Integer>> combinationSum3(int k, int n) {
		backTracking(n, k, 1, 0);
		return result;
	}

	private void backTracking(int targetSum, int k, int startIndex, int sum) {
		// 减枝
		if (sum > targetSum) {
			return;
		}

		if (path.size() == k) {
			if (sum == targetSum) result.add(new ArrayList<>(path));
			return;
		}

		// 减枝 9 - (k - path.size()) + 1
		for (int i = startIndex; i <= 9 - (k - path.size()) + 1; i++) {
			path.add(i);
			sum += i;
			backTracking(targetSum, k, i + 1, sum);
			//回溯
			path.removeLast();
			//回溯
			sum -= i;
		}
	}
}

// 上面剪枝 i <= 9 - (k - path.size()) + 1; 如果还是不清楚
// 也可以改为 if (path.size() > k) return; 执行效率上是一样的
class Solution {
    LinkedList<Integer> path = new LinkedList<>();
    List<List<Integer>> ans = new ArrayList<>();
    public List<List<Integer>> combinationSum3(int k, int n) {
        build(k, n, 1, 0);
        return ans;
    }

    private void build(int k, int n, int startIndex, int sum) {

        if (sum > n) return;

        if (path.size() > k) return;

        if (sum == n && path.size() == k) {
            ans.add(new ArrayList<>(path));
            return;
        }

        for(int i = startIndex; i <= 9; i++) {
            path.add(i);
            sum += i;
            build(k, n, i + 1, sum);
            sum -= i;
            path.removeLast();
        }
    }
}
```





##四、电话号码的字母组合

### 题目

![](https://raw.githubusercontent.com/vankykoo/javaStudy/e7418312d081de9088cf2abc95094cdee49051f0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E9%A2%98%E7%9B%AE/backtracking/3.png)

### 思路

![](https://code-thinking-1253855093.file.myqcloud.com/pics/20201123200304469.png)

* 使用回溯算法
  * 回溯函数的参数
    * 字符串数组，字符串数组下标的数组，字符串数组下标的数组的坐标
  * 终止条件
    * 如果**StringBuilder的长度**等于**字符串数组下标的数组的长度**，就返回
  * 回溯逻辑
    * 找到对应的字符集，用for循环遍历，加入到StringBuilder中，然后调用回溯函数，结束后删除StringBuilder的最后一个字符。

### 代码

```java
//我的代码
class Solution {
    List<String> result = new ArrayList<>();
    StringBuilder sb = new StringBuilder();

    public List<String> letterCombinations(String digits) {
        if(digits.length() == 0){
            return result;
        }
        String[] arr = {"","","abc","def","ghi","jkl","mno","pqrs","tuv","wxyz"};
        int[] indexArr = new int[digits.length()];
        for(int j = 0; j < digits.length();j++){
            indexArr[j] = digits.charAt(j) - '0';
        }

        backtracking2(arr,indexArr,0);

        return result;
    }

    public void backtracking2(String[] strArr,int[] strIndexArr,int numIndex){
        if(sb.length() == strIndexArr.length){
            result.add(sb.toString());
            return;
        }

        String s = strArr[strIndexArr[numIndex]];
        for(int j = 0;j < s.length();j++){
            sb.append(s.charAt(j));
            backtracking2(strArr,strIndexArr,numIndex + 1);
            sb.deleteCharAt(sb.length() - 1);
        }
    }
}
```



### 二刷

```java
class Solution {
    char[][] arr = {{},{},{'a','b','c'},{'d','e','f'},
                    {'g','h','i'},{'j','k','l'},{'m','n','o'},
                    {'p','q','r','s'},{'t','u','v'},{'w','x','y','z'}};

    List<String> res = new ArrayList<>();
    StringBuilder sb = new StringBuilder();

    public List<String> letterCombinations(String digits) {
        int len = digits.length();
        if(len == 0){
            return res;
        }
        
        int[] digitsArr = new int[len];
        for(int i = 0; i < len; i++){
            digitsArr[i] = digits.charAt(i) - '0';
        }

        backtracking(digitsArr, len, 0);

        return res;
    }

    public void backtracking(int[] digitsArr, int n, int index){
        if(sb.length() == n){
            res.add(sb.toString());
            return;
        }

        //两层for循环
        //1.遍历digits  2.遍历数字对应的字母
        for(int i = index; i < n; i++){
            for(int j = 0; j < arr[digitsArr[i]].length; j++){
                sb.append(arr[digitsArr[i]][j]);
                backtracking(digitsArr, n, i + 1);
                sb.deleteCharAt(sb.length() - 1);
            }
        }
    }
}
```





```java
//答案代码
class Solution {

    //设置全局列表存储最后的结果
    List<String> list = new ArrayList<>();

    public List<String> letterCombinations(String digits) {
        if (digits == null || digits.length() == 0) {
            return list;
        }
        //初始对应所有的数字，为了直接对应2-9，新增了两个无效的字符串""
        String[] numString = {"", "", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"};
        //迭代处理
        backTracking(digits, numString, 0);
        return list;

    }

    //每次迭代获取一个字符串，所以会设计大量的字符串拼接，所以这里选择更为高效的 StringBuild
    StringBuilder temp = new StringBuilder();

    //比如digits如果为"23",num 为0，则str表示2对应的 abc
    public void backTracking(String digits, String[] numString, int num) {
        //遍历全部一次记录一次得到的字符串
        if (num == digits.length()) {
            list.add(temp.toString());
            return;
        }
        //str 表示当前num对应的字符串
        String str = numString[digits.charAt(num) - '0'];
        for (int i = 0; i < str.length(); i++) {
            temp.append(str.charAt(i));
            //c
            backTracking(digits, numString, num + 1);
            //剔除末尾的继续尝试
            temp.deleteCharAt(temp.length() - 1);
        }
    }
}
```





## 五、组合总和

### 题目

![](https://raw.githubusercontent.com/vankykoo/javaStudy/629ee05839134403f1eee1a1dceab43a0fcf1139/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E9%A2%98%E7%9B%AE/backtracking/4.png)

### 思路

![](https://code-thinking-1253855093.file.myqcloud.com/pics/20201223170730367-20230310135337214.png)

* 模板：

* ```java
  void backtracking(参数){
    if(终止条件){
      存放结果;
      return;
    }
    
    for(选择：本层集合中元素（树中节点孩子的数量就是集合的大小）){
      处理节点;
      backtracking(路径，选择列表);//递归
      回溯，撤销处理结果
    }
  }
  ```

  * 终止条件：
    * ①如果sum已经大于target，直接return。
    * ②如果sum== target，加入到结果集中。
  * 处理节点：将节点加入到sumRes集合中。sum += array[i]。
  * backtracking后，sum -= array[i]
  * 撤销处理结果：将sumRes最后一位删除。
  * ※for循环的初始值为当前遍历索引start，backtracking时for循环的索引只能大于等于start



### 代码

```java
class Solution {

    int sum = 0;
    List<List<Integer>> result = new ArrayList<>();
    LinkedList<Integer> sumRes = new LinkedList<>();

    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        backtracking(target,candidates,0);
        return result;
    }

    public void backtracking(int target,int[] array, int start){
        if(sum > target){
            return;
        }

        if(sum == target){
            result.add(new ArrayList<>(sumRes));
            return;
        }

        for(int i = start;i < array.length;i++){
            sumRes.add(array[i]);
            sum += array[i];
            backtracking(target,array,i);
            sum -= array[i];
            sumRes.removeLast();
        }
    }
}
```



### 二刷

```java
class Solution {

    int sum = 0;
    List<Integer> path = new ArrayList<>();
    List<List<Integer>> res = new ArrayList<>();

    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        backtracking(candidates, target, 0);

        return res;
    }

    public void backtracking(int[] candidates, int target, int index){
        if(sum == target){
            res.add(new ArrayList(path));
            return;
        }else if(sum > target){
            return;
        }

        for(int i = index; i < candidates.length; i++){
            path.add(candidates[i]);
            sum += candidates[i];
            backtracking(candidates, target, i);
            sum -= candidates[i];
            path.removeLast();
        }
    }
}
```





### 答案代码

优化：

* 先对数组进行排序
* 如果 sum + candidates[i] > target 就终止遍历，在for循环内判断。

```java
// 剪枝优化
class Solution {
    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        List<List<Integer>> res = new ArrayList<>();
        Arrays.sort(candidates); // 先进行排序
        backtracking(res, new ArrayList<>(), candidates, target, 0, 0);
        return res;
    }

    public void backtracking(List<List<Integer>> res, List<Integer> path, int[] candidates, int target, int sum, int idx) {
        // 找到了数字和为 target 的组合
        if (sum == target) {
            res.add(new ArrayList<>(path));
            return;
        }

        for (int i = idx; i < candidates.length; i++) {
            // 如果 sum + candidates[i] > target 就终止遍历
            if (sum + candidates[i] > target) break;
            path.add(candidates[i]);
            backtracking(res, path, candidates, target, sum + candidates[i], i);
            path.remove(path.size() - 1); // 回溯，移除路径 path 最后一个元素
        }
    }
}
```





## 六、组合总和Ⅱ

### 题目

![](https://raw.githubusercontent.com/vankykoo/javaStudy/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E9%A2%98%E7%9B%AE/backtracking/5.png)

### 思路

* 和上一题有一点区别，这题的每个数字只能用一次，且会出现重复数字，且不能出现重复组合。

* 解法主要难在去重上：

  * 需要在for循环中加上一个判断：在每一层上进行去重。

* 核心代码：

  ```java
  if(i > start && candidates[i] == candidates[i - 1]) {
      continue;
  }
  ```

  * 不能使用 `i > 0`，`i > 0`说明每个数字在组合内不能重复。

![](https://code-thinking-1253855093.file.myqcloud.com/pics/20221021163812.png)



### 代码

```java
class Solution {

    List<List<Integer>> result = new ArrayList<>();
    LinkedList<Integer> sumRes = new LinkedList<>();
    int sum = 0;

    public List<List<Integer>> combinationSum2(int[] candidates, int target) {
        Arrays.sort(candidates);
        backtracking(candidates,target,0);
        return result;
    }

    public void backtracking(int[] candidates, int target, int start){
        if(sum > target){
            return;
        }

        if(sum == target){
            result.add(new ArrayList<>(sumRes));
            return;
        }

        for(int i = start;i < candidates.length;i++){
            if(i > start && candidates[i] == candidates[i - 1]) {
                continue;
            }
            sumRes.add(candidates[i]);
            sum += candidates[i];
            backtracking(candidates,target,i + 1);
            sum -= candidates[i];
            sumRes.removeLast();
        }
    }

}
```





### 二刷

```java
class Solution {

    List<List<Integer>> result = new ArrayList<>();
    LinkedList<Integer> path = new LinkedList<>();
    int sum = 0;

    public List<List<Integer>> combinationSum2(int[] candidates, int target) {
        Arrays.sort(candidates);
        backtracking(candidates,target,0);
        return result;
    }

    public void backtracking(int[] candidates, int target, int start){
        if(target == sum){
            result.add(new ArrayList<>(path));
            return;
        }

        for(int i = start; i < candidates.length; i++){
            //剪枝1：避免重复解
            if(i > start && candidates[i] == candidates[i-1]){
                continue;
            }
            //剪枝2：如果已经大于target，就不用继续了
            if(sum + candidates[i] > target){
                break;
            }

            path.add(candidates[i]);
            sum += candidates[i];
            backtracking(candidates, target, i + 1);
            sum -= candidates[i];
            path.removeLast();

        }

    }

}
```





### 答案代码

```java
class Solution {
  LinkedList<Integer> path = new LinkedList<>();
  List<List<Integer>> ans = new ArrayList<>();
  boolean[] used;
  int sum = 0;

  public List<List<Integer>> combinationSum2(int[] candidates, int target) {
    used = new boolean[candidates.length];
    // 加标志数组，用来辅助判断同层节点是否已经遍历
    Arrays.fill(used, false);
    // 为了将重复的数字都放到一起，所以先进行排序
    Arrays.sort(candidates);
    backTracking(candidates, target, 0);
    return ans;
  }

  private void backTracking(int[] candidates, int target, int startIndex) {
    if (sum == target) {
      ans.add(new ArrayList(path));
    }
    for (int i = startIndex; i < candidates.length; i++) {
      if (sum + candidates[i] > target) {
        break;
      }
      // 出现重复节点，同层的第一个节点已经被访问过，所以直接跳过
      if (i > 0 && candidates[i] == candidates[i - 1] && !used[i - 1]) {
        continue;
      }
      used[i] = true;
      sum += candidates[i];
      path.add(candidates[i]);
      // 每个节点仅能选择一次，所以从下一位开始
      backTracking(candidates, target, i + 1);
      used[i] = false;
      sum -= candidates[i];
      path.removeLast();
    }
  }
}
```





## 七、分隔回文串（难）

### 题目

![](https://raw.githubusercontent.com/vankykoo/javaStudy/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E9%A2%98%E7%9B%AE/backtracking/6.png)





### 思路

![](https://code-thinking.cdn.bcebos.com/pics/131.%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2.jpg)

* startIndex就是分割线
* 加入到子结果集的条件是子串满足回文串。
* 判断子串是回文串方法：双指针法

### 代码

```java
class Solution {
    List<List<String>> lists = new ArrayList<>();
    Deque<String> deque = new LinkedList<>();

    public List<List<String>> partition(String s) {
        backTracking(s, 0);
        return lists;
    }

    private void backTracking(String s, int startIndex) {
        //如果起始位置大于s的大小，说明找到了一组分割方案
        if (startIndex >= s.length()) {
            lists.add(new ArrayList(deque));
            return;
        }
        for (int i = startIndex; i < s.length(); i++) {
            //如果是回文子串，则记录
            if (isPalindrome(s, startIndex, i)) {
                String str = s.substring(startIndex, i + 1);
                deque.addLast(str);
            } else {
                continue;
            }
            //起始位置后移，保证不重复
            backTracking(s, i + 1);
            deque.removeLast();
        }
    }
    //判断是否是回文串
    private boolean isPalindrome(String s, int startIndex, int end) {
        for (int i = startIndex, j = end; i < j; i++, j--) {
            if (s.charAt(i) != s.charAt(j)) {
                return false;
            }
        }
        return true;
    }
}
```







## 八、复原IP地址

### 题目

![](https://raw.githubusercontent.com/vankykoo/javaStudy/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E9%A2%98%E7%9B%AE/backtracking/7.png)



### 思路

* 整体思路和上一题差不多
* 不同的就是在判断每一个区间是否符合标准
  * 标准：在0到255之间，如果是两位数及以上，不能以0开头
* 使用StringBuilder来分割字符串，可以灵活地增删符号。
* 定义一个全局变量pointNum记录分隔符【.】的数量。





### 我的代码

还可以精简一点的

```java
class Solution {

    List<String> result = new ArrayList<>();
    StringBuilder sb = new StringBuilder();
    int pointNum = 0;

    public List<String> restoreIpAddresses(String s) {
        sb.append(s);
        backtracking(s.length(),0,1);
        return result;
    }

    public void backtracking(int sLength, int startIndex, int lastIndex){
        if(pointNum == 3){
            //处理最后一个数字
            int index = sb.lastIndexOf(".");
            String s = sb.substring(index + 1,sb.length()).toString();
            if(s.length() > 1 && s.charAt(0) == '0') return;    //防止最后一个数0开头
            if(s != "" && s.length() < 4){  //s.length() < 4 防止s转换出来的数字过大
                int num = Integer.parseInt(s);
                if(num <= 255 && num >= 0){
                    result.add(sb.toString());
                }
            }
            return;
        }

        for(int i = lastIndex;i <= sb.length();i++){
            //判断数字是否满足
            String s = sb.substring(startIndex,i).toString();
            if(s.charAt(0) == '0' && s.length() > 1){   //防止数字零开头
                return;
            }
            sb.insert(i,".");
            int num = Integer.parseInt(s);
            if(num < 0 || num > 255){
                sb.deleteCharAt(sb.lastIndexOf("."));
                return;
            }
            pointNum++;
            backtracking(sLength, i+1, i + 2);
            pointNum--;
            if(sb.lastIndexOf(".") != -1){
                sb.deleteCharAt(sb.lastIndexOf("."));
            }
        }
    }


}
```





##九、子集

### 题目

![](https://raw.githubusercontent.com/vankykoo/javaStudy/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E9%A2%98%E7%9B%AE/backtracking/8.png)



### 思路

* 每一层都加入到结果集中
* 如果到末尾就return



###代码

```java
class Solution {

    List<List<Integer>> result = new ArrayList<>();
    LinkedList<Integer> path = new LinkedList<>();

    public List<List<Integer>> subsets(int[] nums) {
        backtracking(nums,0);
        
        return result;
    }

    public void backtracking(int[] nums, int startIndex){
        result.add(new ArrayList<>(path));
        if(startIndex == nums.length) return;

        for(int i = startIndex;i < nums.length;i++){
            path.add(nums[i]);
            backtracking(nums, i + 1);
            path.removeLast();
        }

    }
}
```





##十、子集Ⅱ

### 题目

![](https://raw.githubusercontent.com/vankykoo/javaStudy/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E9%A2%98%E7%9B%AE/backtracking/9.png)



###思路

和上一题比，多了对原数组进行排序，然后每一层需要去重

![](https://code-thinking-1253855093.file.myqcloud.com/pics/20201124195411977.png)



### 代码

```java
class Solution {

    LinkedList<Integer> path = new LinkedList<>();
    List<List<Integer>> result = new ArrayList<>();


    public List<List<Integer>> subsetsWithDup(int[] nums) {
        Arrays.sort(nums);//排序
        backtracking(nums,0);
        return result;
    }

    public void backtracking(int[] nums, int startIndex){
        result.add(new ArrayList<>(path));

        for(int i = startIndex;i < nums.length;i++){
          //去重
            if(i > startIndex && nums[i] == nums[i - 1]){
                continue;
            }
            path.add(nums[i]);
            backtracking(nums,i + 1);
            path.removeLast();
        }
    }


}
```





## 十一、递增子序列

### 题目

* 序列数量大于等于2
* 序列元素可以重复，但是必须递增

![](https://raw.githubusercontent.com/vankykoo/javaStudy/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E9%A2%98%E7%9B%AE/backtracking/10.png)

### 思路

![](https://code-thinking-1253855093.file.myqcloud.com/pics/20201124200229824-20230310131640070.png)

**同一父节点下的同层上使用过的元素就不能再使用了**



### 代码

```java
class Solution {

    List<List<Integer>> result = new ArrayList<>();
    LinkedList<Integer> path = new LinkedList<>();

    public List<List<Integer>> findSubsequences(int[] nums) {
        backtracking(nums, 0);
        return result;
    }

    public void backtracking(int[] nums, int startIndex){
        if(path.size() >= 2){
            result.add(new ArrayList<>(path));
        }

        HashSet<Integer> hs = new HashSet<>();
        for(int i = startIndex;i < nums.length; i++){

            //控制顺序和去重
            if(path.size() > 0 && nums[i] < path.getLast() || hs.contains(nums[i])){
                continue;
            }

            hs.add(nums[i]);
            path.add(nums[i]);
            backtracking(nums, i + 1);
            path.removeLast();
        }
    }
}
```





## 十二、全排列

### 题目

![](https://raw.githubusercontent.com/vankykoo/javaStudy/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E9%A2%98%E7%9B%AE/backtracking/11.png)



### 思路

* 使用boolean数组，用过的赋值为true，没用过的赋值为false。
* ![](https://code-thinking-1253855093.file.myqcloud.com/pics/20201209174225145.png)



### 我的代码

```java
class Solution {

    List<List<Integer>> result = new ArrayList<>();
    LinkedList<Integer> path = new LinkedList<>();
    boolean[] usedArray;

    public List<List<Integer>> permute(int[] nums) {
        usedArray = new boolean[nums.length];
        backtracking(nums);
        return result;
    }

    public void backtracking(int[] nums){
        if(path.size() == nums.length){
            result.add(new ArrayList(path));
            return;
        }

        for(int i=0;i < nums.length;i++){
            if(usedArray[i] == true){
                continue;
            }
            usedArray[i] = true;
            path.add(nums[i]);
            backtracking(nums);
            path.removeLast();
            usedArray[i] = false;
        }

    }
}
```



## 十三、全排列Ⅱ

### 题目





### 思路

主要是在去重：（排序后）

* 如果上一个元素等于当前元素，且上一个元素已经被用过，就跳过。
* 如果当前元素已经被用过，也跳过。

![](https://code-thinking-1253855093.file.myqcloud.com/pics/20201124201331223.png)



### 我的代码

```java
class Solution {

    List<List<Integer>> result = new ArrayList<>();
    LinkedList<Integer> path = new LinkedList<>();
    boolean[] usedArray;

    public List<List<Integer>> permuteUnique(int[] nums) {
        Arrays.sort(nums);
        usedArray = new boolean[nums.length];
        backtracking(nums);
        
        return result;
    }

    public void backtracking(int[] nums){
        if(path.size() == nums.length){
            result.add(new ArrayList(path));
            return;
        }

        for(int i=0;i < nums.length;i++){
            if( i > 0 && nums[i] == nums[i - 1] && usedArray[i - 1] == true || usedArray[i] == true){
                continue;
            }
            usedArray[i] = true;
            path.add(nums[i]);
            backtracking(nums);
            path.removeLast();
            usedArray[i] = false;
        }
    }
}
```





## 十四、重新安排行程

### 题目

![](https://raw.githubusercontent.com/vankykoo/javaStudy/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E9%A2%98%E7%9B%AE/backtracking/13.png)

* 需要排序
* 每张票都要用上

### 思路

![](https://code-thinking-1253855093.file.myqcloud.com/pics/2020111518065555-20230310121240991.png)





### 代码

* 这次为什么是boolean呢？

  因为我们只需要找到一个行程，就是在树形结构中唯一的一条通向叶子节点的路线，

```java
class Solution {

    private LinkedList<String> res;
    private LinkedList<String> path = new LinkedList<>();

    public List<String> findItinerary(List<List<String>> tickets) {
      //对每张票的目的地进行排序
        Collections.sort(tickets,(a, b) -> a.get(1).compareTo(b.get(1)));
        path.add("JFK");
      //“使用过”数组
        boolean[] used = new boolean[tickets.size()];
        backtracking((ArrayList)tickets, used);
        return res;
    }

    public boolean backtracking(ArrayList<List<String>> tickets, boolean[] used){
        if(path.size() == tickets.size() + 1){
            res = new LinkedList(path);
            return true;
        }

        for(int i = 0; i < tickets.size(); i++){
            if(!used[i] && tickets.get(i).get(0).equals(path.getLast())) {
              //如果没使用过此票，而且出发地等于path最后的目的地
              //把此票的目的地放入path
                path.add(tickets.get(i).get(1));
                used[i] = true;

                if(backtracking(tickets, used)){
                    return true;
                }

                used[i] = false;
                path.removeLast();
            }
        }
        return false;
    }
    
}
```





## 十五、N皇后

### 题目

![](https://raw.githubusercontent.com/vankykoo/javaStudy/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E9%A2%98%E7%9B%AE/backtracking/14.png)

### 思路

* 使用boolean数组来表示哪些路径可以使用。

* 每一层的used数组应该不同，所有需要创建新数组并使用深拷贝来传值

* > 深拷贝和浅拷贝是编程中常见的两种复制对象的方式，它们的主要区别在于复制的深度不同。
  >
  > **浅拷贝**只会复制对象的最外层，创建一个新对象，但是新对象的属性引用的是原对象属性的内存地址。也就是说，如果原对象中的属性值是基本类型，那么就会直接复制值；如果属性值是引用类型（如数组、对象等），那么就会复制内存地址，因此原对象和新对象**会共享该属性**。
  >
  > **深拷贝**则会递归复制对象的所有层次，也就是说，无论原对象的属性值是基本类型还是引用类型，深拷贝都会创建一个全新的副本，新对象和原对象**不共享任何属性**。
  >
  > 总结一下，浅拷贝只复制了引用，而不复制引用指向的内容。深拷贝则会递归地复制所有内容。因此，在处理包含引用类型属性的对象时，我们需要根据实际需求选择使用浅拷贝还是深拷贝。



### 我的代码

```java
class Solution {

    List<List<String>> result = new ArrayList<>();
    LinkedList<String> path = new LinkedList<>();
    StringBuilder sb = new StringBuilder();

    public List<List<String>> solveNQueens(int n) {
        boolean[][] used = new boolean[n][n];
        for(int i=0;i<n;i++){
            sb.append(".");
        }
        backtracking(0,n,used);

        return result;
    }

    public void backtracking(int row,int n,boolean[][] used){
        if(path.size() == n){
            result.add(new ArrayList(path));
            return;
        }

        for(int i = 0;i < n;i++){
            if(used[row][i] == true){
                continue;
            }
            //放字符
            path.add(sb.replace(i,i+1,"Q").toString());
            sb.replace(i,i+1,".");
            backtracking(row + 1,n,puton(row,i,n,used));
            path.removeLast();
        }
    }

    public boolean[][] puton(int row, int column, int n, boolean[][] used){
      //深拷贝
        int i,j;
        boolean[][] usedArray = new boolean[n][n];
        for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
                usedArray[i][j] = used[i][j];
            }
        }

      //向右
        for(i = 0; i < n; i++){
            usedArray[row][i] = true;
        }

      //向左
        for(j = 0; j < n; j++){
            usedArray[j][column] = true;
        }

        //向左上
        for(i = row,j = column ; i >= 0 && j >= 0; i--,j--){
            usedArray[i][j] = true;
        }

        //向右上
        for(i = row,j = column ; i >= 0 && j < n; i--,j++){
            usedArray[i][j] = true;
        }

        //向左下
        for(i = row,j = column ; i < n && j >= 0; i++,j--){
            usedArray[i][j] = true;
        }

        //向右下
        for(i = row,j = column ; i < n && j < n; i++,j++){
            usedArray[i][j] = true;
        }

        return usedArray;
    }
}
```





## 十六、解数独

### 题目

![](https://raw.githubusercontent.com/vankykoo/javaStudy/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E9%A2%98%E7%9B%AE/backtracking/15.png)





### 思路

* backtracking需要返回boolean类型
  * 只要找到一个符合条件就立刻返回，相当于找从根结点到叶子节点一条唯一路径，
* 两个for循环
  * 一个遍历行，一个遍历列
* **注意这里return false的地方，这里放return false 是有讲究的**。
  * 因为如果一行一列确定下来了，这里尝试了9个数都不行，说明这个棋盘找不到解决数独问题的解！那么会直接返回， **这也就是为什么没有终止条件也不会永远填不满棋盘而无限递归下去！**



### 我的代码

```java
class Solution {
    public void solveSudoku(char[][] board) {
        solveSudokuHelper(board);
    }

    private boolean solveSudokuHelper(char[][] board){
        //「一个for循环遍历棋盘的行，一个for循环遍历棋盘的列，
        // 一行一列确定下来之后，递归遍历这个位置放9个数字的可能性！」
        for (int i = 0; i < 9; i++){ // 遍历行
            for (int j = 0; j < 9; j++){ // 遍历列
                if (board[i][j] != '.'){ // 跳过原始数字
                    continue;
                }
                for (char k = '1'; k <= '9'; k++){ // (i, j) 这个位置放k是否合适
                    if (isValidSudoku(i, j, k, board)){
                        board[i][j] = k;
                        if (solveSudokuHelper(board)){ // 如果找到合适一组立刻返回
                            return true;
                        }
                        board[i][j] = '.';
                    }
                }
                // 9个数都试完了，都不行，那么就返回false
                return false;
                // 因为如果一行一列确定下来了，这里尝试了9个数都不行，说明这个棋盘找不到解决数独问题的解！
                // 那么会直接返回， 「这也就是为什么没有终止条件也不会永远填不满棋盘而无限递归下去！」
            }
        }
        // 遍历完没有返回false，说明找到了合适棋盘位置了
        return true;
    }

    /**
     * 判断棋盘是否合法有如下三个维度:
     *     同行是否重复
     *     同列是否重复
     *     9宫格里是否重复
     */
    private boolean isValidSudoku(int row, int col, char val, char[][] board){
        // 同行是否重复
        for (int i = 0; i < 9; i++){
            if (board[row][i] == val){
                return false;
            }
        }
        // 同列是否重复
        for (int j = 0; j < 9; j++){
            if (board[j][col] == val){
                return false;
            }
        }
        // 9宫格里是否重复
        int startRow = (row / 3) * 3;
        int startCol = (col / 3) * 3;
        for (int i = startRow; i < startRow + 3; i++){
            for (int j = startCol; j < startCol + 3; j++){
                if (board[i][j] == val){
                    return false;
                }
            }
        }
        return true;
    }
}
```



















































































































