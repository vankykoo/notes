# 数组

## 一、二分法查找

题目：

![](https://pic-1317004580.cos.ap-guangzhou.myqcloud.com/%E6%96%B0%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E7%BB%84/1.png)



类型①：左闭右闭区间，[left,right]。

![](https://code-thinking-1253855093.file.myqcloud.com/pics/20210311153055723.jpg)

```java
class Solution {
    public int search(int[] nums, int target) {
        int right = nums.length - 1, left = 0;
        while(right >= left){
            int middle = (left + right) / 2;
            if(nums[middle] == target)
                return middle;
            else if(nums[middle] > target)
                right = middle - 1;
            else 
                left = middle + 1;
        }
        return -1;
    }
}
```

类型②：左闭右开，[left,right)

![](https://code-thinking-1253855093.file.myqcloud.com/pics/20210311153123632.jpg)

```java
class Solution {
    public int search(int[] nums, int target) {
        int right = nums.length, left = 0;
      //变化一：right不能等于left，没有意义
        while(right > left){
            int middle = (left + right) / 2;
            if(nums[middle] == target)
                return middle;
            else if(nums[middle] > target)
     //变化二：直接让right等于middle
                right = middle;
            else 
                left = middle + 1;
        }
        return -1;
    }
}
```



## 二、移除元素

题目：![](https://pic-1317004580.cos.ap-guangzhou.myqcloud.com/%E6%96%B0%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E7%BB%84/2.png)

![](https://pic-1317004580.cos.ap-guangzhou.myqcloud.com/%E6%96%B0%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E7%BB%84/3.png)

解法①：使用快慢指针

双指针法（快慢指针法）： **通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。**

定义快慢指针

- 快指针：寻找新数组的元素 ，新数组就是不含有目标元素的数组
- 慢指针：指向更新 新数组下标的位置![](https://code-thinking.cdn.bcebos.com/gifs/27.%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0-%E5%8F%8C%E6%8C%87%E9%92%88%E6%B3%95.gif)

```java
class Solution {
    public int removeElement(int[] nums, int val) {
        // 快慢指针
        int slowIndex = 0;
        for (int fastIndex = 0; fastIndex < nums.length; fastIndex++) {
            if (nums[fastIndex] != val) {
                nums[slowIndex] = nums[fastIndex];
                slowIndex++;
            }
        }
        return slowIndex;
    }
}
```



解放②：定义两个指针，一个从左往右，一个从右往左；右边的找是val值的坐标，左边的找不是val值的坐标，然后交换。

```java
//相向指针
class Solution {
    public int removeElement(int[] nums, int val) {
        int left = 0,right = nums.length - 1;
        while(left < right){
          //如果满足条件，交换
            if(nums[left] == val && nums[right] != val){
                int temp = nums[left];
                nums[left] = nums[right];
                nums[right] = temp;
            }
          //左边的找是val值的坐标
            while(nums[left] != val && left < right){
                left++;
            }
          //右边的找不是val值的坐标
            while(nums[right] == val && left < right){
                right--;
            }
        }
		//最后left=right，随便返回一个即可
        return right;
    }
}
```





##三、有序数组的平方

题目：![](https://pic-1317004580.cos.ap-guangzhou.myqcloud.com/%E6%96%B0%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E7%BB%84/4.png)



`思路：使用双指针。`

`首先创建一个新数组，两个指针分别指向传入数组的首尾。`

`通过比较，平方较大的先传入新数组，从新数组后面开始传，传后移动指针即可。`

![](https://code-thinking.cdn.bcebos.com/gifs/977.%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9.gif)

```java
class Solution {
    public int[] sortedSquares(int[] nums) {
        int[] array = new int[nums.length];
        int index = nums.length - 1;//指向新数组尾
        int right = nums.length - 1, left = 0;
        while(right >= left){
            if(nums[right] * nums[right] > nums[left] * nums[left]){
                array[index--] = nums[right] * nums[right];
                right--;
            }else{
                array[index--] = nums[left] * nums[left];
                left++;
            }
        }
        return array;
    }
}
```





## 四、长度最小的子数组

题目：![](https://pic-1317004580.cos.ap-guangzhou.myqcloud.com/%E6%96%B0%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E7%BB%84/5.png)

------

使用滑动窗口的方法：

如果总和大于target，移动i；如果总和小于target，移动j。

![](http://code-thinking.cdn.bcebos.com/gifs/209.%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84.gif)

------

**我的代码：**

```java
class Solution {
    public int minSubArrayLen(int target, int[] nums) {
        int right = 0,left = 0;
        int minLength = 0;
        int sum = nums[left];
        while(right < nums.length){
            if(sum >= target){
                minLength = right - left + 1;
                sum -= nums[left];
                left++;
            }else if(right == nums.length - 1 && sum < target){
                break;
            }else{
                right++;
                sum += nums[right];
            }
        }
        return minLength;
    }
}
//时间复杂度为n
```

**存在的问题：**

* 变量 `minLength` 应该初始化为 `Integer.MAX_VALUE` 而不是 `0`，因为如果在整个循环过程中都没有找到满足条件的子数组，那么应该返回 `0` 而不是错误的最小长度。
* 在更新 `minLength` 的值时，应该使用 `minLength = Math.min(minLength, right - left + 1);` 而不是直接赋值，以便在整个循环过程中跟踪所有满足条件的子数组的最小长度。
* 在返回结果之前，应该检查 `minLength` 是否等于 `Integer.MAX_VALUE`，如果是，则返回 `0`，否则返回 `minLength` 的值。


------

**官方答案思路：**

代码中定义了两个指针 `left` 和 `right`，分别表示滑动窗口的左右边界。变量 `minLength` 用于跟踪所有满足条件的子数组的最小长度，初始值为 `Integer.MAX_VALUE`。变量 `sum` 表示滑动窗口中所有元素的和。

在循环过程中，指针 `right` 每次向右移动一位，并将 `nums[right]` 的值累加到 `sum` 中。然后，如果 `sum >= target`，则更新 `minLength` 的值，并将指针 `left` 向右移动一位，同时从 `sum` 中减去 `nums[left]` 的值。这个过程会一直重复，直到 `sum < target`。

当指针 `right` 移动到数组末尾时，循环结束。最后，检查 `minLength` 是否等于 `Integer.MAX_VALUE`，如果是，则返回 `0`，否则返回 `minLength` 的值。

这种方法的时间复杂度为 O(n)，其中 n 是数组 `nums` 的长度。

```java
class Solution {
    public int minSubArrayLen(int target, int[] nums) {
        int right = 0, left = 0;
        int minLength = Integer.MAX_VALUE;
        int sum = 0;
        while (right < nums.length) {
            sum += nums[right];
            while (sum >= target) {
                minLength = Math.min(minLength, right - left + 1);
                sum -= nums[left];
                left++;
            }
            right++;
        }
        return minLength == Integer.MAX_VALUE ? 0 : minLength;
    }
}
```



## 五、螺旋矩阵Ⅱ

题目：

![](https://pic-1317004580.cos.ap-guangzhou.myqcloud.com/%E6%96%B0%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E7%BB%84/6.png)

------

思路：就是向右->向下->向左->向上->向右......设置直走的边界，每次走完要更新边界即可。



我的代码：

```java
class Solution {
    public int[][] generateMatrix(int n) {
        int toRight = n - 1;//向右走的边界
        int toDown = n - 1;//向下走的边界
        int toLeft = 0;//向左走的边界
        int toUp = 1;//向上走的边界
        int row = 0, col = 0;//数组坐标
        int round = 0;//直走了几次
        int result = 2 * n - 1;//需要直走几次
        int num = 1;
        int[][] arr = new int[n][n];
        while(round < result){
            //向右
            while(col < toRight){
                arr[row][col++] = num++;
            }
            round++;//直走次数增加
            toRight--;//直走边界改变

            //向下
            while(row < toDown){
                arr[row++][col] = num++;
            }
            round++;
            toDown--;

            //向左
            while(col > toLeft){
                arr[row][col--] = num++;
            }
            round++;
            toLeft++;

            //向上
            while(row > toUp){
                arr[row--][col] = num++;
            }
            round++;
            toUp++;
        }
        //最后的数要单独赋值？？？为什么呢
        if(n % 2 == 0){
            row = (n - 1) / 2;
            col = (n - 3) / 2;
            arr[row][col] = n * n;
        }else{
            row = (n - 1) / 2;
            col = (n - 1) / 2;
            arr[row][col] = n * n;
        }

        return arr;
    }
}
```

------

答案代码：

```java
class Solution {
    public int[][] generateMatrix(int n) {
        int loop = 0;  // 控制循环次数
        int[][] res = new int[n][n];
        int start = 0;  // 每次循环的开始点(start, start)
        int count = 1;  // 定义填充数字
        int i, j;

        while (loop++ < n / 2) { // 判断边界后，loop从1开始
            // 模拟上侧从左到右
            for (j = start; j < n - loop; j++) {
                res[start][j] = count++;
            }

            // 模拟右侧从上到下
            for (i = start; i < n - loop; i++) {
                res[i][j] = count++;
            }

            // 模拟下侧从右到左
            for (; j >= loop; j--) {
                res[i][j] = count++;
            }

            // 模拟左侧从下到上
            for (; i >= loop; i--) {
                res[i][j] = count++;
            }
            start++;
        }

        if (n % 2 == 1) {
            res[start][start] = count;
        }

        return res;
    }
}
```



## 六、总结

![](https://code-thinking-1253855093.file.myqcloud.com/pics/%E6%95%B0%E7%BB%84%E6%80%BB%E7%BB%93.png)







