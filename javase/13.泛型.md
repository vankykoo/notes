# 泛型

## 一、泛型的基础语法

###1）泛型介绍

①泛型又称参数化类型，是jdk5.0出现的新特性，解决数据类型的安全性问题。

②在类声明或实例化时只要指定好需要的具体的类型即可。

③Java泛型可以保证如果程序在编译时没有发出警告，运行时就不会产生ClassCastException异常，同时使代码更加简洁、健壮。

④泛型的作用：可以在类声明时通过一个标识表示类中某个属性的类型，或者是某个方法的返回值的类型，或者是参数类型。

```java
//main中
{
  Person<String> person = new Person<String>("hello");
}

class Person<E> {
  E s;//E表示s的数据类型，该数据类型在定义Person对象的时候指定，即编译期间就确定E是什么类型。
  public Person(E s) {//构造器
    this.s = s;
  }
  public E f() {	//方法
    return s;
  }
}
```

> **泛型仅仅是java的语法糖，它不会影响java虚拟机生成的汇编代码，在编译阶段，虚拟机就会把泛型的类型擦除，还原成没有泛型的代码，顶多编译速度稍微慢一些，执行速度是完全没有什么区别的**



> 需要记住有关Java泛型转换的事实：
>
> ● 虚拟机中没有泛型，只有普通的类和方法。
>
> ● 所有的类型参数都用它们的限定类型替换。
>
> ● 桥方法被合成来保持多态。
>
> ● 为保持类型安全性，必要时插入强制类型转换。



###2）泛型语法

```java
//泛型的声明
interface 接口<T>{}
class 类<K,V>{}
//其中T,K,V不代表值，而是表示类型
//任意字母都可以，常用T表示，是Type的缩写
```



###3）泛型使用细节

①泛型T.K,V,E只能是引用类型，**不能是基本数据类型**。

②在指定泛型具体类型后，可以传入该类型或其子类类型。

③泛型使用形式

```java
List<Integer> list1 = new ArrayList<Integer>();
List<Integer> list2 = new ArrayList<>();//简写，【推荐这种】
List list3 = new ArrayList();//默认给他的泛型是Object
```

> 总结：泛型代码与JVM      
>
> ① 虚拟机中没有泛型，只有普通类和方法。
> ② 在编译阶段，所有泛型类的类型参数都会被Object或者它们的限定边界来替换。(类型擦除)     
>
> ③在继承泛型类型的时候，桥方法的合成是为了避免类型变量擦除所带来的多态灾难。     无论我们如何定义一个泛型类型，相应的都会有一个原始类型被自动提供。原始类型的名字就是擦除类型参数的泛型类型的名字。

## 二、自定义泛型

###1）类的泛型

[1]语法

```java
class 类名<T,R...>{
  成员;
}
```

[2]使用细节

①普通成员（属性、方法）可以使用泛型

②**使用泛型的数组不能初始化**，不能在类中初始化，只能在类中创建数组，因为在new时不能确定泛型的类型，就无法在内存开空间。

> 不能创建参数化类型的数组！！
>
> 声明类型为Pair\<String>[]的变量是合法的。不过不能用new Pair\<String>[10]初始化这个变量。

③**静态方法、静态属性不能使用类的泛型**

④泛型类的类型是**在创建对象时确定的**（因为创建对象时需要指定确定类型

⑤如果在创建对象时，没有指定类型，默认为Object

> 既不能抛出也不能捕获泛型类对象。实际上，甚至泛型类扩展Throwable都是不合法的。
>
> Java异常处理的一个基本原则是，必须为所有受查异常提供一个处理器。不过可以利用泛型消除这个限制。

###2）接口泛型

[1]语法

```java
interface 接口名<T,R...>{
  成员;
}
```

[2]使用细节

①接口中，静态成员也不能使用泛型，接口内的常量都是静态的。

②泛型接口的类型，在继承接口或者实现接口时确定。

③没有指定类型，默认为Object。



###3）自定义泛型方法

[1]基本语法

```java
修饰符 <T,R...>返回类型 方法名(参数列表){
}
```

[2]使用细节

①泛型方法，可以定义在普通类中，也可以定义在泛型类中。

②当泛型方法被调用时，类型就会确定。

③方法**public void eat(E e){}**中，修饰符后没有<？？？>，eat方法不是泛型方法，而是使用了泛型。

```java
//main方法中
{
  Car car = new Car();
  //当调用方法时，传入参数，编译器，就会确定类型，会进行自动装箱
  car.fly("宝马", 100);//String，Integer
  car.fly(300, 100.1);//Integer，Double
}

class Car {//普通类

    public void run() {//普通方法
    }
  
    public <T, R> void fly(T t, R r) {//泛型方法
    }
}

class Fish<T, R> {//泛型类
    public void run() {//普通方法
    }
  
    public<U,M> void eat(U u, M m) {//泛型方法
    }
  
    public void hi(T t) {	//使用了泛型，不是泛型方法
    }
  
    //泛型方法，可以使用类声明的泛型，也可以使用自己声明泛型
    public<K> void hello(R r, K k) {
    }
}
```



## 三、泛型的继承和通配符

###1）介绍

①泛型不具备继承性

```java
List<Object> list = new ArrayList<String>();//错误
```

②【<?>】：支持任意泛型类型

③【<? extends A>】：支持A类以及A类的子类，规定了泛型的上限

④【<? super A>】：支持A类以及A类的父类，不限于直接父类，规定了泛型的下限



## 四、JUnit

###1）基本介绍

①JUnit是一个Java语言的单元测试框架

②多数Java的开发环境都已经集成了JUnit作为单元测试的工具



###2）基本操作

```java
//一、在方法上面输入【@Test】
//二、用【Alt+Enter】选择【Add'JUnit5.4'to classpath】引入包
//三、等待加载完成即可运行

@Test
public void fly(){
  System.out.println("hello!");
}
```



































