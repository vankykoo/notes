# 集合

## 一、集合框架体系【图】

1、集合主要是两组：单列集合、双列集合

2、Collection接口有两个重要的子接口[List 、Set]，他们的实现子类都是<u>单列</u>集合

3、Map接口的实现子类是<u>双列</u>集合，存放的K-V键值对。![](https://pic-1317004580.cos.ap-guangzhou.myqcloud.com/%E7%AC%94%E8%AE%B0/11/Collection%E7%BB%A7%E6%89%BF%E6%9C%BA%E5%88%B6.png)

![](https://pic-1317004580.cos.ap-guangzhou.myqcloud.com/%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7%E2%85%A0/D%28JIPGC90%40RCSVSJ%24YTVK5J.png)

![](https://uploadfiles.nowcoder.com/images/20161005/1792058_1475635333123_ACED241801E307EE7A39612F85A94EBF)

## 二、Collection接口的特点、方法

###**1）特点**

[1]Collecction实现子类可以存放多个元素，每个元素可以是Object

[2]有些Collection的实现类，可以存放重复的元素，有些不可以

[3]有些Collection的实现类，有些是有序的（List），有些不是有序的（Set）

[4]Collection接口没有直接的实现子类，是通过它的<u>子接口</u>Set和List来实现的

![](https://pic-1317004580.cos.ap-guangzhou.myqcloud.com/%E7%AC%94%E8%AE%B0/11/Collection%E4%BD%93%E7%B3%BB%E5%9B%BE.png)

###**2）常用方法**

[1]【add】：添加单个元素

[2]【remove】：删除指定元素

[3]【contains】：查找元素是否存在

[4]【size】：获取元素个数

[5]【isEmpty】：判断是否为空

[6]【addAll】：添加多个元素（添加一个Collection对象）

[7]【clear】：清空

[8]【containsAll】：查找多个元素（一个对象）是否都存在

[9]【removeAll】：删除多个元素（一个对象）



###**3）遍历元素方式1：使用Iterator（迭代器）**

①Iterator对象称为迭代器，主要用于<u>遍历</u>Collection集合中的元素

②所有实现了Collection接口的集合类都有一个iterator()方法，用以返回一个实现了Iterator接口的对象，即可以返回一个迭代器。

③Iterator仅用于遍历集合，Iterator本身并<u>不存放对象</u>。

```java
Iterator iterator = col.iterator();//生成一个col集合的迭代器
while(iterator.hasNext()){//hasNext()：判断是否还有下一个元素
  System.out.println(iterator.next());//next()表示指针下移、将下移以后集合位置上的元素返回
}

//当退出while循环后，这时iterator迭代器，指向最后一个元素
//如果希望再次遍历，需要重置迭代器
iterator = col.iterator();
```



> 如果你想在循环语句中删除集合中的某个元素，就要用迭代器iterator的**remove()方法**，因为它的remove()方法<u>不仅会删除元素，还会维护一个标志</u>，用来记录目前是不是可删除状态，例如，你不能连续两次调用它的remove()方法，调用之前至少有一次next()方法的调用。



###**4）遍历元素方式2：增强for循环**

※增强for循环可以代替iterator迭代器，特点：增强for就是简化版的iterator，本质一样。只能用于遍历集合或数组。

```java
//基本语法
for(元素类型 元素名:集合名或数组名){
  访问元素
}

//例1:集合
for(Object book : col){
  System.out.println("book=" + book);
}
//例2：数组
int[] nums = {1,8,10,90};
for(int i : nums){
  System.out.println("i=" + i);
}
```



###**5）遍历元素方式3：普通for循环**

```java
for(int i=0;i < list.size();i++){
  System.out.println(list.get(i));
}
```



## 三、Collection接口的子接口：List实现类

###**1）基本介绍**

①List接口是Collection接口的子接口

②List集合类中元素<u>有序</u>（即添加顺序和取出顺序一致）、<u>可重复</u>

③List集合中的每个元素都有其对应的顺序索引，从0开始。

④List容器中的元素都对应一个整数型的序号记载其在容器中的位置，可以根据序号存取容器中的元素。



###**2）常用方法**

①【void **add**(int index, Object ele)】：在index位置插入ele元素

```java
List list = new ArrayList();
list.add("jack");
list.add("mary");
list.add(1,"mike");//在位置1插入对象mike
```

②【boolean **addAll**(int index,Collection eles)】：从index位置开始将eles的所有元素添加进去

```java
List list2 = new ArrayList();
list2.add("leo");
list2.add("miss");
list.addAll(1,list2);
```

③【Object **get**(int index)】：获取指定index位置的元素

④【int **indexOf**(Object obj)】：返回obj在集合中首次出现的位置

⑤【int **lastIndexOf**(Object obj)】：返回obj在当前集合中末次出现的位置

⑥【Object **remove**(int index)】：移除指定index位置的元素，并返回此元素

⑦【Object **set**(int index, Object ele)】：设置指定index位置的元素为ele，相当于是替换。

⑧【List **subList**(int fromIndex,int toIndex)】：返回从fromIndex到toIndex位置的子集合【<u>不包括toIndex</u>】

⑨【int **size**()】：返回集合中元素的个数

⑩【boolean **containsAll**(Collection<?> collection)】：检查Collection中是否包含collection中所有的元素。

11、【Object[] toArray()】：将Collection转化为数组

> ①【ArrayList<E>(int initialCapacity)】：用指定容量构造一个空数组列表。
>
> 参数：initialCapacity 数组列表的最初容量。
>
> ②【void ensureCapacity(int capacity)】：确保数组列表在不重新分配存储空间的情况下就能够保存给定数量的元素。
>
> 参数：capacity 需要的存储容量
>
> ③【void trimToSize()】：将数组列表的存储容量削减到当前尺寸。





###**3）ArrayList的注意事项**

①ArrayList可以加入null，并且<u>可以多个</u>

②ArrayList是由<u>数组</u>来实现数据存储的

③ArrayList基本等同于Vector，除了ArrayList是<u>**线程不安全**</u>（执行效率高），在多线程情况下，不建议使用ArrayList。



###**4）ArrayList底层结构和源码分析**

[1]ArrayList中维护了一个Object类型的数组：elementDate

```java
transient Object[] elementData;
//transient表示瞬间的，短暂的。表示该属性不会被序列化
```

[2]当创建ArrayList对象时，如果使用的是<u>无参</u>构造器，则初始elementdata容量为**0**，第一次添加时扩容elementData为**10**，如需要再次扩容，则每次扩容elementData为原来的**1.5**倍

[3]如果使用的是指定大小的构造器，则初始elementData容量为指定大小，如果需要扩容，则直接扩容为原来elementData的**1.5**倍。



###**5）Vector底层结构和源码分析**

[1]Vector底层也是一个对象数组：elementData

```java
protected Object[] elementData;
```

[2]Vector是线程同步的，即<u>**线程安全**</u>，它的操作方法带有synchronized

[3]在开发过程中，需要线程同步安全时，考虑使用Vector

[4]扩容机制：如果是<u>无参</u>构造器，默认为**10**个空间，如果需要扩容则每次扩为原来的**2**倍。

如果是<u>有参</u>，<u>满后</u>每次按原来的**2**倍扩容。

[5]在内存中占用**连续**的空间。如果Vector定义为保存Object则可以存放任意类型。

![](https://pic-1317004580.cos.ap-guangzhou.myqcloud.com/%E7%AC%94%E8%AE%B0/11/ArrayList%E5%92%8CVector%E6%AF%94%E8%BE%83.png)

###**6）LinkedList底层结构**

[1]LinkedList底层维护了一个<u>双向链表</u>

[2]LinkedList中维护了两个属性first和last分别指向首节点和尾节点

[3]每个结点（Node对象）里面又维护了pre、next、item三个属性。

[4]所以LinkedList的元素的<u>添加和删除</u>不是通过数组完成的，相对来说效率较高。

```java
class Node{
  public Object item;//存放数据
  public Node next;//指向后一个结点
  public Node pre;//指向前一个结点
  public Node(Object name){
    this.item = name;
  }
  public String toString(){
    return "Node name =" + item;
  }
}
```



###**7）LinkedList方法：**

①添加结点【add】：添加到最后

②删除结点【remove()】：默认删除第一个结点

③修改结点【set(索引,内容)】

④获取结点【get(索引)】



###**8）LinkedList和ArrayList比较**

①改查操作多选择ArrayList，增删操作多选择LinkedList

②一般来说，在程序中，查询较多，因此大部分情况下会选择ArrayList

## 四、Collection接口的子接口：Set实现类

###**1）Set接口基本介绍**

①<u>无序</u>（添加和取出的顺序不一致），没有索引。【去除掉顺序虽然不是添加的顺序，但它是固定的】

②<u>不允许重复</u>元素，所以最多包含一个null

③HashSet底层是HashMap【<u>数组+链表+红黑树</u>】



###**2）Set接口的常用方法**

和List接口一样，Set接口也是Collection的子接口，因此，常用方法和Collection接口一样。



###**3）Set接口的遍历方式**

[1]可以使用迭代器

```java
Set set = new HashSet();//创建一个Set接口
Iterator iterator = set.iterator();//创建一个迭代器
while(iterator.hasNext()){
  System.out.println(iterator.next());
}
```

[2]增强for

```java
Set set = new HashSet();//创建一个Set接口
for(Object o : set){
  System.out.println(o);
}
```

※不能使用索引的方式来获取，即不能使用普通for循环



###**4）HashSet底层机制说明**

※**不是线程安全的！**

①HashSet的底层是<u>HashMap</u>

②添加一个元素时，先得到<u>hash值->转成索引值</u>

③找到存储数据表table，看这个索引位置是否已经存放元素。

如果没有，直接加入。

如果有，调用equals比较，如果相同，就放弃添加；如果不相同，则添加到链表最后。

④在Java8中，如果一条链表的元素个数达到<u>TREEIFY_THRESHOLD</u>（默认是**8**），并且table的大小大于等于<u>MIN_TREEIFY_CAPACITY</u>（默认是**64**），就会进行树化（红黑树），否则仍然采用数组扩容机制。

⑤第一次添加时，table数组扩容到**16**，临界值（threshole）是16*加载因子（loadFactor==**0.75**）=12【缓冲】

⑥如果table数组使用到了临界值**12**【指的是添加的结点的个数，不是table数组占的个数】，就会按原来的**2倍**扩容到16*2=**32**，新的临界值就是32\*0.75=24，以此类推。



###**5）LinkedHashSet说明**

①LinkedHashSet是HashSet的子类

②LinkedHashSet底层是一个<u>LinkedHashMap</u>，底层维护了一个<u>hash表+双向链表</u>

③LinkedHashSet根据元素的hashCode值来决定元素的存储位置，同时使用链表维护元素的次序，这使得元素看起来是<u>以插入顺序保存的</u>。

④LinkedHashSet<u>不允许添加重复元素</u>。

⑤每一个结点有pre和next属性，形成双向链表

⑥在添加一个元素时，先求hash值，再求索引，确定该元素再hashtable的位置，然后将添加的元素加入到双向链表（如果已经存在则不添加）。



## 五、Map接口的特点、方法和遍历方式

###**1）Map接口实现类的特点**

①Map与Collection并列存在，用于保存具有映射关系的数据：Key-Value

②Map中的Key和Value可以是任何引用类型的数据，会封装到<u>HashMap$Node</u>对象中。

③Map中的<u>Key不能重复</u>，原因和HashSet一样。Value可以重复。

④Map的<u>Key可以为null</u>，value也可以为null，注意Key为null，只能有一个，value为null可以多个。

⑤常用String类作为Map的key

⑥key和value直接存在单向一对一关系，即通过指定的key总能找到对应的value。

```java
Map map = new HashMap();
map.put("no1","hello");//k-v
map.put("no2","hi");//k-v
map.put("no1","mike");//当有相同的k，就等价于替换
//通过get方法，传入key，会返回对应的value
System.out.println(map.get("no2"));//hi
```

⑦Map存放数据的key-value，一对k-v是放在一个HashMap$Node中的，又因为<u>Node实现了Entry接口</u>，有些书上也说一对k-v就是一个Entry

```java
Map map = new HashMap();
map.put("no1","hello");
map.put("no2","mike");
//1.k-v最后是HashMap$Node node = new Node(hash,key,value,null)
//2.k-v为了方便程序员遍历，还会创建EntrySet集合，该集合存放的元素的类型Entry，而一个Entry对象就有k,v EntrySet<Entry<K,V>>即：transient Set<Map.Entry<K,V>> entrySet;
//3.entrySet中，定义类型是Map.Entry，但是实际上存放的还是HashMap$Node
//	这是因为static class Node<K,V>implements Map.Entry<K,V>
//4.当把HashMap$Node对象存放到entrySet就方便我们的遍历，因为Map.Entry提供了重要的方法【getKey()和getValue()】
Set set = map.entrySet();//set.getClass -> HashMap$EntrySet
for(Object obj : set){
  Map.Entry entry = (Map.Entry) obj;//向下转型
  System.out.println(entry.getKey() + "-" + entry.getValue());//no1-hellp;no2-mike
}

//【网络资料】：
//EntrySet通常用于循环遍历Map集合的方法，它的使用要点包括以下几点：
//1）使用Map集合的EntrySet()方法返回一个Set集合，Set集合中的元素是Map.Entry类型的对象。
//2）使用EntrySet中的getKey()和getValue()方法获取Map中的key和value。
```

※补充entrySet方法：EntrySet是一种特殊的集合，它由Map.entrySet方法返回一个Set对象，Set对象中的元素都是Map.Entry对象，一般用来循环遍历一个Map集合。Map.Entry类型封装Map中的一个键值对，其中的键和值可以彼此独立操作，可以根据键来查找值，也可以根据值来查找键，从而反向查找值。

![](https://pic-1317004580.cos.ap-guangzhou.myqcloud.com/%E7%AC%94%E8%AE%B0/11/Map%E4%BD%93%E7%B3%BB%E5%9B%BE.png)



![](https://pic-1317004580.cos.ap-guangzhou.myqcloud.com/%E7%AC%94%E8%AE%B0/11/Map%E7%BB%A7%E6%89%BF%E6%9C%BA%E5%88%B6.png)

###2）Map接口常用方法

①【**put**】添加

②【**remove**】根据key删除映射关系

③【**get**】根据key获取value

④【**size**】获取元素个数

⑤【**isEmpty**】判断个数是否为0

⑥【**clear**】清空

⑦【**containsKey**】查找key是否存在



###**3）Map的遍历方法**

①先取出所有的key放在一个Set类型的集合中，通过key取出对应的Value

②把所有的values取出放在Collection类型的集合中。

③通过EntrySet获取所有k-v到一个Set类型集合中，再将entry转成Map.Entry，再调用两个方法

```java
Map map = new HashMap();

//第一组：先取出所有的key放在一个Set类型的集合中，通过key取出对应的Value
Set keyset = map.keySet();
//(1)增强for【背】
for(Object key : keyset){
  System.out.println(key + "-" + map.get(key));
}
//(2)迭代器
Iterator iterator = keyset.iterator();//创建keyset的迭代器
while(iterator.hasNext()){
  Object key = iterator.next();
  System.out.println(key + "-" + map.get(key));
}

//第二组：把所有的values取出放在Collection类型的集合中。
Collection values = map.values();//这里可以使用所有的Collection使用的遍历的方法
//(1)增强for
for(Object value : values){
  System.out.println(value);//只打印value，不打印key
}
//(2)迭代器
Iterator iterator2 = values.iterator();
while(iterator2.hasNext()){
  Object value = iterator2.next();
  System.out.println(value);//只打印value，不打印key
}

//第三组：通过EntrySet获取所有k-v到一个Set类型集合中
Set entrySet = map.entrySet();//EntrySet<Map.Entry<K,V>>
//(1)增强for
for(Object entry : entrySet) {
  Map.Entry m = (Map.Entry) entry;//将entry转成Map.Entry
  System.out.println(m.getKey() + "-" + m.getValue());
}
//(2)迭代器
Iterator iterator3 = entrySet.iterator();
while(iterator3.hasNext()){
  Object entry = iterator3.next();//HashMap$Node -实现->Map.Entry【有getKey、getValue方法
  Map.Entry m = (Map.Entry)entry;//向下转型Map.Entry
  System.out.println(m.getKey + "-" + m.getValue);
}
```



> 要迭代处理映射的键和值，最容易的方法是使用forEach方法。可以提供一个接收键和值的lambda表达式。映射中的每一项会依序调用这个表达式。
>
> ```java
> scores.forEach((k,v) -> System.out.println("key=" + k + ", value=" + v));
> ```
>
> 





## 六、Map接口的实现类

###**1）HashMap小结**

【扩容机制和HashSet一致】

①Map接口的常用实现类：HashMap、Hashtable和Properties。

②HashMap是Map接口使用频率最高的实现类

③HashMap是以key-val对的方式来存储数据（HashMap$Node类型）

④key<u>不能重复</u>，但是value可以重复，允许使用null键和null值。

⑤如果添加相同的key，则会覆盖原来的key-value，等同于修改了value

⑥与HashSet一样，<u>不保证映射的顺序</u>，因为底层是以hash表的方式来存储的。

⑦HashMap**没有实现同步**，因此<u>线程不安全</u>，方法没有做同步互斥的操作，没有synchronized。



※Hashmap中的value可以是null，get(key)==null有两种情况，一是key不存在，二是该key中存的是null，所以应该使用map.containskey(key)返回的true/false来判断是否存在这个key。



> 在JDK8之前的版本中，`HashMap`的数据结构是一个数组和链表的组合。`HashMap`内部维护了一个`Entry`数组，数组中的每个元素都是一个链表的头节点。当向`HashMap`中添加一个键值对时，会根据键的哈希值计算出它在数组中的索引位置，然后将这个键值对添加到对应索引位置的链表中。
>
> 如果两个不同的键具有相同的哈希值，或者它们的哈希值经过计算后得到了相同的索引位置，那么这两个键值对就会被存储在同一个链表中。这种情况称为哈希冲突。
>
> 当需要查找一个键对应的值时，会根据键的哈希值计算出它在数组中的索引位置，然后遍历对应索引位置的链表，查找与给定键相等的键值对。



###**2）HashMap源码**

```java
HashMap map = new HashMap();
	map.put("java", 10);//ok
 	map.put("php", 10);//ok
 	map.put("java", 20);//替换value

 	System.out.println("map=" + map);//

 	/*解读HashMap的源码+图解
 	1. 执行构造器 new HashMap()
 		初始化加载因子 loadfactor = 0.75
 		HashMap$Node[] table = null
 	2. 执行put 调用 hash方法，计算 key的 hash值 (h = key.hashCode()) ^ (h >>> 16)
 		public V put(K key, V value) {//K = "java" value = 10
 			return putVal(hash(key), key, value, false, true);
  		}
 	3. 执行 putVal
         final V putVal(int hash, K key, V value, boolean onlyIfAbsent,boolean evict) {
 			Node<K,V>[] tab; Node<K,V> p; int n, i;//辅助变量
 			//如果底层的table 数组为null, 或者 length =0 , 就扩容到16
 			if ((tab = table) == null || (n = tab.length) == 0)
 				n = (tab = resize()).length;
 			//取出hash值对应的table的索引位置的Node, 如果为null, 就直接把加入的k-v
 			//, 创建成一个 Node ,加入该位置即可
 			if ((p = tab[i = (n - 1) & hash]) == null)
                    tab[i] = newNode(hash, key, value, null);
 			else {
                    Node<K,V> e; K k;//辅助变量
 			// 如果table的索引位置的key的hash相同和新的key的hash值相同，
 			// 并 满足(table现有的结点的key和准备添加的key是同一个对象  || equals返回真)
 			// 就认为不能加入新的k-v
 				if (p.hash == hash &&((k = p.key) == key || (key != null && key.equals(k))))
 					e = p;
 				else if (p instanceof TreeNode)//如果当前的table的已有的Node 是红黑树，就按照红黑树的方式处理
                      e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);
                  else {
                        //如果找到的结点，后面是链表，就循环比较
                        for (int binCount = 0; ; ++binCount) {//死循环
                        if ((e = p.next) == null) {//如果整个链表，没有和他相同,就加到该链表的最后
                        p.next = newNode(hash, key, value, null);
						//加入后，判断当前链表的个数，是否已经到8个，到8个后就调用 treeifyBin 方法进行红黑树的转换
                        if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st
                                treeifyBin(tab, hash);
                                break;
                        }
                        if (e.hash == hash && //如果在循环比较过程中，发现有相同,就break,就只是替换value
                                ((k = e.key) == key || (key != null && key.equals(k))))
                                break;
                            p = e;
                        }
                    }
                    if (e != null) { // existing mapping for key
                        V oldValue = e.value;
                        if (!onlyIfAbsent || oldValue == null)
                            e.value = value; //替换，key对应value
                        afterNodeAccess(e);
                        return oldValue;
                    }
                }
                ++modCount;//每增加一个Node ,就size++
                if (++size > threshold[12-24-48])//如size > 临界值，就扩容
                    resize();
                afterNodeInsertion(evict);
                return null;
            }

5. 关于树化(转成红黑树)
//如果table 为null ,或者大小还没有到 64，暂时不树化，而是进行扩容.
//否则才会真正的树化 -> 剪枝
    final void treeifyBin(Node<K,V>[] tab, int hash) {
       int n, index; Node<K,V> e;
       if (tab == null || (n = tab.length) < MIN_TREEIFY_CAPACITY)
           resize();
```



###**3）Hashtable介绍**

①存放的元素是键值对：Key-value

②Hashtable的键和值<u>都不能为null</u>，否则会抛出NullPointerException

③Hashtable使用方法基本上和HashMap一致，Hashtable是<u>**线程安全的**</u>（synchronized），HashMap是线程不安全的。

④扩容机制：初始为**11**，临界值为11***0.75**=8，到达临界值后按原来的空间**乘2加1**处理，即11\*2+1=23。

⑤Hashtable继承自Dictionary类，而HashMap继承自AbstractMap类。



###**4）properties介绍**

①Properties类继承自Hashtable类并且实现了Map接口，也是使用一种键值对的形式来保存数据。

②他的使用特点和Hashtable类似。

③Properties还可以用于从xxx.properties文件中加载数据到Properties类对象，并进行读取和修改。

④说明：工作后xxx.properties文件通常作为配置文件，这个知识点再IO流举例。

```java
//方法
properties.put(key,value);//添加
//put相同key时，相当于修改
properties.remove(key);//通过key删除键值对
properties.get(key);//通过key查找value
```



###**5）TreeSet**

```java
        //解读
        //1. 当我们使用无参构造器，创建TreeSet时，仍然是无序的
        //2. 老师希望添加的元素，按照字符串大小来排序
        //3. 使用TreeSet 提供的一个构造器，可以传入一个比较器(匿名内部类)
        //   并指定排序规则
        //4. 简单看看源码
        //解读
        /*
        1. 构造器把传入的比较器对象，赋给了 TreeSet的底层的 TreeMap的属性this.comparator

         public TreeMap(Comparator<? super K> comparator) {
                this.comparator = comparator;
            }
         2. 在 调用 treeSet.add("tom"), 在底层会执行到
         
             if (cpr != null) {//cpr 就是我们的匿名内部类(对象)
                do {
                    parent = t;
                    //动态绑定到我们的匿名内部类(对象)compare
                    cmp = cpr.compare(key, t.key);
                    if (cmp < 0)
                        t = t.left;
                    else if (cmp > 0)
                        t = t.right;
                    else //如果相等，即返回0,这个Key就没有加入
                        return t.setValue(value);
                } while (t != null);
            }
         */

        TreeSet treeSet = new TreeSet(new Comparator() {	//匿名内部类
            @Override
            public int compare(Object o1, Object o2) {
                //下面 调用String的 compareTo方法进行字符串大小比较
                //return ((String) o2).compareTo((String) o1);
                //如果要求加入的元素，按照长度大小排序
                return ((String) o1).length() - ((String) o2).length();
            }
        });
        //添加数据.
        treeSet.add("jack");
        treeSet.add("tom");//3
        treeSet.add("sp");
        treeSet.add("a");
        treeSet.add("abc");//3


        System.out.println("treeSet=" + treeSet);
```



###**6）TreeMap**

```java
        //使用默认的构造器，创建TreeMap, 是无序的(也没有排序)
        /*
         要求：按照传入的 k(String) 的大小进行排序
         */
//        TreeMap treeMap = new TreeMap();
        TreeMap treeMap = new TreeMap(new Comparator() {
            @Override
            public int compare(Object o1, Object o2) {
                //按照传入的 k(String) 的大小进行排序
                //按照K(String) 的长度大小排序
                //return ((String) o2).compareTo((String) o1);
                return ((String) o2).length() - ((String) o1).length();
            }
        });
        treeMap.put("jack", "杰克");
        treeMap.put("tom", "汤姆");
        treeMap.put("kristina", "克瑞斯提诺");
        treeMap.put("smith", "斯密斯");
        treeMap.put("hsp", "韩顺平");//加入不了

        System.out.println("treemap=" + treeMap);

        /*

            解读源码：
      1. 构造器. 把传入的实现了 Comparator接口的匿名内部类(对象)，传给给TreeMap的comparator
             public TreeMap(Comparator<? super K> comparator) {
                this.comparator = comparator;
            }
      2. 调用put方法
         2.1 第一次添加, 把k-v 封装到 Entry对象，放入root
            Entry<K,V> t = root;
            if (t == null) {
                compare(key, key); // type (and possibly null) check

                root = new Entry<>(key, value, null);
                size = 1;
                modCount++;
                return null;
            }
         2.2 以后添加
            Comparator<? super K> cpr = comparator;
            if (cpr != null) {
                do { //遍历所有的key , 给当前key找到适当位置
                    parent = t;
                    cmp = cpr.compare(key, t.key);//动态绑定到我们的匿名内部类的compare
                    if (cmp < 0)
                        t = t.left;
                    else if (cmp > 0)
                        t = t.right;
                    else  //如果遍历过程中，发现准备添加Key 和当前已有的Key 相等，就不添加
                        return t.setValue(value);
                } while (t != null);
            }
         */
```





## 七、总结：如何选择集合实现类

①先判断存储类型，即是一组对象（单列）还是一组键值对（双列）

②<u>一组对象（单列）：Collection接口</u>

​	允许重复：List

​		增删多：**LinkedList**【底层维护了一个双向链表】

​		改查多：**ArrayList**【底层维护Object类型的可变数组】

​	不允许重复：Set

​		无序：**HashSet**【底层是HashMap，维护了一个哈希表，即（数组+链表+红黑树）】

​		排序：**TreeSet**

​		插入和取出顺序一致：**LinkedHashSet**【维护数组+双向链表】

③<u>一组键值对（双列）：Map</u>

​	键无序：**HashMap**【底层是哈希表，jdk7：数组+链表；jdk8：数组+链表+红黑树】

​	键排序：**TreeMap**

​	键插入和取出顺序一致：**LinkedHashMap**

​	读取文件：**Properties**

## 八、Collections工具类的使用

###**1）Collections工具类介绍**

①Collections是一个操作Set、List和Map等集合的工具类。

②Collections中提供了一系列静态的方法对集合元素进行排序、查询和修改等操作。



###**2）排序操作（均为static方法）**

①【**reverse**(List)】：反转List中元素的顺序

②【**shuffle**(List)】：对List集合元素进行随机排序

③【**sort**(List)】：根据元素的自然顺序对指定List集合元素按升序排序

④【**sort**(List,Comparator)】：根据指定的Comparator产生的顺序对List集合元素进行排序

⑤【**swap**(List,int i,int j)】：将指定List集合中的i处元素和j处元素进行交换。

```java
        //创建ArrayList 集合，用于测试.
        List list = new ArrayList();
        list.add("tom");
        list.add("smith");
        list.add("king");

        Collections.reverse(list);
        Collections.sort(list);
	    Collections.shuffle(list);
//        sort(List，Comparator)：根据指定的 Comparator 产生的顺序对 List 集合元素进行排序
        //我们希望按照 字符串的长度大小排序
        Collections.sort(list, new Comparator() {
            @Override
            public int compare(Object o1, Object o2) {
                //可以加入校验代码.
                return ((String) o2).length() - ((String) o1).length();
            }
        });
        Collections.swap(list, 0, 1);
```



###**3）查找、排序操作**

①【Object **max**(Collection)】：根据元素的自然顺序，返回给定集合中的最大元素。

②【Object **max**(Collection,Comparator)】：根据Comparator指定的顺序，返回给定集合中的最大元素。

③【Object **min**(Collection)】：根据元素的自然顺序，返回给定集合中的最小元素。

④【Object **min**(Collection,Comparator)】：根据Comparator指定的顺序，返回给定集合中的最小元素。

⑤【int **frequency**(Collection,Object)】：返回指定集合中指定元素的出现次数。

⑥【void **copy**(List dest,List src)】：将src中的内容复制到dest中。

⑦【boolean **replaceAll**(List list,Object oldVal,Object newVal)】：使用新值替换List对象的所有旧值。

⑧【static \<T extends Comparable<? super T>> int **binarySearch**(List\<T>element, T key)】、

【static \<T> int **binarySearch**(List\<T> elements, T key, Comparator\<? super T> c)】：从有序列表中搜索一个键，如果元素扩展了AbstractSequentialList类，则采用线性查找，否则将采用二分查找。这个方法的时间复杂度为O (a(n) log n), n是列表的长度，a(n)是访问一个元素的平均时间。这个方法将返回这个键在列表中的索引，如果在列表中不存在这个键将返回负值i。在这种情况下，应该将这个键插入到列表索引—i—1的位置上，以保持列表的有序性。

⑨【static void reverse(List<?> l)】：逆置列表中元素的顺序。例如，逆置列表[t, a, r]后将得到列表[r, a, t]。这个方法的时间复杂度为O (n), n为列表的长度。

```java
        Collections.sort(list, new Comparator() {
            @Override
            public int compare(Object o1, Object o2) {
                //可以加入校验代码.
                return ((String) o2).length() - ((String) o1).length();
            }
        });
        System.out.println("字符串长度大小排序=" + list);

        Collections.swap(list, 0, 1);
        System.out.println("交换后的情况");
        System.out.println("list=" + list);

        System.out.println("自然顺序最大元素=" + Collections.max(list));
        //Object max(Collection，Comparator)：根据 Comparator 指定的顺序，返回给定集合中的最大元素
        //比如，我们要返回长度最大的元素
        Object maxObject = Collections.max(list, new Comparator() {
            @Override
            public int compare(Object o1, Object o2) {
                return ((String)o1).length() - ((String)o2).length();
            }
        });
        System.out.println("长度最大的元素=" + maxObject);


        //Object min(Collection)
        //Object min(Collection，Comparator)
        //上面的两个方法，参考max即可

        System.out.println("tom出现的次数=" + Collections.frequency(list, "tom"));

        ArrayList dest = new ArrayList();
        //为了完成一个完整拷贝，我们需要先给dest 赋值，大小和list.size()一样
        for(int i = 0; i < list.size(); i++) {
            dest.add("");
        }
        //拷贝
        Collections.copy(dest, list);
        System.out.println("dest=" + dest);

        //如果list中，有tom 就替换成 汤姆
        Collections.replaceAll(list, "tom", "汤姆");
        System.out.println("list替换后=" + list);
```



## 九、ConcurrentHashMap

###1、ConcurrentHashMap 1.7

#### 1）存储结构

![](https://oss.javaguide.cn/github/javaguide/java/collection/java7_concurrenthashmap.png)

Java7的`ConcurrentHashMap`有很多个`Segment`组合，而每一个`Segment`是一个类似于`HashMap`的结构，所以每一个`HashMap`的内部可以进行扩容。但是`Segment`的个数一旦初始化就不能改变，默认`Segment`的个数是16个，也可以认为`ConcurrentHashMap`默认支持最多16个线程并发。



#### 2）初始化

通过ConcurrentHashMap的无参构造探寻ConcurrentHashMap的初始化流程。

```java
/**
* Creates a new, empty map with a default initial capacity (16),
* load factor (0.75) and concurrencyLevel (16).
*/
public ConcurrentHashMap() {
    this(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL);
}
```

无参构造中调用了有参构造，传入了三个参数的默认值，他们的值是：

```java
/**
* 默认初始化容量
*/
static final int DEFAULT_INITIAL_CAPACITY = 16;

/**
* 默认负载因子
*/
static final float DEFAULT_LOAD_FACTOR = 0.75f;

/**
* 默认并发级别
*/
static final int DEFAULT_CONCURRENCY_LEVEL = 16;
```

有参构造函数内部实现逻辑：

```java
@SuppressWarnings("unchecked")
public ConcurrentHashMap(int initialCapacity,float loadFactor, int concurrencyLevel) {
    // 参数校验
    if (!(loadFactor > 0) || initialCapacity < 0 || concurrencyLevel <= 0)
        throw new IllegalArgumentException();
    // 校验并发级别大小，大于 1<<16，重置为 65536
    if (concurrencyLevel > MAX_SEGMENTS)
        concurrencyLevel = MAX_SEGMENTS;
    // Find power-of-two sizes best matching arguments
    // 2的多少次方
    int sshift = 0;
    int ssize = 1;
    // 这个循环可以找到 concurrencyLevel 之上最近的 2的次方值
    while (ssize < concurrencyLevel) {
        ++sshift;
        ssize <<= 1;
    }
    // 记录段偏移量
    this.segmentShift = 32 - sshift;
    // 记录段掩码
    this.segmentMask = ssize - 1;
    // 设置容量
    if (initialCapacity > MAXIMUM_CAPACITY)
        initialCapacity = MAXIMUM_CAPACITY;
    // c = 容量 / ssize ，默认 16 / 16 = 1，这里是计算每个 Segment 中的类似于 HashMap 的容量
    int c = initialCapacity / ssize;
    if (c * ssize < initialCapacity)
        ++c;
    int cap = MIN_SEGMENT_TABLE_CAPACITY;
    //Segment 中的类似于 HashMap 的容量至少是2或者2的倍数
    while (cap < c)
        cap <<= 1;
    // create segments and segments[0]
    // 创建 Segment 数组，设置 segments[0]
    Segment<K,V> s0 = new Segment<K,V>(loadFactor, (int)(cap * loadFactor),
                         (HashEntry<K,V>[])new HashEntry[cap]);
    Segment<K,V>[] ss = (Segment<K,V>[])new Segment[ssize];
    UNSAFE.putOrderedObject(ss, SBASE, s0); // ordered write of segments[0]
    this.segments = ss;
}
```

总结Java7中ConcurrentHashMap的初始化逻辑：

①必要参数检验。

②检验并发级别`concurrencyLevel`大小，如果大于最大值，重置为最大值。无参构造**默认值为16**。

③寻找并发级别`concurrencyLevel`之上最近的**2的幂次方**值，作为初始化容量大小，**默认是16**。

④记录`segmentShift`偏移量，这个值为【容量 = 2的N次方】中的N，在后面Put时计算位置时会用到。**默认是32 - sshift = 28。**

⑤记录`segmentMask`，默认是ssize - 1 = 16 - 1 = 15。

⑥**初始化`segments[0]`，默认大小为2，负载因子0.75，扩容阈值是2*0.75 = 1.5**，插入第二个值时才会进行扩容。



#### 3）put

```java
/**
 * Maps the specified key to the specified value in this table.
 * Neither the key nor the value can be null.
 *
 * <p> The value can be retrieved by calling the <tt>get</tt> method
 * with a key that is equal to the original key.
 *
 * @param key key with which the specified value is to be associated
 * @param value value to be associated with the specified key
 * @return the previous value associated with <tt>key</tt>, or
 *         <tt>null</tt> if there was no mapping for <tt>key</tt>
 * @throws NullPointerException if the specified key or value is null
 */
public V put(K key, V value) {
    Segment<K,V> s;
    if (value == null)
        throw new NullPointerException();
    int hash = hash(key);
    // hash 值无符号右移 28位（初始化时获得），然后与 segmentMask=15 做与运算
    // 其实也就是把高4位与segmentMask（1111）做与运算
    int j = (hash >>> segmentShift) & segmentMask;
    if ((s = (Segment<K,V>)UNSAFE.getObject          // nonvolatile; recheck
         (segments, (j << SSHIFT) + SBASE)) == null) //  in ensureSegment
        // 如果查找到的 Segment 为空，初始化
        s = ensureSegment(j);
    return s.put(key, hash, value, false);
}

/**
 * Returns the segment for the given index, creating it and
 * recording in segment table (via CAS) if not already present.
 *
 * @param k the index
 * @return the segment
 */
@SuppressWarnings("unchecked")
private Segment<K,V> ensureSegment(int k) {
    final Segment<K,V>[] ss = this.segments;
    long u = (k << SSHIFT) + SBASE; // raw offset
    Segment<K,V> seg;
    // 判断 u 位置的 Segment 是否为null
    if ((seg = (Segment<K,V>)UNSAFE.getObjectVolatile(ss, u)) == null) {
        Segment<K,V> proto = ss[0]; // use segment 0 as prototype
        // 获取0号 segment 里的 HashEntry<K,V> 初始化长度
        int cap = proto.table.length;
        // 获取0号 segment 里的 hash 表里的扩容负载因子，所有的 segment 的 loadFactor 是相同的
        float lf = proto.loadFactor;
        // 计算扩容阀值
        int threshold = (int)(cap * lf);
        // 创建一个 cap 容量的 HashEntry 数组
        HashEntry<K,V>[] tab = (HashEntry<K,V>[])new HashEntry[cap];
        if ((seg = (Segment<K,V>)UNSAFE.getObjectVolatile(ss, u)) == null) { // recheck
            // 再次检查 u 位置的 Segment 是否为null，因为这时可能有其他线程进行了操作
            Segment<K,V> s = new Segment<K,V>(lf, threshold, tab);
            // 自旋检查 u 位置的 Segment 是否为null
            while ((seg = (Segment<K,V>)UNSAFE.getObjectVolatile(ss, u))
                   == null) {
                // 使用CAS 赋值，只会成功一次
                if (UNSAFE.compareAndSwapObject(ss, u, null, seg = s))
                    break;
            }
        }
    }
    return seg;
}
```

具体流程：

* 1、计算要put的key的位置，获取指定位置的Segment。
* 2、如果指定位置Segment为空，则初始化这个Segment
  * **初始化Segment流程：**
  * ①检查计算得到的位置的Segment是否为null。
  * ②为null继续初始化，使用Segment[0]的容量和负载因子创建一个HashEntry数组。
  * ③再次检查计算得到的指定位置的Segment是否为null。
  * ④使用创建的HashEntry数组初始化这个Segment。
  * ⑤自旋判断计算得到的指定位置的Segment是否为null，使用CAS在这个位置赋值为Segment。
* 3、Segment.put插入key，value值。


下面是最后一行中的Segment的put方法：

```java
final V put(K key, int hash, V value, boolean onlyIfAbsent) {
    // 获取 ReentrantLock 独占锁，获取不到，scanAndLockForPut 获取。
    HashEntry<K,V> node = tryLock() ? null : scanAndLockForPut(key, hash, value);
    V oldValue;
    try {
        HashEntry<K,V>[] tab = table;
        // 计算要put的数据位置
        int index = (tab.length - 1) & hash;
        // CAS 获取 index 坐标的值
        HashEntry<K,V> first = entryAt(tab, index);
        for (HashEntry<K,V> e = first;;) {
            if (e != null) {
                // 检查是否 key 已经存在，如果存在，则遍历链表寻找位置，找到后替换 value
                K k;
                if ((k = e.key) == key ||
                    (e.hash == hash && key.equals(k))) {
                    oldValue = e.value;
                    if (!onlyIfAbsent) {
                        e.value = value;
                        ++modCount;
                    }
                    break;
                }
                e = e.next;
            }
            else {
                // first 有值没说明 index 位置已经有值了，有冲突，链表头插法。
                if (node != null)
                    node.setNext(first);
                else
                    node = new HashEntry<K,V>(hash, key, value, first);
                int c = count + 1;
                // 容量大于扩容阀值，小于最大容量，进行扩容
                if (c > threshold && tab.length < MAXIMUM_CAPACITY)
                    rehash(node);
                else
                    // index 位置赋值 node，node 可能是一个元素，也可能是一个链表的表头
                    setEntryAt(tab, index, node);
                ++modCount;
                count = c;
                oldValue = null;
                break;
            }
        }
    } finally {
        unlock();
    }
    return oldValue;
}
```

由于Segment继承了ReentrantLock，所以Segment内部可以很方便的获取锁，put流程就用到了这个功能。

1、tryLock()获取锁，获取不到的话使用scanAndLockForPut方法继续获取。

2、计算put的数据要放入的index位置，然后获取这个位置上的HashEntry。

3、遍历put新元素，为什么要便利？因为这里获取的HashEntry可能是一个空元素，也可能是链表已存在，所以要区别对待。

* 如果这个位置上的HashEntry不存在：
  * 1、如果当前容量大于扩容阈值，且小于最大容量，进行扩容。
  * 2、直接头插法插入。
* 如果这个位置上的HashEntry存在：
  * 1、判断链表当前元素key和hash值是否要和put的key和hash值一致。一致则替换值。
  * 2、不一致则获取链表下一个节点，直到发现相同进行值替换，或者链表表里没有相同的。
    * 1、如果当前容量大于扩容阈值，且小于最大容量，进行扩容。
    * 2、直接头插法插入。

4、如果要插入的位置之前已经存在，替换后返回旧值，否则返回null。

这里面的第一步中的`scanAndLockForPut`操作这里没有介绍，这个方法做的操作就是不断的自旋`tryLock()`获取锁。当自旋次数大于指定次数时，使用`lock()`阻塞获取锁。在自旋时顺表获取下hash位置的`HashEntry`。

```java
private HashEntry<K,V> scanAndLockForPut(K key, int hash, V value) {
    HashEntry<K,V> first = entryForHash(this, hash);
    HashEntry<K,V> e = first;
    HashEntry<K,V> node = null;
    int retries = -1; // negative while locating node
    // 自旋获取锁
    while (!tryLock()) {
        HashEntry<K,V> f; // to recheck first below
        if (retries < 0) {
            if (e == null) {
                if (node == null) // speculatively create node
                    node = new HashEntry<K,V>(hash, key, value, null);
                retries = 0;
            }
            else if (key.equals(e.key))
                retries = 0;
            else
                e = e.next;
        }
        else if (++retries > MAX_SCAN_RETRIES) {
            // 自旋达到指定次数后，阻塞等到只到获取到锁
            lock();
            break;
        }
        else if ((retries & 1) == 0 &&
                 (f = entryForHash(this, hash)) != first) {
            e = first = f; // re-traverse if entry changed
            retries = -1;
        }
    }
    return node;
}
```





#### 4）扩容rehash

`ConcurrentHashMap`的扩容只会扩容到原来的两倍。老数组里的数据移动到新的数组时，位置要么不变，要么变为`index+oldSize`，参数里的node会在扩容之后使用链表**头插法**插入到指定位置。

```java
private void rehash(HashEntry<K,V> node) {
    HashEntry<K,V>[] oldTable = table;
    // 老容量
    int oldCapacity = oldTable.length;
    // 新容量，扩大两倍
    int newCapacity = oldCapacity << 1;
    // 新的扩容阀值
    threshold = (int)(newCapacity * loadFactor);
    // 创建新的数组
    HashEntry<K,V>[] newTable = (HashEntry<K,V>[]) new HashEntry[newCapacity];
    // 新的掩码，默认2扩容后是4，-1是3，二进制就是11。
    int sizeMask = newCapacity - 1;
    for (int i = 0; i < oldCapacity ; i++) {
        // 遍历老数组
        HashEntry<K,V> e = oldTable[i];
        if (e != null) {
            HashEntry<K,V> next = e.next;
            // 计算新的位置，新的位置只可能是不便或者是老的位置+老的容量。
            int idx = e.hash & sizeMask;
            if (next == null)   //  Single node on list
                // 如果当前位置还不是链表，只是一个元素，直接赋值
                newTable[idx] = e;
            else { // Reuse consecutive sequence at same slot
                // 如果是链表了
                HashEntry<K,V> lastRun = e;
                int lastIdx = idx;
                // 新的位置只可能是不便或者是老的位置+老的容量。
                // 遍历结束后，lastRun 后面的元素位置都是相同的
                for (HashEntry<K,V> last = next; last != null; last = last.next) {
                    int k = last.hash & sizeMask;
                    if (k != lastIdx) {
                        lastIdx = k;
                        lastRun = last;
                    }
                }
                // ，lastRun 后面的元素位置都是相同的，直接作为链表赋值到新位置。
                newTable[lastIdx] = lastRun;
                // Clone remaining nodes
                for (HashEntry<K,V> p = e; p != lastRun; p = p.next) {
                    // 遍历剩余元素，头插法到指定 k 位置。
                    V v = p.value;
                    int h = p.hash;
                    int k = h & sizeMask;
                    HashEntry<K,V> n = newTable[k];
                    newTable[k] = new HashEntry<K,V>(h, p.key, v, n);
                }
            }
        }
    }
    // 头插法插入新的节点
    int nodeIndex = node.hash & sizeMask; // add the new node
    node.setNext(newTable[nodeIndex]);
    newTable[nodeIndex] = node;
    table = newTable;
}
```

最后的两个for循环：第一个for循环是为了寻找这样一个节点，这个节点后面的所有next节点的新位置都是相同的。然后把这个作为一个链表赋值到新位置。第二个for循环是为了把剩余的元素通过头插法插入到指定位置链表。这样实现的原因可能是基于概率统计。





#### 5）get

1、计算得到key的存放位置

2、遍历指定位置查找相同的key的value值。

```java
public V get(Object key) {
    Segment<K,V> s; // manually integrate access methods to reduce overhead
    HashEntry<K,V>[] tab;
    int h = hash(key);
    long u = (((h >>> segmentShift) & segmentMask) << SSHIFT) + SBASE;
    // 计算得到 key 的存放位置
    if ((s = (Segment<K,V>)UNSAFE.getObjectVolatile(segments, u)) != null &&
        (tab = s.table) != null) {
        for (HashEntry<K,V> e = (HashEntry<K,V>) UNSAFE.getObjectVolatile
                 (tab, ((long)(((tab.length - 1) & h)) << TSHIFT) + TBASE);
             e != null; e = e.next) {
            // 如果是链表，遍历查找到相同 key 的 value。
            K k;
            if ((k = e.key) == key || (e.hash == h && key.equals(k)))
                return e.value;
        }
    }
    return null;
}
```



### 2、ConcurrentHashMap 1.8

#### 1）存储结构

![](https://oss.javaguide.cn/github/javaguide/java/collection/java8_concurrenthashmap.png)

Java8的ConcurrentHashMap相对于Java7来说变化比较大，不再是之前的Segment数组 + HashEntry数组 + 链表，而是Node 数组 + 链表/红黑树。当冲突链表达到一定长度时，链表会转换成红黑树。



#### 2）初始化  initTable

```java
/**
 * Initializes table, using the size recorded in sizeCtl.
 */
private final Node<K,V>[] initTable() {
    Node<K,V>[] tab; int sc;
    while ((tab = table) == null || tab.length == 0) {
        //　如果 sizeCtl < 0 ,说明另外的线程执行CAS 成功，正在进行初始化。
        if ((sc = sizeCtl) < 0)
            // 让出 CPU 使用权
            Thread.yield(); // lost initialization race; just spin
        else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) {
            try {
                if ((tab = table) == null || tab.length == 0) {
                    int n = (sc > 0) ? sc : DEFAULT_CAPACITY;
                    @SuppressWarnings("unchecked")
                    Node<K,V>[] nt = (Node<K,V>[])new Node<?,?>[n];
                    table = tab = nt;
                    sc = n - (n >>> 2);
                }
            } finally {
                sizeCtl = sc;
            }
            break;
        }
    }
    return tab;
}
```

> 这段代码是ConcurrentHashMap中的initTable()方法。它用于初始化table数组。
>
> 当table数组为null或长度为0时，它会进入循环。
>
> 如果sizeCtl小于0，则说明另一个线程正在执行初始化，因此当前线程会让出CPU使用权。
>
> 否则，当前线程会尝试使用CAS将sizeCtl设置为-1，以便获得初始化的权利。
>
> 如果成功，则会创建一个新的Node数组，并将其赋值给table。
>
> 最后，sizeCtl被设置为n - (n >>> 2)，其中n是数组的长度。
>
> 这个方法最终返回初始化后的table数组。

从源码中可以发现`ConcurrentHashMap`的初始化是通过自旋和CAS操作完成的。里面的需要注意的是变量`sizeCtl`，它的值决定着当前的初始化状态。

sizeCtl是ConcurrentHashMap中的一个变量，它用于控制table数组的初始化和扩容。它的值有以下几种情况：

- 如果table未初始化，sizeCtl表示table的初始容量。
- 如果table已初始化，sizeCtl表示下一次扩容时的阈值，即table的长度乘以加载因子。
- 如果sizeCtl为-1，则表示有一个线程正在执行初始化操作。
- 如果sizeCtl小于-1，则表示有多个线程正在执行扩容操作，其绝对值表示参与扩容的线程数。

> 在Java8之前，ConcurrentHashMap使用分段锁来实现并发，数据结构为hashmap（数组加链表）的基础上再套一层segment数组，锁加在segment元素上。
>
> Java8实现了粒度更细的加锁，去掉了segment数组，直接使用synchronized锁住hash后得到的数组下标位置中的第一个元素，这样加锁比segment加锁能支持更高的并发量。另外，在java8中，当链表内的node数量满足一定条件时，链表会变成红黑树，加快搜索速度。





#### 3）put

```java
public V put(K key, V value) {
    return putVal(key, value, false);
}

/** Implementation for put and putIfAbsent */
final V putVal(K key, V value, boolean onlyIfAbsent) {
    // key 和 value 不能为空
    if (key == null || value == null) throw new NullPointerException();
    int hash = spread(key.hashCode());
    int binCount = 0;
    for (Node<K,V>[] tab = table;;) {
        // f = 目标位置元素
        Node<K,V> f; int n, i, fh;// fh 后面存放目标位置的元素 hash 值
        if (tab == null || (n = tab.length) == 0)
            // 数组桶为空，初始化数组桶（自旋+CAS)
            tab = initTable();
        else if ((f = tabAt(tab, i = (n - 1) & hash)) == null) {
            // 桶内为空，CAS 放入，不加锁，成功了就直接 break 跳出
            if (casTabAt(tab, i, null,new Node<K,V>(hash, key, value, null)))
                break;  // no lock when adding to empty bin
        }
        else if ((fh = f.hash) == MOVED)
            tab = helpTransfer(tab, f);
        else {
            V oldVal = null;
            // 使用 synchronized 加锁加入节点
            synchronized (f) {
                if (tabAt(tab, i) == f) {
                    // 说明是链表
                    if (fh >= 0) {
                        binCount = 1;
                        // 循环加入新的或者覆盖节点
                        for (Node<K,V> e = f;; ++binCount) {
                            K ek;
                            if (e.hash == hash &&
                                ((ek = e.key) == key ||
                                 (ek != null && key.equals(ek)))) {
                                oldVal = e.val;
                                if (!onlyIfAbsent)
                                    e.val = value;
                                break;
                            }
                            Node<K,V> pred = e;
                            if ((e = e.next) == null) {
                                pred.next = new Node<K,V>(hash, key,
                                                          value, null);
                                break;
                            }
                        }
                    }
                    else if (f instanceof TreeBin) {
                        // 红黑树
                        Node<K,V> p;
                        binCount = 2;
                        if ((p = ((TreeBin<K,V>)f).putTreeVal(hash, key,
                                                       value)) != null) {
                            oldVal = p.val;
                            if (!onlyIfAbsent)
                                p.val = value;
                        }
                    }
                }
            }
            if (binCount != 0) {
                if (binCount >= TREEIFY_THRESHOLD)
                    treeifyBin(tab, i);
                if (oldVal != null)
                    return oldVal;
                break;
            }
        }
    }
    addCount(1L, binCount);
    return null;
}
```

1、根据key计算出hashcode。

2、判断是否需要进行初始化。

3、即为当前key定位出的Node，如果为空表示当前位置可以写入数据，利用CAS尝试写入，失败则自旋保证成功。

4、如果当前位置的hashcode == MOVED == -1,则需要进行扩容。

5、如果都不满足，则利用synchronized锁写入数据。

6、如果数量大于TREEIFY_THRESHOLD则要执行树化方法，在treeifyBin中会首先判断当前数组长度≥64时才会将链表转换为红黑树。

> ConcurrentHashMap的put操作主要由putVal()方法实现。该方法中对value的插入，采用了CAS操作和synchronized的操作，从而保证了并发环境下的安全性。put步骤大致如下：
>
> 1. 判断key和value是否为null，如果是的话抛出NullPointerException并结束（ConcurrentHashMap不允许存放null型的key和value，这点和HashMap也不同）。
> 2. 计算key的hash值。
> 3. 如果table未初始化或长度为0，则调用initTable()方法进行初始化。
> 4. 根据hash值定位到table中的一个桶（数组元素），并获取该桶中的第一个节点。
> 5. 如果该桶为空，则使用CAS操作尝试将新节点插入到该桶中。
> 6. 如果该桶不为空，则使用synchronized锁住该桶中的第一个节点，并遍历该桶中的所有节点，查找与key相等的节点。如果找到了，则更新该节点的值。否则，在该桶的末尾插入新节点。
> 7. 如果该桶中的节点数量超过了树化阈值（默认为8），则将该桶中的链表转换为红黑树。
>

#### 4）get

```java
public V get(Object key) {
    Node<K,V>[] tab; Node<K,V> e, p; int n, eh; K ek;
    // key 所在的 hash 位置
    int h = spread(key.hashCode());
    if ((tab = table) != null && (n = tab.length) > 0 &&
        (e = tabAt(tab, (n - 1) & h)) != null) {
        // 如果指定位置元素存在，头结点hash值相同
        if ((eh = e.hash) == h) {
            if ((ek = e.key) == key || (ek != null && key.equals(ek)))
                // key hash 值相等，key值相同，直接返回元素 value
                return e.val;
        }
        else if (eh < 0)
            // 头结点hash值小于0，说明正在扩容或者是红黑树，find查找
            return (p = e.find(h, key)) != null ? p.val : null;
        while ((e = e.next) != null) {
            // 是链表，遍历查找
            if (e.hash == h &&
                ((ek = e.key) == key || (ek != null && key.equals(ek))))
                return e.val;
        }
    }
    return null;
}
```

1、根据hash值计算位置。

2、查找到指定位置，如果头节点就是要找的，直接返回它的value。

3、如果头节点hash值小于0，说明正在扩容或者是红黑树，查找之。

4、如果是链表，遍历查找之。





### 3、Java7和Java8的ConcurrentHashMap总结

Java7中`ConcurrentHashMap`使用的是分段锁，也就是每一个`Segment`上同时只有一个线程可以操作，每一个`Segment`都是一个类似`HashMap`数组的结构，它可以扩容，它的冲突会转化为链表。但是`Segment`的个数一旦初始化就不能改变。

Java8中的`ConcurrentHashMap`使用的`Synchronized`锁加CAS的机制。结构也由Java7中的**`Segment` 数组 + `HashEntry` 数组 + 链表**进化成了**`Node`数组 + 链表/红黑树**，`Node`是类似于一个`HashEntry`的结构。它的冲突在达到一定大小时会转化成红黑树，在冲突小于一定数量时又退回链表。





### 4、ConcurrentHashMap和Hashtable的区别

主要体现在实现线程安全的方式不同：

* 底层数据结构
  * JDK1.7的`ConcurrentHashMap`底层采用分段的 **数组+链表** 实现，JDK1.8采用的数据结构跟`HashMap1.8`的结构一样，**数组 + 链表/红黑二叉树**。
  * `Hashtable`和JDK1.8之前的`HashMap`的底层数据结构类似都是采用 **数组 + 链表** 的形式，数组HashMap的主体，链表则是主要为了解决哈希冲突而存在的；
* 实现线程安全的方式
  * 在JDK1.7的时候，`ConcurrentHashMap`对整个桶数组进行了分割分段（`Segment`，分段锁），每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。
  * 到了JDK1.8的时候，`ConcurrentHashMap`已经摒弃了`Segment`的概念，而是直接用**`Node`数组 + 链表 + 红黑树** 的数据结构来实现，并发控制使用`synchronized`和CAS来操作。（JDK1.6以后`synchronized`锁做了很多优化）整个看起来就像是优化过且线程安全的`HashMap`，虽然在JDK1.8中还能看到`Segment`的数据结构，但是已经简化了属性，只是为了兼容旧版本。
  * **`Hashtable`（同一把锁）**：使用`synchronized`来保证线程安全，效率低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用put添加元素，另一个线程不能使用put添加元素，也不能使用get，竞争会越来越激烈效率越低。



**Hashtable：**

![](https://oss.javaguide.cn/github/javaguide/java/collection/jdk1.7_hashmap.png)



**JDK1.7的ConcurrentHashMap：**

![](https://oss.javaguide.cn/github/javaguide/java/collection/java7_concurrenthashmap.png)

`ConcurrentHashMap`是由`Segment`数组结构和`HashEntry`数组结构组成。

`Segment`数组中的每一个元素包含一个`HashEntry`数组，每个`HashEntry`数组属于链表结构。



**JDK1.8的ConcurrentHashMap：**

![](https://oss.javaguide.cn/github/javaguide/java/collection/java8_concurrenthashmap.png)

JDK1.8的`ConcurrentHashMap`不再是 **Segment数组 + HashEntry 数组 + 链表**，而是**Node 数组 + 链表/红黑树**。不过，`Node`只能用于链表的情况，红黑树的情况需要使用`TreeNode`。当冲突链表达到一定长度时，链表会转换成红黑树。

`TreeNode`是存储红黑树节点，被`TreeBin`包装。`TreeBin`通过`root`属性维护红黑树的根节点，因为红黑树在旋转的时候，根节点可能会被它原来的子节点替换掉，在这个时间点，如果有其他线程要写这棵红黑树就会发生线程不安全问题，所有在`ConcurrentHashMap`中`TreeBin`通过`waiter`属性维护当前使用这棵红黑树的线程，来防止其他线程的进入。

```java
static final class TreeBin<K,V> extends Node<K,V> {
        TreeNode<K,V> root;
        volatile TreeNode<K,V> first;
        volatile Thread waiter;
        volatile int lockState;
        // values for lockState
        static final int WRITER = 1; // set while holding write lock
        static final int WAITER = 2; // set when waiting for write lock
        static final int READER = 4; // increment value for setting read lock
...
}
```





### 5、ConcurrentHashMap线程安全的具体实现方式/底层具体实现

#### ①JDK1.8之前

![](https://oss.javaguide.cn/github/javaguide/java/collection/java7_concurrenthashmap.png)

首先将数据分为一段一段（Segment）的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其他线程访问。

`ConcurrentHashMap`是由**`Segment`数组结构和`HashEntry`数组结构组成**。

`Segment`继承了`ReentrantLock`，所以`Segment`是一种可重入锁，**扮演锁的角色**。`HashEntry`用于存储键值对数据。

> 可重入锁（Reentrant Lock）是指在同一个线程内，外层函数获得锁之后，内层递归函数仍然有获取该锁的权限。在同一个线程内，当一个锁被占用时，仍然可以被再次获取。可重入锁最大的作用是避免死锁。ReentrantLock和synchronized都是可重入锁¹。
>
> 不可重入锁（Non-reentrant Lock）与可重入锁相反，同一个线程在未释放锁之前无法再次获取该锁。如果递归调用会发生死锁¹。
>
> 简单来说，可重入锁允许同一个线程多次获取同一把锁，而不可重入锁则不允许这种情况发生。
>

```java
static class Segment<K,V> extends ReentrantLock implements Serializable {
}
```

一个`ConcurrentHashMap`里包含一个`Segment`数组，`Segment`的个数一旦初始化就不能改变。`Segment`数组的大小默认是16，也就是说默认可以同时支持16个线程并发写。

`Segment`的结构和`HashMap`类似，是一种数组和链表结构，一个`Segment`包含一个`HashEntry`数组，每个`HashEntry`是一个链表结构的元素，每个`Segment`守护着一个`HashEntry`数组里的元素，当对`HashEntry`数组的数据进行修改时，必须首先获得对应的`Segment`的锁，也就是说，对同一`Segment`的并发写入会被阻塞，不同`Segment`的写入是可以并发执行的。



#### ②JDK1.8之后

![](https://oss.javaguide.cn/github/javaguide/java/collection/java8_concurrenthashmap.png)

`ConcurrentHashMap`取消了`Segment`分段锁，采用 **Node + CAS + synchronized** 来保证并发安全。数据结构跟`HashMap1.8`的结构类似，**数组 + 链表/红黑二叉树**。Java8在链表长度超过一定阈值（8）时将链表（寻址时间复杂度为O(N)）转换为红黑树（寻址时间复杂度为O(log(N))）。

java 8中，锁粒度更细，`synchronized`只锁定当前链表或红黑二叉树的首节点，这样只要hash不冲突，就不会产生并发，就不会影响其他Node的读写，效率大幅提升。



### 6、JDK1.7和JDK1.8的ConcurrentHashMap实现的不同

* 线程安全实现方式：JDK1.7采用Segment分段锁来保证安全，Segment是继承自ReentrantLock。JDK1.8放弃了Segment分段锁的设计，采用 Node + CAS +synchronized保证线程安全，锁粒度更细，synchronized只锁定当前链表或红黑二叉树的首节点。
* Hash碰撞解决方法：JDK1.7采用拉链法，JDK1.8采用拉链法结合红黑树（链表长度超过一定阈值时，将链表转换为红黑树）。
* 并发度：JDK1.7最大的并发度是Segment的个数，默认是16。JDK1.8最大并发度是Node数组答大小，并发度更大。


> Hash碰撞指的是两个不同的值（比如张三、李四的学号）经过hash计算后，得到的hash值相同，后来的李四要放到原来的张三的位置，但是数组的位置已经被张三占了，导致冲突。
>
> 解决Hash碰撞的方法有**开放寻址法和拉链法**。
>
> **开放寻址法**指的是，当前数组位置1被占用了，就放到下一个位置2上去，如果2也被占用了，就继续往下找，直到找到空位置。
>
> **拉链法**采用的是链表的方式，在位置1存放一个指针，指向数组外的另一个位置，将李四安排在这里，张三那个Entry中的next指针就指向李四的这个位置。如果还有冲突，就把又冲突的那个Entry放到一个新位置上，然后李四的Entry指向它，这样就形成一个链表。

































## 十、线程安全的集合

### 1）高效的映射、集、队列

java.util.concurrent包提供了映射、有序集和队列的高效实现：**ConcurrentHashMap、ConcurrentSkipListMap、ConcurrentSkipListSet和ConcurrentLinkedQueue。**

> ● 【ConcurrentLinkedQueue<E>()】
>
> 构造一个可以被多线程安全访问的无边界非阻塞的队列。



> ● 【ConcurrentSkipListSet<E>()】
>
> ● 【ConcurrentSkipListSet<E>(Comparator<? super E> comp)】构造一个可以被多线程安全访问的有序集。第一个构造器要求元素实现Comparable接口。



> ● 【ConcurrentHashMap<K, V>()】
>
> ● 【ConcurrentHashMap<K, V>(int initialCapacity)】
>
> ● 【ConcurrentHashMap<K, V>(int initialCapacity, float loadFactor,int concurrencyLevel)】
>
> 构造一个可以被多线程安全访问的散列映射表。
>
> 参数：initialCapacity　集合的初始容量。默认值为16。loadFactor控制调整：如果每一个桶的平均负载超过这个因子，表的大小会被重新调整。默认值为0.75。concurrencyLevel　并发写者线程的估计数目。



> ● 【ConcurrentSkipListMap<K, V>()】
>
> ● 【ConcurrentSkipListSet<K, V>(Comparator<? super K> comp)】构造一个可以被多线程安全访问的有序的映像表。第一个构造器要求键实现Comparable接口。



### 2）对并发散列映射的批操作

[1]介绍：Java SE 8为并发散列映射提供了批操作，**即使有其他线程在处理映射，这些操作也能安全地执行。**批操作会遍历映射，处理遍历过程中找到的元素。无须冻结当前映射的快照。除非你恰好知道批操作运行时映射不会被修改，否则就要把结果看作是映射状态的一个近似。



**[2]有三种不同的操作：**

* 搜索（search）为每个键或值提供一个函数，直到函数生成一个非null的结果。然后搜索终止，返回这个函数的结果。
* 规约（reduce）组合所有键或值，这里要使用所提供的一个累加函数。
* forEach 为所有键或值提供一个函数。



**[3]每个操作都有四个版本：**

* operationKeys：处理键
* operationValues：处理值
* operation：处理键和值
* operationEntries：处理Map.Entry对象

※对于上述各个操作，需要指定一个参数化阈值（parallelism threshold）。如果映射包含的元素多于这个阈值，就会并行完成批操作。如果希望批操作在一个线程中运行，可以使用阈值Long.MAX_VALUE。如果希望用尽可能多的线程运行批操作，可以使用阈值1。



### 3）Future

[1]用处及介绍：

主要用在一些需要执行耗时任务的场景，避免程序一直原地等待耗时任务执行完成，执行效率太低。

具体来说是这样的：当我们执行某一耗时的任务时，可以将这个耗时任务交给一个子线程去异步执行，同时我们可以干点其他事情，不用傻傻等待耗时任务执行完成。等我们的事情干完后，我们再通过Future类获取获取到耗时任务的执行结果。



[2]在Java中，Future类只是一个泛型接口，位于java.utils.concurrent包下，其中定义了5个方法，主要包括下面这4个功能：

* 取消任务；
* 判断任务是否被取消；
* 判断任务是否已经执行完成；
* 获取任务执行结果

```java
// V 代表了Future执行的任务返回值的类型
public interface Future<V> {
    // 取消任务执行
    // 成功取消返回 true，否则返回 false
    boolean cancel(boolean mayInterruptIfRunning);
    // 判断任务是否被取消
    boolean isCancelled();
    // 判断任务是否已经执行完成
    boolean isDone();
    // 获取任务执行结果
    V get() throws InterruptedException, ExecutionException;
    // 指定时间内没有返回计算结果就抛出 TimeOutException 异常
    V get(long timeout, TimeUnit unit)

        throws InterruptedException, ExecutionException, TimeoutExceptio

}
```



简单理解就是：我有一个任务，提交给了Future来处理。任务执行期间我自己可以去做任何想做的事情。并且，在这期间我还可以取消任务以及获取任务的执行状态。一段时间之后，我就可以在Future那里直接取出任务执行结果。



[3]Callble和Future的关系：

FutureTask提供了Future接口的基本实现，常用来封装Callable和Runnable，具有取消任务、查看任务是否执行完成以及获取任务执行结果的方法。ExecutorService.submit()方法返回的其实就是Future的实现类FutureTask。

```java
<T> Future<T> submit(Callable<T> task);
Future<?> submit(Runnable task);
```

Future不光实现了Future接口，还实现了Runnable接口，因此可以作为任务直接被线程执行。

![](https://oss.javaguide.cn/github/javaguide/java/concurrent/completablefuture-class-diagram.jpg)

FutureTask有两个构造函数，可传入Callable或者Runnale对象。实际上，传入Runnable对象也会在方法内部转换为Callable对象。

```java
public FutureTask(Callable<V> callable) {
    if (callable == null)
        throw new NullPointerException();
    this.callable = callable;
    this.state = NEW;
}
public FutureTask(Runnable runnable, V result) {
    // 通过适配器RunnableAdapter来将Runnable对象runnable转换成Callable对象
    this.callable = Executors.callable(runnable, result);
    this.state = NEW;
}
```

FutureTask相当于对Callable进行了封装，管理着任务执行的情况，存储了Callable的call方法的任务执行结果。



### 4）线程池

####[1]构造器（Executor）类

有许多静态工厂方法用来构建线程池。

![](https://pic-1317004580.cos.ap-guangzhou.myqcloud.com/%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7%E2%85%A0/T~R%60Z%7DRH%7BS%25U3R~O%281O7VY6.png)



####[2]线程池

**{1}介绍**：线程池就是管理一系列线程的资源池。当有任务要处理时，直接从线程池中获取线程来处理，处理完之后线程并不会立即被销毁，而是等待下一个任务。

**{2}好处：**

线程池提供了一种限制和管理资源（包括执行一个任务）的方式。每个线程池还维护一些基本统计信息，例如已完成任务的数量。

* 降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。
* 提高相应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。
* 提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一地分配、调优和监控。



**{3}创建线程池的方式**

①方式一：通过ThreadPoolExecutor构造函数来创建（推荐）

![](https://javaguide.cn/assets/threadpoolexecutor%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0-d54a5992.png)



②方式二：通过Executor框架的工具类Executors来创建。

我们可以创建多种类型的ThreadPoolExecutor：

* **FixedThreadPool**：该方法返回一个固定线程数量的线程池。该线程池中的线程数量始终不变。当有一个新的任务提交时，线程池中若有空闲线程，则立即执行。若没有，则新的任务会被暂存在一个任务队列中，待有线程空闲时，便处理在任务队列中的任务。
* **SingleThreadExecutor**：该方法返回一个只有一个线程的线程池。若多余一个任务被提交到该线程池，任务会被保存在一个任务队列中，待线程空闲，按先入先出的顺序执行队列中的任务。
* **CachedThreadPool**：该方法返回一个可根据实际情况调整线程数量的线程池。线程池的线程数量不确定，但若有空闲线程可以复用，则会优先使用可复用的线程。若所有线程均在工作，又有新的任务提交，则会创建新的线程处理任务。所有线程在当前任务执行完毕后，将返回线程池进行复用。
* **ScheduledThreadPool**：该返回一个用来在给定的延迟后运行任务或者定期执行任务的线程池。

![](https://oss.javaguide.cn/github/javaguide/java/concurrent/executors-inner-threadpool.png)



{4}线程池常见参数

**ThreadPoolExecutor 3 个最重要的参数：**

- **corePoolSize :** 任务队列未达到队列容量时，最大可以同时运行的线程数量。
- **maximumPoolSize :** 任务队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。
- **workQueue:** 新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。



**ThreadPoolExecutor其他常见参数 :**

- **keepAliveTime**:线程池中的线程数量大于 `corePoolSize` 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了 `keepAliveTime`才会被回收销毁；
- **unit** : `keepAliveTime` 参数的时间单位。
- **threadFactory** :executor 创建新线程的时候会用到。
- **handler** :饱和策略。关于饱和策略下面单独介绍一下。

![](https://javaguide.cn/assets/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%90%84%E4%B8%AA%E5%8F%82%E6%95%B0%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB-d65f3309.png)



{5}处理任务的流程

![](https://oss.javaguide.cn/javaguide/%E5%9B%BE%E8%A7%A3%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.png)

①如果当前运行的线程数小于核心线程数，那么就会新建一个线程来执行任务。

②如果当前运行的线程数等于或大于核心线程数，但是小于最大线程数，那么就把该任务放入到任务队列里等待执行。

③如果向任务队列投放任务失败（任务队列已经满了），但是当前运行的线程数是小于最大线程数的，就新建一个线程来执行任务。

④如果当前运行的线程数已经等同于最大线程数了，新建线程将会使当前运行的线程超出最大线程数，那么当前任务会被拒绝，饱和策略会调用`RejectedExecutionHandler.rejectedExecution()`方法。











