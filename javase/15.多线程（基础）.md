# 多线程（基础）

## 一、线程介绍

###**1）线程相关概念**

[1]**程序**（program）：是为完成特定任务、用某种语言编写的一组指令的集合。

[2]**进程**：

①进程是指运行中的程序。比如使用QQ，就启动了一个进程，操作系统会为该进程分配内存空间。

②进程是程序的一次执行过程，或是正在运行的一个程序。是一个动态过程：有它自身的产生、存在和消亡过程。

[3]**线程**：

①线程是由进程创建的，是进程的一个实体。

②一个进程可以拥有多个线程。



> 私有:java虚拟机栈，程序计数器，本地方法栈    
>
> 共享:java堆，方法区



###2）其它概念

[1]单线程：同一个时刻，只允许执行一个线程。

[2]多线程：同一个时刻，可以执行多个线程。



[3]并发：同一个时刻，多个任务交替执行，造成一种“貌似同时”的错觉，简单的说，单核cpu实现的多任务就是并发。

[4]并行：同一个时刻，多个任务同时执行，多核cpu可以实现并行。

## 二、线程创建

###1）创建线程的两种方式

①继承Thread类，重写run方法。

②实现Runnable接口，重写run方法。



###2）方法一：继承Thread类，重写run方法。

```java
//每隔1秒输出一次“喵喵，我是小猫咪”，共输出80次
//main中
{
  Cat cat = new Cat();
  cat.start();//启动线程->最终会执行cat的run方法
  //run方法就是一个普通的方法，没有真正的启动一个线程，就会把run方法执行完毕，才向下执行
  //当main线程启动一个子线程Thread-0，主线程不会阻塞，会继续执行
  //这时主线程和子线程是交替执行
}

class Cat extends Thread{	//继承Thread类
  int times = 0;
  @Override
  public void run(){	//重写run方法，在里面写自己的业务代码
    while(true){
      System.out.println("喵喵，我是小猫咪" + (++times));
      try{
        Thread.sleep(1000);//让该线程休眠1秒
      }catch(InterruptedException e){
        e.printStackTrace();
      }
      if(times == 80){
        break;
      }
    }
  }
}
```



###3）方法二：实现Runnable接口，重写run方法。

[1]说明：

①java是单继承的，在某些情况下一个类可能已经继承了某个父类，这时在用继承Thread类方法来创建线程显然不可能了。

②java设计者们提供了另外一个方式创建线程，就是通过实现Runnable接口来创建线程。

```java
//main中
{
  Dog dog = new Dog();
  Thread thread = new Thread(dog);
  //创建了Thread对象，把 dog对象(实现Runnable),放入Thread
  thread.start();
}

class Dog implements Runnable{	//实现Runnable接口
  int count = 0;
  @Override
  public void run(){
    while(true){
      System.out.println("小狗汪汪叫" + (++count));
      try{
        Thread.sleep(1000);//让该线程休眠1秒
      }catch(InterruptedException e){
        e.printStackTrace();
      }
      if(count == 80){
        break;
      }
    }
  }
}
```



###4）继承Thread和实现Runnable的区别

①从java的设计来看，通过继承Thread或者实现Runnable接口来创建线程本质上没有区别，从jdk帮助文档我们可以看到Thread类本身就实现了Runnable接口。

②实现Runnable接口方式更加适合多个线程共享一个资源的情况，并且避免了单继承的限制。【建议使用Runnable】



###5）线程终止

①当线程完成任务后会自动退出。

②还可以通过使用变量来控制run方法退出的方式停止线程，即通知方式。

## 三、线程方法

###1）常用方法一

[1] 【setName】：设置线程名称，使之与参数name相同。

[2]【getName】：返回线程的名称。

[3]【start】：使该线程开始执行；Java虚拟机底层调用该线程的start0方法

[4]【run】：调用线程对象run方法。

[5]【setPriority】：更改线程的优先级。

[6]【getPriority】：获取线程的优先级。

[7]【sleep】：在指定的毫秒数内让当前正在执行的线程休眠（暂停执行）

[8]【interrupt】：中断线程。

[9]【getState】：得到这一线程的状态。

※使用细节

①start底层会创建新的线程，调用run，**run就是一个简单的方法调用，不会启动新线程**。

②线程优先级：MAX_PRIORITY(10)   NORM_PRIORITY(5)   MIN_PRIORITY(1)

③interrupt是中断线程，但并没有真正的结束线程，所以一般用于中断正在休眠的线程。

④sleep是线程的静态方法，使当前线程休眠。

⑤**Thread.sleep() 、Thread.join()和 Object.wait(),都可以抛出 InterruptedException**。这个异常是不能忽略的,因为它是一个检查异常(checked exception)

※注意：不要调用Thread类或Runnable对象的run方法。直接调用fun方法，只会执行同一个线程中的任务，而不会启动新线程。应该调用Thread.start方法。这个方法将创建一个执行run方法的新线程。

> interrupted和isInterrupted的区别
>
> interrupted方法是一个静态方法，他检测当前的线程是否被中断。而且，调用interrupted方法**会清除该线程的中断状态**。
>
> isInterrupted方法是一个实例方法，可用来检验是否有线程被中断。调用这个方法**不会改变中断状态**。



###2）常用方法二

[1]【yield】：线程的礼让。让出cpu，让其他线程执行，但礼让的时间不确定，所以也不一定礼让成功。

> yiled方法属于高风亮节的行为，这个坑位我不上了，后面跟我同级别的先上厕所。这样比较好记！    
>
> 高优先级的就是你们的县长，县长要上厕所，对不起，你得出来，县长先上，县长上完了，CPU分配到你了，你才能继续拉X。 

[2]【join】：线程的插队。插队的线程一旦插队成功，则肯定先执行完插入的线程所有的任务。



###3）用户线程和守护线程

①用户线程：也叫工作线程，当线程的任务执行完成或收到通知方式就结束。

②守护线程：一般是为工作线程服务的，当所有的用户线程结束，守护线程自动结束。

※常见的守护线程：垃圾回收机制



###4）线程的生命周期

①【NEW】：尚未启动的线程处于此状态

> 当一个线程处于新创建状态时，程序还没有开始运行线程中的代码。在线程运行之前还有一些基础工作要做。

②【RUNNABLE】：在Java虚拟机中执行的线程处于此状态。可以细分成[READY]和[RUNNING]

③【BLOCKED】:被阻塞等待监视器锁定的线程处于此状态。

④【WAITING】:正在等待另一个线程执行特定动作的线程处于此状态。

⑤【TIMED_WAITING】:正在等待另一个线程执行动作达到指定等待时间的线程处于此状态。

> ③-⑤
>
> * 当一个线程试图获取一个内部的对象锁，而该锁被其他线程持有，则该线程进入阻塞状态。当所有其他线程释放该锁，并且线程调度器允许支持本线程持有它的时候，该线程将变成阻塞状态。
> * 当线程等待另一个线程通知调度器一个条件时，它自己进入等待状态。
> * 有几个方法有一个超时参数。调用它们导致线程进入计时等待(timed waiting)状态。这一状态将一直保持到超时期满或者接收到适当的通知。带有超时参数的方法有**Thread.sleep和Object.wait、Thread.join、Lock.tryLock以及Condition.await**的计时版。

⑥【TERMINATED】：已退出的线程处于此状态

> 终止原因：
>
> * 因为run方法正常退出而自然死亡
> * 因为一个没有捕获的异常终止了run方法而意外死亡。

![](https://pic-1317004580.cos.ap-guangzhou.myqcloud.com/%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7%E2%85%A0/2WF%7D6%7DLQBYYWAB%29%40DZJX4%29J.png)

![](https://pic-1317004580.cos.ap-guangzhou.myqcloud.com/%E7%AC%94%E8%AE%B0/11/22/%E7%BA%BF%E7%A8%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png)



![](https://uploadfiles.nowcoder.com/images/20211203/4107856_1638521150082/C07B66248A18C7A704A30D55EFDB2480)

## 四、Synchronized

###1）线程同步机制说明

①在多线程编程，一些敏感数据不允许被多个线程同时访问，访问就使用同步访问技术，保证数据在任何时刻最多有一个线程访问，以保证数据的完整性。

②线程同步：即当有一个线程在对内存进行操作时，其它线程都不可以对这个内存地址进行操作，直到该线程完成操作，其它线程才能对该内存地址进行操作。



###2）同步方法

①同步代码块

```java
synchronized(对象) {//得到对象的锁，才能操作同步代码
  //需要被同步的代码
}
```

②synchronized还可以放在方法声明中，表示整个方法为同步方法

```java
public synchronized void m(String name){
  //需要被同步的代码
}
```



### 3）说明

※修饰非静态方法 ，锁的是this； 对象修饰静态方法 ，锁的是class对象。

**synchronized不是修饰变量的，而是用来修饰方法或代码块的**

>   同步是害怕在操作过程的时候被其他线程也进行读取操作，一旦是原子性的操作就不会发生这种情况。 
>   因为一步到位的操作，其他线程不可能在中间干涉。++x，x++，x=y都有读取、操作两个步骤，而x=1则是原子性操作。 所以x=1不需要进行同步。



### 4）补充

> 从1.0版开始，Java中的每一个对象都有一个内部锁。如果一个方法用synchronized关键字声明，那么对象的锁将保护整个方法。也就是说，要调用该方法，线程必须获得内部的对象锁。

> 内部对象锁只有一个相关条件。wait方法添加一个线程到等待集中，notifyAll /notify方法解除等待线程的阻塞状态。
>
> wait、notifyAll以及notify方法是Object类的final方法。Condition方法必须被命名为await、signalAll和signal以便它们不会与那些方法发生冲突。

> 内部锁和条件存在一些局限。包括：
>
> ● 不能中断一个正在试图获得锁的线程。
>
> ● 试图获得锁时不能设定超时。
>
> ● 每个锁仅有单一的条件，可能是不够的。

> 下面是一些建议：
>
> ● 最好既不使用Lock/Condition也不使用synchronized关键字。在许多情况下你可以使用java.util.concurrent包中的一种机制，它会为你处理所有的加锁。例如，在14.6节，你会看到如何使用阻塞队列来同步完成一个共同任务的线程。还应当研究一下并行流。
>
> ● 如果synchronized关键字适合你的程序，那么请尽量使用它，这样可以减少编写的代码数量，减少出错的几率。
>
> ● 如果特别需要Lock/Condition结构提供的独有特性时，才使用Lock/Condition。

* 【void notifyAll()】：解除那些在该对象上调用wait方法的线程的阻塞状态。该方法只能在同步方法或同步块内部调用。如果当前线程不是对象锁的持有者，该方法抛出一个IllegalMonitorStateException异常。
* 【void notify()】：随机选择一个在该对象上调用wait方法的线程，解除其阻塞状态。该方法只能在一个同步方法或同步块中调用。如果当前线程不是对象锁的持有者，该方法抛出一个IllegalMonitorStateException异常。
* 【void wait()】：导致线程进入等待状态直到它被通知。该方法只能在一个同步方法中调用。如果当前线程不是对象锁的持有者，该方法抛出一个IllegalMonitorStateException异常。



### 5）同步阻塞

通过进入一个同步阻塞可以获得锁。

```java
//在一个类中：
synchronized(obj){
  //.....
}

//或者
private Object lock = new Object();
synchronized(lock){
  //.....
}
```

第一种情况：获得obj的锁。

第二种情况：lock对象被创建仅仅是用来使用每个Java对象持有的锁。



###6）监视器

1）监视器（monitor）可以在不需要考虑如何加锁的情况下，就可以保证多线程的安全性。

2）监视器具有如下特性：

* 监视器是只包含私有域的类
* 每个监视器类的对象有一个相关的锁。
* 使用该锁对所有的方法进行加锁。如果客户端调用obj.method()，那么obj对象的锁是在方法调用开始时自动获得，并且当方法返回时自动释放该锁。因为所有的域是私有的，这样的安排可以确保一个线程在对对象操作时，没有其他线程能访问该域。
* 该锁可以有任意多个相关条件。



### 7）final变量

将一个域声明为final，可以安全地访问一个共享域。

`final Map<String,Double> accounts = new HashMap<>();`

其他线程会在构造函数完成构造之后才看到这个accounts变量。

但是对这个映射表的操作不是线程安全的。如果多个线程在读写这个映射表，仍然需要进行同步。



## 五、互斥锁

###1）基本介绍

①Java语言中，引入了对象互斥锁的概念，来保证共享数据操作的完整性。

②每个对象都对应于一个可称为“互斥锁”标记，这个标记用来保证在任一时刻，只能有一个线程访问该对象。

③关键字synchronized来与对象的互斥锁联系。当某个对象用synchronized修饰时，表明该对象在任一时刻只能由一个线程访问。

④同步的局限性：导致程序的执行效率降低。

⑤同步方法（非静态的）的锁可以是this，也可以是其他对象（要求是同一个对象）

⑥同步方法（静态的）的锁为当前类本身。



###2）使用细节

[1] 同步方法如果没有使用static修饰，默认锁对象为【this】

[2] 如果方法使用static修饰，默认锁对象：【当前类.class】

[3] 实现步骤：

①需要先分析上锁的代码

②选择同步代码块或同步方法

③要求多个线程的锁对象为同一个即可。

## 六、死锁

###1）基本介绍

* 多个线程都占用了对方的锁资源，但不肯相让，导致了死锁，在编程是一定要避免死锁的发生。


###2）释放锁

[1]下面操作会释放锁

①当前线程的同步方法、同步代码块执行结束。

②当前线程在同步代码块、同步方法中遇到break、return。

③当前线程在同步代码块、同步方法中出现了未处理的Error或Exception，导致异常结束

④当前线程在同步代码块、同步方法中执行了线程对象的wait()方法，当前线程暂定，并释放锁。

[2]下面操作不会释放锁

①线程执行同步代码块或同步方法时，程序调用Thread.sleep()、Thread.yield()方法暂停当前线程的执行，不会释放锁。

②线程执行同步代码块时，其他线程调用了该线程的suspend()方法将该线程挂起，该线程不会释放锁。【应尽量避免使用suspend()和resume()来控制线程，方法过时】



## 七、线程属性

### 1）线程优先级

* 在Java程序设计语言中，每一个线程有一个优先级。默认情况下，一个线程继承它的父线程的优先级。可以用setPriority方法提高或降低任何一个线程的优先级。
* 每当线程调度器有机会选择新线程时，他首先选择具有较高优先级的线程。但是线程优先级是高度依赖于系统的。

※如果有几个高优先级的线程没有进入非活动状态，低优先级的线程可能永远也不能执行。每当调度器决定运行一个新线程时，首先会在具有高优先级的线程中进行选择，尽管这样会使低优先级的线程完全饿死。

### 2）守护线程

* 守护线程的唯一用途是为其他线程提供服务。
* 当只剩下守护线程时，虚拟机就退出了，由于如果只剩下守护线程，就没必要继续运行程序了。

※守护线程应该永远不去访问固有资源，如文件、数据库，因为它会在任何时候甚至在一个操作的中间发生中断。

> 【void setDaemon(boolean isDaemon)】：标识该线程为守护线程或用户线程。这一方法必须在线程启动之前调用。



## 八、补充

###1）CountDownLatch和CyclicBarrier

1）介绍

①**CountDownLatch**是一个同步的辅助类，允许一个或多个线程，<u>等待其他一组线程完成操作</u>，再继续执行。
②**CyclicBarrier**是一个同步的辅助类，允许一组线程相互之间等待，<u>达到一个共同点</u>，再继续执行。

2）区别

①CountDownLatch和CyclicBarrier都是用作多线程同步，CountDownLatch基于AQS，CyclicBarrier基于ReentrantLock
②CyclicBarrier支持复用和barrierCommand，但是CountDownLatch不支持。
③CyclicBarrier会阻塞线程，在最后一个任务执行线程完成之前，其余线程都必须等待，而线程在调用CountDownLatch的countDown方法之后就会结束。

3）使用场景对比

①CountdownLatch 使用场景：顾名思义CountdownLatch可以当做一个计数器来使用,比如某线程需要等待其他几个线程都执行过某个时间节点后才能继续执行 。

②CyclicBarrier 使用场景:所有线程在其他线程没有准备好之前都在被阻塞中,等到所有线程都准备好了才继续执行。

③在学习了CyclicBarrier之后发现，CyclicBarrier也可以实现跟CountDownLatch类似的功能，只需要在它的parties中多设置一个数，将主线程加入等待队列就可以了。



###2）volatile关键字

[1]前提：

* 多处理器的计算机能够暂时在寄存器或本地内存缓冲区中保存内存中的值。结果是，运行在不同处理器上的线程可能在同一个内存位置取到不同的值。
* 编译器可以改变指令执行的顺序以使吞吐量最大化。这种顺序上的变化不会改变代码语义，但是编译器假定内存的值仅仅在代码中有显式的修改指令时才会改变。然而，内存的值可以被另一个线程改变！

[2]介绍：volatile关键字为实例域的同步访问提供了一种免锁机制。如果声明一个域为volatile，那么编译器和虚拟机就知道该域是可能被另一个线程并发更新的。

[3]**volatile关键字有两个作用：**    

1.<u>并发环境可见性</u>：volatile修饰后的变量能够保证该变量在线程间的可见性，线程进行数据的读写操作时将绕开工作内存（CPU缓存）而直接跟主内存进行数据交互，即线程进行读操作时直接从主内存中读取，写操作时直接将修改后端变量刷新到主内存中，这样就能保证其他线程访问到的数据是最新数据    

2.<u>并发环境有序性</u>：通过对volatile变量采取内存屏障（Memory barrier）的方式来防止编译重排序和CPU指令重排序，具体方式是通过在操作volatile变量的指令前后加入内存屏障，来实现happens-before关系，保证在多线程环境下的数据交互不会出现紊乱。



> 一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义：
>
>
>    1）保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。
>
>
>    2）禁止进行指令重排序。
>
>
>   volatile只提供了保证访问该变量时，每次都是从内存中读取最新值，并不会使用寄存器缓存该值——每次都会从内存中读取。
>
>
>   而对该变量的修改，volatile并不提供原子性的保证。
>
>
>   由于及时更新，很可能导致另一线程访问最新变量值，无法跳出循环的情况
>
>
>   多线程下计数器必须使用锁保护。

> volatile单纯使用**不能保证线程安全**，他只是提供了一种弱的同步机制来确保修饰的变量的更新操作通知到其他线程，

> Volatile这个修饰符，它是针对多线程情况下出现的。当线程读取它修饰的变量时，都会强迫从主存中重新读取。

> volatile能保证数据的可见性，但不能完全保证数据的原子性，synchronized即保证了数据的可见性也保证了原子性。

### 3）线程安全的总结

> ①vector  
>
> ②stack(StringBuffer)  
>
> ③ hashtable(properties)   
>
> ④enum



### 4）ThreadLocal

**ThreadLocal类主要解决的就是让每个线程绑定自己的值，可以将ThreadLocal类形象的比喻成存放数据的盒子，盒子中可以存储每个线程的私有数据。**

ThreadLocal类用于创建一个线程本地变量

在Thread中有一个成员变量ThreadLocals，该变量的类型是ThreadLocalMap,也就是一个**Map**，它的键是threadLocal，值就是变量的副本，ThreadLocal为每一个使用该变量的线程都提供了一个变量值的副本，每一个线程都可以独立地改变自己的副本，是线程隔离的。

通过ThreadLocal的get()方法可以获取该线程变量的本地副本，在get方法之前要先set,否则就要重写initialValue()方法。

ThreadLocal不是用来解决对象共享访问问题的，而主要是提供了保持对象的方法和避免参数传递的方便的对象访问方式。一般情况下，通过ThreadLocal.set()到线程中的对象是该线程自己使用的对象，其他线程是不需要访的，也访问不到的。各个线程中访问的是不同的对象。

> ThreadLocal可以给一个初始值，而每个线程都会获得这个初始化值的一个副本，这样才能保证不同的线程都有一份拷贝。
>
> ThreadLocal不是用于解决共享变量的问题的，不是为了协调线程同步而存在，而是为了方便每个线程处理自己的状态而引入的一个机制.



### 5）java.concurrent包

> Semaphore：类，控制某个资源可被同时访问的个数; 
>
> ReentrantLock：类，具有与使用synchronized方法和语句所访问的隐式监视器锁相同的一些基本行为和语义，但功能更强大； 
>
> Future：接口，表示异步计算的结果；
>
> CountDownLatch： 类，可以用来在一个线程中等待多个线程完成任务的类。



### 6）线程调度算法

一般线程调度模式分为两种——抢占式调度和协同式调度。

* **抢占式调度**指的是每条线程执行的时间、线程的切换都由系统控制，系统控制指的是在系统某种运行机制下，可能每条线程都分同样的执行时间片，也可能是某些线程执行的时间片较长，甚至某些线程得不到执行的时间片。在这种机制下，一个线程的堵塞不会导致整个进程堵塞。
* **协同式调度**指某一线程执行完后主动通知系统切换到另一线程上执行，这种模式就像接力赛一样，一个人跑完自己的路程就把接力棒交接给下一个人，下个人继续往下跑。线程的执行时间由线程本身控制，线程切换可以预知，不存在多线程同步问题，但它有一个致命弱点：如果一个线程编写有问题，运行到一半就一直堵塞，那么可能导致整个系统崩溃。

 <u>java采用的是抢占式调度方式</u>。



### 7）读/写锁

java.util.concurrent.locks包定义了两个锁类，我们已经讨论的ReentrantLock类和ReentrantReadWriteLock类。如果很多线程从一个数据结构读取数据而很少线程修改其中的数据的话，后者十分有用。

写读写锁的步骤：

1.构造一个ReentrantReadWriteLock对象：

```java
private ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();
```

2.抽取读锁和写锁：

【Lock readLock()】：得到一个可以被多个读操作共用的读锁，但会排斥所有写操作。

【Lock writeLock()】：得到一个写锁，排除所有其他的读操作和写操作。

```java
private Lock readLock = rwl.readLock();
private Lock writeLock = rwl.writeLock();
```

3.对所有的获取方法加读锁：

```java
private double getTotalBalance(){
  readLock.lock();
  try{}
  finaly{readLock.unlock();}
}
```

4.对所有的修改方法加写锁

```java
public void transfer(...){
  writeLock.lock();
  try{}
  finally{writeLock.unlock();}
}
```



> CopyOnWriteArrayList适用于**写少读多**的并发场景 。
>
> ReadWriteLock即为读写锁，他要求写与写之间互斥，读与写之间互斥， 读与读之间可以并发执行。在**读多写少**的情况下可以提高效率 。
>
> ConcurrentHashMap是同步的HashMap，**读写都加锁** 。
>
> volatile只保证多线程操作的可见性，不保证原子性



### 8）阻塞队列

在协调多个线程之间的合作时，阻塞队列是一个有用的工具。

> 工作者线程可以周期性地将中间结果存储在阻塞队列中。其他的工作者线程移出中间结果并进一步加以修改。队列会自动地平衡负载。如果第一个线程集运行得比第二个慢，第二个线程集在等待结果时会阻塞。如果第一个线程集运行得快，它将等待第二个队列集赶上来。

![](https://pic-1317004580.cos.ap-guangzhou.myqcloud.com/%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7%E2%85%A0/SN%248G5%5DQT1B95~%252%7DRKCI6F.png)

阻塞队列方法分为以下三类，这取决于当队列满或空时它们的相应方式。

①如果将队列当作线程管理工具来使用，将要用到put和take方法。

②当试图向满的队列中添加或从空的队列中移出元素时，add、remove和element操作抛出异常。

③当然，在一个多线程程序中，队列会在任何时候空或满，因此，一定要使用offer、poll方法作为替代。

这些方法如果不能完成任务，只是给出一个错误提示而不会抛出异常。



### 9）线程通信的两种方式

在Java中，常用的线程通信方式有两种，分别是**利用Monitor实现线程通信、利用Condition实现线程通信**。线程同步是线程通信的前提，所以究竟采用哪种方式实现通信，取决于线程同步的方式。

​    如果是采用synchronized关键字进行同步，则需要依赖Monitor（同步监视器）实现线程通信，Monitor就是锁对象。在synchronized同步模式下，锁对象可以是任意的类型，所以通信方法自然就被定义在**Object**类中了，这些方法包括：wait()、notify()、notifyAll()。一个线程通过Monitor调用wait()时，它就会释放锁并在此等待。当其他线程通过Monitor调用notify()时，则会唤醒在此等待的一个线程。当其他线程通过Monitor调用notifyAll()时，则会唤醒在此等待的所有线程。   

 JDK 1.5新增了Lock接口及其实现类，提供了更为灵活的同步方式。如果是采用Lock对象进行同步，则需要依赖**Condition**实现线程通信，Condition对象是由Lock对象创建出来的，它依赖于Lock对象。Condition对象中定义的通信方法，与Object类中的通信方法类似，它包括await()、signal()、signalAll()。通过名字就能看出它们的含义了，当通过Condition调用await()时当前线程释放锁并等待，当通过Condition调用signal()时唤醒一个等待的线程，当通过Condition调用signalAll()时则唤醒所有等待的线程。





















