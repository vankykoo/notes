#面向对象编程（高级）

## 1、类变量和类方法（static）

### 一、类变量

**1）基本介绍**：类变量也叫静态变量/静态属性，是该类的所有对象<u>共享的</u>变量，任何一个该类的对象去访问它时，取到的都是相同的值，同样任何一个该类的对象去修改它时，修改的也是同一个变量。

**2）定义类变量语法：**

【访问修饰符 static 数据类型 变量名;】（推荐）  或【static 访问修饰符 数据类型 变量名;】

**3）访问类变量：**

【类名.类变量名】（推荐） 或【对象名.类变量名】

※静态变量的访问修饰符的访问权限和范围和普通属性是一样的。

※类变量是随着类的加载而创建的，所有即使<u>没有创建对象实例也可以访问</u>。

**4）使用细节**

```java
class A{
  private int num = 10;//普通属性、普通成员变量，非静态属性、非静态成员变量、实例变量  
  public static String name;//类变量、静态变量
}
```

①当我们需要让某个类的所有对象都共享一个变量时，就可以使用 类变量（静态变量）。

②类变量与实例变量的区别：类变量是该类的所有对象共享的，而实例变量是每个对象独享的。

③加上static称为类变量或静态变量，否则称为实例变量/普通变量/非静态变量

④实例变量不能通过【类名.类变量名】方式访问。

⑤类变量是在<u>类加载时就初始化</u>了，即使没有创建对象，只要类加载了，就可以使用类变量了。

⑥类变量的生命周期随类的加载开始，随着类消亡而销毁。



### 二、类方法

**1）类方法的定义：**	【访问修饰符 static 数据返回类型 方法名(){}】 （推荐）

​					【static 访问修饰符 数据返回类型 方法名(){}】

**2）类方法的调用：**【类名.类方法名】或 【对象名.类方法名】

※前提是满足访问修饰符的访问权限和范围。

**3）使用细节：**

① 当我们希望不创建实例也可以调用某个方法（即当做工具来使用），就可以把方法做成静态方法。

②类方法和普通方法都是随着类的加载而加载，将结构信息存储在方法区：

类方法中无this的参数 ，普通方法隐含this的参数。

③普通方法和对象有关，需要通过对象名调用，比如【对象名.方法名（参数）】，不能通过类名调用。

④类方法中不允许使用和对象有个的关键字，比如this、super。

⑤类方法（静态方法）中**只能访问**静态变量或静态方法。

​    普通成员方法可以访问非静态成员，也可以访问静态成员。

> 被static修饰的变量称为静态变量，静态变量属于整个类，而局部变量属于方法，只在该方法内有效，所以static不能修饰局部变量

> 编译看左边，运行看右边。  父类型引用指向子类型对象，无法调用只在子类型里定义的方法

> 类方法就是指类中用static 修饰的方法（非static 为实例方法），比如main 方法，那么可以以main方法为例，**可直接调用其他类方法，必须通过实例调用实例方法**

### 三、static

> 在static方法中是**不能访问非静态变量 a** 的，需要将 a 声明为static，答案才会是 0 ，否则是编译出错

> Java中静态变量只能在类主体中定义，**不能在方法中定义**。
> 静态变量属于类所有而不属于方法。

> static用于修饰成员变量和成员函数，想要实现对象中的共性数据的对象共享，可以将这个数据进行静态修饰，被静态修饰的成员可以直接被类名调用，静态随着类的加载而加载，而且优先于对象存在。**静态方法只能访问静态成员**（静态方法和静态变量），不可以访问非静态成员，这是因为静态方法加载时，优先于对象存在，所以没有办法访问对象中的成员。**静态方法中不能使用this和super关键字**，因为this代表本类对象，super代表父类对象，而静态时，有可能没有对象存在，所以this和super无法使用。

> 在A类通过类名访问B类的静态成员变量时，B类的静态成员变量必须**public**修饰  。

> 当类加载时，static静态方法随着类加载而初始化，此时实例对象还未被创建，但是**非静态成员变量需要等到实例对象创建才会被初始化**

> 在静态方法中调用本类的静态方法时可直接调用
>
> 在静态方法中**可直接调用本类的静态方法**，也可以通过类名.静态方法名的方式来调用其他类的静态方法

------

类加载：

> ![](https://pic-1317004580.cos.ap-guangzhou.myqcloud.com/%E6%9D%82/33/OEQK_%28AR69R%404%25DB%247QMORK.png)
>
> 解析：开始时JVM加载B.class，对所有的静态成员进行声明，t1  t2被初始化为默认值，为null，又因为t1  t2需要被显式初始化，所以对t1进行显式初始化，初始化代码块→构造函数（没有就是调用默认的构造数），咦！静态代码块咋不初始化？因为在开始时已经对static部分进行了初始化，虽然只对static变量进行了初始化，但在初始化t1时也不会再执行static块了，因为JVM认为这是第二次加载类B了，所以static会在t1初始化时被忽略掉，所以直接初始化非static部分，也就是构造块部分（输出''构造块''）接着构造函数（无输出）。接着对t2进行初始化过程同t1相同（输出'构造块'），此时就对所有的static变量都完成了初始化，接着就执行static块部分（输出'静态块'），接着执行，main方法，同样也，new了对象，调用构造函数输出（'构造块'）

## 2、理解main方法语法static

**1）解释main方法的形式**：【public static void main(String[] args){}】

①main方法是虚拟机调用的，java虚拟机需要调用类的main方法，所以该方法的访问权限必须是**public**。

②java虚拟机在执行main()方法时不必创建对象，所以该方法必须是static。

③该方法接收String类型的数据参数，该数组中保存执行java命令时传递给所运行的类的参数。

④通过【java 执行的程序 参数1 参数2 参数3 ...】传参数到数组args。

**2）特别说明**：

①在main()中，可以直接调用main方法所在类的静态方法或静态属性。

②不能直接访问该类中的非静态成员；若要访问，必须创建该类的一个实例对象后，才能通过这个对象去访问类中的非静态成员。

## 3、代码块

**1）基本介绍**：代码块又称初始化块，属于类中的成员，即是类的一部分，类似于方法，将逻辑语句封装在方法体中，通过{}包围起来。		

※但和方法不同，没有方法名，没有返回，没有参数，只有方法体，而且不用通过对象或类显式调用，而是加载类时，或创建对象时隐式调用。

※代码块相当于另外一种形式的构造器（对构造器的补充机制），可以 做初始化的操作。

**2）**

```java
//基本语法：
[修饰符]{
  代码;
};
//1）修饰符可写可不写，若写，只能写static。
//2）代码块分为两类，使用static修饰的叫静态代码块，没有static修饰的，叫普通代码块/非静态代码块
//3）逻辑语句（代码）可以为任何逻辑语句：输入、输出、方法调用、循环、判断....
//4）最后的分号可写可不写。
```

**3）使用细节：**

①static代码块也叫静态代码块，作用就是对类进行初始化，而且它随着类的加载而执行，并且<u>只会执行一次</u>；如果是普通代码块，每创建一个对象就调用一次。

②类加载的三种情况：

* 创建对象实例时（new一个对象时）
* 创建子类对象实例时，父类也会被加载（父类先加载）
* 使用类的静态成员时（属性/方法）。

③普通代码块在创建对象实例时，会被隐式调用，每创建一次，就会调用一次。如果只是类的静态成员，普通代码块并不会执行。

④创建一个对象时，在**一个类**调用顺序：

* 一、调用静态代码块和静态属性初始化（注意：静态代码块和静态属性初始化调用的优先级一样，如果有多个静态代码块和多个静态变量初始化，则<u>按他们定义的顺序</u>调用）
* 二、调用普通代码块和普通属性初始化（注意：普通代码块和普通属性初始化调用的优先级一样，如果有多个普通代码块和多个普通属性初始化，则按<u>定义顺序</u>调用）
* 三、调用构造方法。

⑤**构造器的最前面其实隐含了super()和调用普通代码块。**

```java
class A{
  public A(){//无参构造器
    //1、super();
    //2、调用普通代码块
    System.out.println("OK");
  }
}
```

⑥创建一个子类对象时（继承关系），他们的静态代码块，静态属性初始化，普通代码块，普通属性初始化，构造方法的调用顺序如下：

* 一、父类的静态代码块和静态属性初始化（优先级一样，按定义顺序执行）
* 二、子类的静态代码块和静态属性初始化（优先级一样，按定义顺序执行）
* 三、父类的普通代码块和普通属性初始化（优先级一样，按定义顺序执行）
* 四、父类的构造方法
* 五、子类的普通代码块和普通属性初始化（优先级一样，按定义顺序执行）
* 六、子类的构造方法

⑦静态代码块<u>只能</u>直接调用静态成员，普通代码块可以调用任何成员。



## 4、单例设计模式

### 1）定义

定义：确保一个类只有一个实例，并提供该实例的全局访问点。

好处：有些实例，全局只需要一个就够了，使用单例模式就可以避免一个全局使用的类，频繁的创建与销毁，耗费系统资源。



### 2）设计要素

* 一个私有构造函数（确保只能单例类自己创建实例）
* 一个私有静态变量（确保只有一个实例）
* 一个公有静态函数（给使用者提供调用方法）

※单例类的构造方法不让其他人修改和使用；并且单例类只创建一个实例，这个实例，其他人也无法修改和直接使用；然后单例类提供一个调用方法，想用这个实例，只能调用。这样就确保了全局只创建了一次实例。



### 3）6种实现及各实现的优缺点

#### 1）饿汉式（线程安全）

**说明**：先不管需不需要使用这个实例，直接先实例化好实例，然后当需要使用的时候，直接掉方法就可以使用了。

**优点**：提前实例化好了一个实例，避免了线程不安全问题的出现。

**缺点**：直接实例化好了实例，不再延迟实例化；若系统没有使用这个实例，或者系统运行很久之后才需要使用这个实例，都会造成系统的资源浪费。

```java
class GirlFriend{
  private String name;
  //为了能够在静态方法中，返回 gf对象，需要将其修饰为static
  private static GirlFriend gf = new GirlFriend("小红");
  //如何保障只能创建一个GirlFriend对象
  //步骤：
  //1、将构造器私有化
  //2、在类的内部直接创建
  //3、提供一个公共的static方法，返回 gf对象
  private GirlFriend(String name) {
    this.name = name;
  }
  
  public static GirlFriend getInstance(){
    return gf;
  }
}
```



####2）饿汉式（线程安全）

**说明**：实现和线程不安全的懒汉式几乎一样，唯一不同的点是，在get方法上加了一把锁。如此一来，多个线程访问，每次只有拿到锁的线程能够进入该方法，避免了多线程不安全问题的出现。

**优点**：延迟实例化，节约了资源，并且是线程安全的。

**缺点：**性能降低。因为即使实例已经实例化了，既后续不会出现线程安全问题了，但是锁还在，每次还是只能拿到锁的线程进入该方法使线程阻塞，等待时间过长。

```java
class Cat{
  private String name;
  private static Cat cat;
  
  private Cat(String name) {
    this.name = name;
  }
  public static synchronized Cat getInstance(){
    if(cat == null){//如果还没有创建Cat对象
      cat = new Cat("小花");
    }
    return cat;
  }
}
```



####3）懒汉式（线程不安全）

**说明：**先不创建实例，当第一次被调用时，再创建实例，所以被称为懒汉式。

**优点：**延迟了实例化，当第一次被调用时，再创建实例，节约了系统资源。

**缺点**：线程不安全。多线程环境下，如果多个线程同时进入了if(cat == null)，若此时还未实例化，也就是cat == null，那么就会有多个线程执行cat = new Cat("小花");，就会实例化多个实例。

```java
class Cat{
  private String name;
  private static Cat cat;//第二步
  //步骤：
  //1、仍然构造器私有化
  //2、定义一个static静态属性对象
  //3、提供一个public的static方法，可以返回一个Cat对象
  private Cat(String name) {
    System.out.println("构造器调用。。。");
    this.name = name;
  }
  public static Cat getInstance(){
    if(cat == null){//如果还没有创建Cat对象
      cat = new Cat("小花");
    }
    return cat;
  }
}
```

* **饿汉式与懒汉式**

1）二者最主要的区别在于创建对象的时机不同：饿汉式是在类加载就创建了对象实例，而懒汉式是在使用时才创建。

2）饿汉式不存在线程安全问题，懒汉式存在线程安全问题。

3）饿汉式存在浪费资源的可能。如果程序员一个对象实例都没有使用，那么饿汉式创建的对象就浪费了，懒汉式是使用时才创建，就不存在这个问题。



#### 4）双重检查锁实现（线程安全）

**说明**：双重检查锁相当于时改进了线程安全的懒汉式。线程安全的懒汉式的缺点是性能降低了，造成的原因是因为即使实例已经实例化，依然每次都会有锁。而现在，我们将锁的位置变了，并且多加了一个检查。也就是，先判断实例是否已经存在了，则不会执行判断方法内的有锁方法了。而如果还没有实例化的时候，多个线程进去了，也没有事，因为里面的方法有锁，只会让一个线程进入最内层方法并实例化实例。如此一来，最多最多，也就是第一次实例化的时候会有线程阻塞的情况，后续便不会有线程阻塞的问题。

**优点**：延迟实例化，节约了资源；线程安全；并且相对于线程安全的懒汉式，性能提高了。

**缺点**：volatile关键字，对性能也有一些影响。

```java
class Cat{
  private String name;
  private volatile static Cat cat;
  
  private Cat(String name) {
    this.name = name;
  }
  public static Cat getInstance(){
    if(cat == null){//如果还没有创建Cat对象
      synchronized (Cat.class){
        if(cat == null){
          cat = new Cat("小花");
        }
      }
    }
    return cat;
  }
}
```

> **为什么使用 volatile 关键字修饰了 cat 实例变量 ？**  
>
> cat = new Cat(); 这段代码执行时分为三步：  
>
> ①为 cat 分配内存空间 
>
> ②初始化 cat 
>
> ③将 cat 指向分配的内存地址  
>
> 正常的执行顺序当然是 1>2>3 ，但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1>3>2。
> 单线程环境时，指令重排并没有什么问题；多线程环境时，会导致有些线程可能会获取到还没初始化的实例。
> 例如：线程A 只执行了 1 和 3 ，此时线程B来调用 getCat()，发现 cat 不为空，便获取 cat 实例，但是其实此时的 uniqueInstance 还没有初始化。 解决办法就是加一个 volatile 关键字修饰 cat ，**volatile 会禁止 JVM 的指令重排**，就可以保证多线程环境下的安全运行。



#### 5）静态内部类实现（线程安全）

**说明：** 首先，当外部类 Cat被加载时，静态内部类 CatHolder 并<u>没有</u>被加载进内存。当调用 getCatInstance() 方法时，会运行 return CatHolder.INSTANCE;  ，触发了 CatHolder .INSTANCE ，此时静态内部类 CatHolder 才会被加载进内存，并且初始化 INSTANCE 实例，**而且 JVM 会确保 INSTANCE 只被实例化一次**。

**优点**：延迟实例化，节约了资源；线程安全；性能提高了。

```java
class Cat{
  private String name;
  private static Cat cat;
  
  private Cat(String name) {
    this.name = name;
  }
  
  private static class CatHolder{
    private static final Cat INSTANCE = new Cat("小花");
  }
  private static Cat getCatInstance(){
    return CatHolder.INSTANCE;
  }
}
```



#### 6）枚举类实现（线程安全）

说明：默认枚举实例的创建就是线程安全的，且在任何情况下都是单例。

优点：写法简单，线程安全，天然防止反射和反序列化调用。

```java
public enum Cat{
  INSTANCE;
  //添加自己需要的操作
  public void doSomeThing(){
    
  }
}
```



> **防止反序列化：**
>
> 反序列化将一个单例实例对象写到磁盘再读回来，从而获得了一个新的实例。我们要防止反序列化，避免得到多个实例。
>
> 枚举类天然防止反序列化。



### 4）应用场景

**[1]应用场景举例：**   

①网站计数器。 

②应用程序的日志应用。 

③Web项目中的配置对象的读取。 

④数据库连接池。 

⑤多线程池。 ...... 



 **[2]使用场景总结：**  

**①频繁实例化然后又销毁的对象**，使用单例模式可以提高性能。 

**②经常使用的对象，但实例化时耗费时间或者资源多**，如数据库连接池，使用单例模式，可以提高性能，降低资源损坏。 

**③使用线程池之类的控制资源时**，使用单例模式，可以方便资源之间的通信。



## 5、final关键字

###**1)基本介绍：**

final可以修饰类、属性、方法和局部变量。

①当<u>不希望类被继承</u>时，可以用final修饰。

②当<u>不希望父类的某个方法被子类**覆盖/重写**</u>时，可以用final关键字修饰。

```java
访问修饰符 final 返回类型 方法名(){}
```

③当<u>不希望类的某个属性的值被修改</u>，可以用final修饰。

```java
public final double TAX_RATE = 0.08;
```

④当<u>不希望某个局部变量被修改，</u>可以用final修饰。

```java
final double TAX_RATE = 0.08;
```

###**2）使用细节：**

①final修饰的属性又叫常量，一般用XX_XX_XX（大写）来命名。

②final修饰的属性在定义时，必须赋初值，并且以后不能再修改，赋值可以在如下位置之一：

```java
class A{
  public final double TAX_RATE1 = 0.08;//1.定义时赋值
  public final double TAX_RATE2;
  public final double TAX_RATE3;
  
  public A(){//2.在构造器中赋值
    TAX_RATE2 = 0.08;
  }
  
  {//3.在代码块赋值
    TAX_RATE3 = 0.08;
  }
}
```

③如果final修饰的属性是静态的，则初始化的位置只能是如下两种，<u>不能在构造器中赋值！</u>

```java
class B{
  public static final double TAX_RATE1 = 0.08;//1.定义时赋值
  public static final double TAX_RATE2;
  
  static{//2.在静态代码块中
    TAX_RATE2 = 0.08;
  }
}
```

④final类不能继承，但可以实例化（new）对象。

⑤如果类不是final类，但是含有final方法，**则该方法虽然不能重写**，但是可以被继承。

⑥一般来说，如果一个类已经是final类了，就没有必要再将方法修饰成final方法。

⑦final不能修饰构造方法（构造器）。

⑧final和static往往搭配使用，效率更高，不会导致类加载，底层编译器做了优化处理。

⑨包装类（Integer，Double,Float,Boolean等都是final），String也是final类。

⑩final修饰方法后，方法是不可被重写的，因为它已经是“最终形态”了。但不会影响重载

> final的成员方法实现中能读取类的成员变量、实例变量。

## 6、抽象类

**1）基本介绍：**当父类的一些方法不能确定时，可以用**abstract**关键字来修饰该方法，这个方法就是抽象方法，用**abstract**来修饰该类就是抽象类。

```java
//例子/快速入门
abstract class Animal{
  String name;
  int age;
  abstract public void cry();//没有方法体
}
```

①用abstract关键字来修饰一个类时，这个类就叫抽象类。

【访问修饰符 abstract 类名{}】

②用abstract关键字来修饰一个方法时，这个方法就是抽象方法。

【访问修饰符 abstract 返回类型 方法名 (参数列表);】（没有方法体）

③抽象类的价值更多作用是在于设计，是设计者设计好后，让子类继承并实现抽象类()。

**2）使用细节：**

①**抽象类不能被实例化**

②抽象类不一定要包含abstract方法。也就是说，抽象类可以没有abstract方法。

③一旦类包含了abstract方法，则这个类必须声明为abstract类。

④abstract<u>只能修饰类和方法</u>，不能修饰属性和其它的。

⑤抽象类可以有任意成员【抽象类本质还是类】

⑥抽象方法不能有主体，即不能实现。

⑦**如果一个类继承了一个抽象类，则它必须实现抽象类的所有抽象方法，除非它自己也声明为abstract类。**

⑧抽象方法不能使用private、final和static来修饰，因为这些关键字都是和重写相违背的。

⑨abstract类只能用来派生子类，不能用来创建abstract类的对象。

⑩接口和抽象类都可以被声明使用。

> ①当一个类的一个或多个方法是抽象方法时
>
> ②当类是一个抽象类的子类，并且不能为任何抽象方法提供任何实现细节或方法体时
>
> ③当一个类实现一个接口，并且不能为任何抽象方法提供实现细节或方法体时
>
> 以上情况下该类一定为抽象类。



> 抽象方法只能定义在抽象类中，抽象方法和抽象类必须由abstract修饰，abstract关键字**只能描述类和方法**，不能描述变量。抽象方法只定义方法声明，不定义方法实现。抽象类不可以被实例化（创建对象），只有通过子类继承抽象类并覆盖抽象类中的所有抽象方法后，该子类才可以被实例化，否则该子类还是一个抽象类。抽象类中有构造函数用于给子类对象进行初始化，同时抽象类中可以含有非抽象方法。**abstract关键字不可以与final，private,static关键字共存**，因为被final修饰的方法不可以被重写，意味着子类不可以重写该方法，如果abstract和final共同修饰父类中的方法，子类要实现抽象方法（abstract的作用），而final又不让该方法重写，这相互矛盾。如果private和abstract共同修饰父类中的方法，private修饰则该方法不可以被子类访问，但是abstract修饰需要子类去实现，两者产生矛盾。如果static和abstract共同修饰父类中的方法，static表示是静态的方法，随着类的加载而加载，则该方法不需要在子类中去实现，这与abstract关键字矛盾。

**3）实践---模板设计模式**

```java
//设计一个抽象类（Template），能完成如下功能：
//1）编写方法calculateTime(),可以计算某段代码的耗时时间
//2）编写抽象方法job()
//3）编写一个子类Sub，继承抽象类Template，并实现job方法
//4）编写一个测试类TestTemplate，看看是否好用

abstract class Template{//抽象类
  pubilc abstract void job();//抽象方法
  public void caleTimes(){
    long start = System.currentTimeMillis();//开始时间
    job();
    long end = System.currentTimeMillis();//结束时间
    System.out.println("耗时：" + (end - start));
  }
}
```



## 7、接口

**1）基本介绍**：接口就是给出一些没有实现的方法，封装到一起，到某个类要使用的时候，再根据具体情况把这些方法写出来。

**2）语法**：

```java
//创建接口
interface 接口名{
  属性;
  方法;（1.抽象方法 2.默认实现方法[default] 3.静态方法[static]）
}

//实现接口
class 类名 implements 接口{
  自己属性;
  自己方法;
  必须实现的接口的抽象方法;
}
```

※①再jdk7.0之前，接口里的所有方法都没有方法体，即都是抽象方法。

②jdk8.0之后接口可以有静态方法、默认方法，也就是说接口中可以有方法的具体实现。

**3）使用细节**

①**接口不能被实例化**。

②接口中所有的方法**是public方法**，接口中抽象方法可以不用abstract修饰。

③一个<u>普通类</u>实现接口，就必须将该接口的所有方法都实现。

④<u>抽象类</u>实现接口，可以不用实现接口的方法。

⑤一个类同时可以实现多个接口。

⑥**接口中的属性只能是final的，而且是<u>public static final</u> 修饰符，且必须初始化**。

```java
interface IA{
  int a = 1;//实际为public static final int a = 1;
}
```

⑦接口中属性的访问语法：【接口名.属性名】

⑧接口不能继承其它类，但可以继承多个别的接口。【即接口与接口之间可以是继承关系】

⑨接口的修饰符<u>只能</u>是**public和默认**，这点和类的修饰符是一样的。

⑩面向对象设计时，每个类的职责应该单一，不要在一个类中引入过多的接口。

11、可以为接口方法提供一个默认实现。必须用**default修饰符**标记这样一个方法。不过这并没有太大用处。

>   **1、必须实现接口中所有的方法。**    
>
>   在实现类中实现接口时，方法的名字、返回值类型、参数的个数及类型必须与接口中的完全一致，并且必须实现接口中的所有方法。   
>
>   **2、接口实现类相当于子类，子类的访问权限是不能比父类小的。**   
>
>   接口中所有方法默认都是public，至于为什么要是public，原因在于如果不是public，那么只能在同个包下被实现，可访问权限就降低很多了，那么在实现类中，实现的类相当于子类，子类的访问权限是不能比父类小的，而在java中一个类如果没有权限的修饰符，默认是default(同一个包内的其它类才可访问)，所以在实现类中一定要写public 



**4）实现接口VS继承类**

* 接口和继承解决的问题不同

继承：解决代码的复用性和可维护性。

接口：设计好各种规范（方法），让其它类去实现这些方法。

* 接口比继承更加灵活：

继承是满是 is - a 的关系，而接口只需满足 like - a 的关系。

* 接口在一定程度上实现代码解耦[接口规范性+动态绑定机制]。

**5）接口的多态传递现象**：接口类型的变量可以指向实现了该接口的类的对象实例。

6）解决默认方法冲突

> 如果先在一个接口中将一个方法定义为默认方法，然后又在超类或另一个接口中定义了同样的方法，会发生什么情况？规则如下：
>
> 1）超类优先。如果超类提供了一个具体方法，同名而且有相同参数类型的默认方法会被忽略。
>
> 2）接口冲突。如果一个超接口提供了一个默认方法，另一个接口提供了一个同名而且参数类型（不论是否是默认参数）相同的方法，必须覆盖这个方法来解决冲突。



### 3）接口vs抽象类

> 接口（interface）可以说成是抽象类的一种特例，接口中的所有方法都必须是抽象的。接口中的方法定义默认为public  abstract类型，接口中的成员变量类型默认为public static final。另外，接口和抽象类在方法上有区别：     
>
> 1. 抽象类可以有构造方法，接口中不能有构造方法。   
>
>
> 2. 抽象类中可以包含非抽象的普通方法，接口中的所有方法	  必须都是抽象的，不能有非抽象的普通方法。 
> 3. 抽象类中可以有普通成员变量，接口中没有普通成员变量  
> 4. 抽象类中的抽象方法的访问类型可以是public，protected和默认类型 
> 5. 抽象类中可以包含静态方法，接口中不能包含静态方法 
> 6. 抽象类和接口中都可以包含静态成员变量，抽象类中的静态成员变量的访问类型可以任意，但接口中定义的变量只能是public  static final类型，并且默认即为public static final类型 
> 7. 一个类可以实现多个接口，但只能继承一个抽象类。二者在应用方面也有一定的区别：接口更多的是在系统架构设计方法发挥作用，主要用于定义模块之间的通信契约。而抽象类在代码实现方面发挥作用，可以实现代码的重用，例如，模板方法设计模式是抽象类的一个典型应用，假设某个项目的所有Servlet类都要用相同的方式进行权限判断、记录访问日志和处理异常，那么就可以定义一个抽象的基类，让所有的Servlet都继承这个抽象基类，在抽象基类的service方法中完成权限判断、记录访问日志和处理异常的代码，在各个子类中只是完成各自的业务逻辑代码。

## 8、内部类

**※外部类**前可以修饰：**public、default、abstract、final** 

###**1）基本介绍**

一个类的内部又完整地嵌套了另一个类结构。被嵌套的类称为内部类（inner class），嵌套其他类的类称为外部类。

※类的五大成员：属性、方法、构造器、代码块、内部类。



> 内部类中声明的所有静态域都必须是final。原因很简单。我们希望一个静态域只有一个实例，不过对于每个外部对象，会分别有一个单独的内部类实例。如果这个域不是final，它可能就不是唯一的。内部类不能有static方法。
>
> Java语言规范对这个限制没有做任何解释。也可以允许有静态方法，但只能访问外围类的静态域和方法。显然，Java设计者认为相对于这种复杂性来说，它带来的好处有些得不偿失。

###**2）基本语法：**

```java
class Outer{//外部类
  class Inner{//内部类
    
  }
}
class Other{//外部其它类
}
```

###**3）内部类的分类：**

* 定义在外部类局部位置上（比如方法内）：

①局部内部类（有类名）

②匿名内部类（没有类名）

* 定义在外部类的成员位置上：

①成员内部类（没用static修饰）

②静态内部类（使用static修饰）



![](https://uploadfiles.nowcoder.com/images/20180701/3807435_1530425536125_D49BCBCCF82CF58C566E12F1E3130070)

### **4）局部内部类**

（本质是一个类）

①定义在外部类的局部位置，通常是在方法中，并且有类名。

②可以<u>直接访问</u>外部类的所有成员，包含私有的。

③不能添加访问修饰符，因为它的地位就是一个局部变量。局部变量是**不能使用修饰符的**。但是可以用final修饰，因为局部变量也可以使用final。

④作用域：仅仅在定义它的方法或代码块中。

⑤局部内部类访问外部类的成员方式：直接访问。

⑥外部类访问局部内部类成员方式：创建对象->访问（必须在作用域内）

⑦外部其他类不能访问局部内部类，因为局部内部类地位是一个局部变量。

⑧如果外部类和局部内部类的成员重名时，默认<u>遵循就近</u>原则，如果想访问外部类的成员，

则可以使用【外部类名.this.成员】去访问

※ 【外部类名.this】本质就是外部类的对象，即调用了这个内部类的方法的对象。

###**5）匿名内部类**：

Ⅰ.快速入门

```java
//main
{
  Outer outer = new Outer();
  outer.method();
}

class Outer{
  private int n1 = 10;
  public void method(){
    IA tiger = new IA(){//创建匿名内部类
      public void cry(){//重写
        System.out.println("老虎叫");
      }
    };
    
  }
}
interface IA{
  
}
class Tiger implements IA{
  public void cry(){
    
  }
}
```



Ⅱ.匿名内部类的使用：匿名内部类**既是一个类的定义，同时它本身也是一个对象**，因此从语法上看，它既有定义类的特征，也有创建对象的特征，

```java
class Outer{
  private int n = 99;
  public void f1(){
//第一种
    Person person = new Person(){
      public void hi(){
        System.out.println("匿名内部类重写了hi方法");
      }
    }
    person.hi();

//第二种
    new Person(){
      public void hi(){
        System.out.println("匿名内部类重写了hi方法");
      }

      public void ok(String name){
        super.ok(str);
      }.ok("jack");		//这里在后面之间调用
    
  	}
  }
  
}

class Person{
  public void hi(){
    System.out.println("hihihi");
  }
  public void ok(String name){
    System.out.println("okok" + name);
  }
}
```

Ⅲ.使用细节：

①**可以直接访问外部类的所有成员**，包括私有的。

②**不能添加访问修饰符**，因为它的地位就是一个**局部变量**。

③作用域：仅仅在定义它的方法或代码块中。

④**外部其他类不能访问匿名内部类。**

⑤如果外部类和匿名内部类的成员重名时，匿名内部类访问的话，默认遵循就近原则，如果想访问外部类的成员，则可以使用【外部类名.this.成员】去访问。

⑥由于构造器的名字必须与类名相同，而匿名类没有类名，所以匿名类不能有构造器。

Ⅳ.实践：

```java
//一、
//main中
{
  f1(new IL(){
    public void show(){
      System.out.println("hihihi");
    }
  });//当做实参直接传递，简洁高效。
  
  public static void f1(IL il){
    il.show();
  }
}
interface IL{
  void show(){
  }
}
```



###**6）成员内部类：**

Ⅰ.基本介绍：成员内部类是定义在外部类的成员位置，并且没有static修饰。

```java
class Outer{//外部类
  private int n1 = 10;
  public String name = "张三";
  class Inner{//内部类
    public void say(){
      System.out.println("n1=" + n1 + "name=" + name);//可以直接 访问
    }
  }
}
```



Ⅱ.使用细节：

①可以<u>直接</u>访问外部类的所有成员，包括私有的

②**可以添加任意访问修饰符（public、protected、默认、private）**，因为它的地位就是一个成员。

③作用域：和外部类的其它成员一样，为整个类体

④外部类访问成员内部类方式：创建对象，再访问

⑤外部其他类访问成员内部类方式：

```java
{//外部其他类
  //方法一
  Outer outer = new Outer();
  Inner inner = outer.new inner();		//在outer内new一个inner类
  //方法二：使用一个方法来获取
  Inner inner = new Outer.getInner();
}

{//外部类创建方法（方法二）
  public Inner getInner(){
    return new Inner();
  }
}
```

⑥如果外部类和内部类的成员重名时，内部类访问的话，默认遵循<u>就近原则</u>，如果想访问外部类的成员，则可以使用【外部类名.this.成员】去访问。



###**7）静态内部类**

Ⅰ.基本介绍：静态内部类是定义在外部类的成员位置，并且有static修饰。

```java
class Outer{
  private int n1 = 10;
  private static String name = "张三";
  static class Inner{
    public void say(){
      System.out.println("name=" + name);
    }
  }
  new Inner().say();
}
```

Ⅱ.使用细节

①可以直接访问外部类的<u>所有静态成员</u>，包含私有的，但<u>不能直接访问</u>非静态成员。

②可以添加任意访问修饰符（public、protected、默认、private）因为它的地位就是一个成员。

③作用域：同其它的成员一样，为整个类体。

④外部类访问静态内部类方式：创建对象，再访问

⑤外部其他类访问静态内部类方式：

```java
//main
{
  Outer outer = new Outer();
  //方式一
  Outer.Inner inner = new Outer.Inner();
  inner.say();
  //方式二：编写一个方法返回静态内部类
  Outer.Inner inner = outer.getInner();
  //方式三：编写一个静态方法，不用创建对象
  Outer.Inner inner = Outer.getInner();
}

class Outer{//外部类
  static class Inner{
    public void say(){
      Sys.out.println("name");
    }
  }
  
  public Inner getInner(){//编写一个方法
    return new Inner();
  }
  public static Inner getInner(){//编写一个静态方法
    return new Inner();
  }
}
```

⑥如果外部类和静态内部类的成员重名时，静态内部类访问时，默认遵循就近原则，如果想访问外部类的成员，则可以使用【外部类名.成员】去访问。

>   1.静态内部类才可以声明静态方法 
>   2.静态方法不可以使用非静态变量 





![](https://uploadfiles.nowcoder.com/images/20190109/242025553_1547012774538_BA9669C5826A238ACEC0BD86755FA5DB)



## 9、对象克隆

3）使用细节

①clone方法是Object的一个protected方法，这说明你的代码不能直接调用这个方法。子类只能调用受保护的clone方法来克隆它自己的对象。必须重新定义clone为public才能允许所有方法克隆对象。

②默认的克隆操作是“浅拷贝”，并没有克隆对象中引用的其他对象。

![浅拷贝](https://pic-1317004580.cos.ap-guangzhou.myqcloud.com/%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7%E2%85%A0/XH%7B%24MI0TZO%40ZQW20L21D9A4.png)

③不过，通常子对象都是可变的，必须重新定义clone方法来建立一个深拷贝，同时克隆所有子对象。



## 10、补充

### 1）中间件

**中间件**是一种独立的系统软件或服务程序，分布式应用软件借助这种软件在不同的技术之间共享资源。中间件位于客户机/服务器的操作系统之上，管理计算机资源和网络通讯。是连接两个独立应用程序或独立系统的软件。相连接的系统，即使它们具有不同的接口，但通过中间件相互之间仍能交换信息。执行中间件的一个关键途径是信息传递。通过中间件，应用程序可以工作于多平台或OS环境。 
  （简单来说，中间件并不能提高内核的效率，一般只是负责网络信息的分发处理） 



###2）JAR文件

①介绍：JAR文件（Java归档，Java Archive），一种软件包文件格式。通常用于聚合大量的Java类文件、相关的元数据和资源（文本、图片等）文件到一个文件，以便开放Java平台应用软件或库。

※jar文件是一种归档文件，以ZIP格式构建，以.jar为文件扩展名。用户可以使用JDK自带的jar命令创建或提取JAR文件。也可以使用其他ZIP压缩工具，不过压缩时zip文件头里的条目顺序很重要，因为Manifest文件常需放在首位。JAR文件内的文件名是Unicode文本。



②清单文件

* 除了类文件、图像和其他资源外，每个jar文件还包含一个用于描述归档特征的清单文件(manifest)
* 清单文件被命名为MANIFEST.MF，它位于jar文件的一个特殊META-INF子目录中。最小的符合标准的清单文件是很简单的。
* 复制的清单文件可能包含更多条目。这些清单条目被分成多个节。第一节被称为主节(main section)。他作用于整个JAR文件。随后的条目用来指定已命名条目的属性，这些已命名的条目可以是某个文件、包或者URL。他们都必须起始于名为Name的条目。节与节之间用空行分开。



③资源

* 在applet和应用程序中使用的类通常需要使用一些相关的数据文件，例如：
  * 图像和声音文件。
  * 带有消息字符串的按钮标签的文本文件。
  * 二进制数据文件，例如，描述地图布局的文件。
* 在Java中这些关联的文件被称为资源（resource）。




### 3）堆的分区

  Java 中的堆是 JVM 所管理的最大的一块内存空间，主要用于存放各种类的实例对象。  

在 Java 中，堆被划分成两个不同的区域：**新生代 ( Young )、老年代 ( Old )**。新生代 ( Young ) 又被划分为三个区域：<u>Eden、From Survivor、To Survivor</u>。
这样划分的<u>目的</u>是为了使 **JVM** 能够更好的管理堆内存中的对象，包括内存的分配以及回收。
堆的内存模型大致为：![](http://www.blogjava.net/images/blogjava_net/fancydeepin/JVM/%E5%A0%86%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B2.png)



※ **JVM** 每次只会使用 Eden 和其中的一块 Survivor 区域来为对象服务，所以无论什么时候，总是有一块 Survivor 区域是空闲着的。
 因此，新生代实际可用的内存空间为 9/10 ( 即90% )的新生代空间。



### 4）CMS收集器

  CMS收集器是一种以获取最短回收停顿时间为目标的收集器，它是基于标记清除算法实现的，它的运作过程相对于其他收集器来说要更复杂一些，整个过程分为四个步骤，包括：初始标记、并发标记、重新标记、并发清除。其中初始标记、重新标记这两个步骤需要暂停整个JVM。           

* **初始标记**仅仅只是标记一下GC Roots能直接关联到的对象，速度很快。              
* **并发标记**阶段就是从GC Roots的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行。              
* **重新标记**阶段则是为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间通常会比初始标记阶段稍长一些，但也远比并发标记阶段的时间短。              
* **并发清除**阶段，清理删除掉标记阶段判断的已经死亡的对象，由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的。![](https://uploadfiles.nowcoder.com/images/20211203/4107856_1638521452222/824E152C4D43EF1E4D3B112755F4D242)




### 5）off-heap

off-heap叫做堆外内存，将你的对象从堆中脱离出来序列化，然后存储在一大块内存中，这就像它存储到磁盘上一样，但它仍然在RAM中。对象在这种状态下不能直接使用，它们必须首先反序列化，也不受垃圾收集。序列化和反序列化将会影响部分性能（所以可以考虑使用FST-serialization）使用堆外内存能够降低GC导致的暂停。堆外内存不受垃圾收集器管理，也不属于老年代，新生代。



### 6）基本类型变量和引用类型变量的赋值原理

一、基本变量赋值

> public void method() {
> ​    int a = 1;
> ​    int b = a;
> }
>
> * 将 int 型 1 推送至操作数栈栈顶
> * 将操作数栈栈顶 int 型值存入第二个本地变量
> * 将第二个int型本地变量推送至操作数栈顶
> * 将操作数栈栈顶 int 型值存入第三个本地变量
> * 方法返回
>
> ![](https://uploadfiles.nowcoder.com/images/20210403/295024425_1617423311067/E233F218A90B7A00B94B7F533A98C0A2)



二、引用类型变量赋值

> public void method2() {
> ​    Object a = new Object();
> ​    Object b = a;
> }
>
> * 创建一个对象，并将其引用压入栈顶
> * 复制栈顶引用类型数据并将其值压入栈顶
> * 执行对象构造方法（使用了栈顶引用类型）
> * 将操作数栈栈顶引用类型数据值存入第二个本地变量 a
> * 将第二个引用类型本地变量推送至栈顶
> * 将栈顶引用类型数值存入第三个本地变量b
> * 方法返回
>
> ![](https://uploadfiles.nowcoder.com/images/20210403/295024425_1617423324866/1A8F685C15FEEF92820538FEA13FF231)



> "值类型数据是在**栈（指虚拟机栈）上分配**内存空间，它的变量直接包含变量的实例，使用效率相对较高。" ：**局部变量表（在虚拟机栈中）**中存放数值的就是真正意义上的数据，不用访问堆，效率较高             
>
> “而引用类型数据是分配在**堆**上，引用类型的变量通常包含一个**指向实例**（指向堆中对象）的指针，变量通过指针来引用实例。” ：局部变量表中存放的数值是指向**堆**中数据（对象）的指针。      



### 7）JVM

>   JVM大体分为堆、栈、方法区和程序计数器四个部分。
>
>   其中<u>堆和方法区</u>对**线程共享**，<u>栈和程序计数器</u>**对线程隔离**。
>
>   堆：存放数组和对象实例 
>
>   栈：存放局部变量和数据类型    
>
>   方法区：存放静态变量、常量、类信息和代码 

> 题目：假如某个JAVA进程的JVM参数配置如下：
>  `-Xms1G -Xmx2G -Xmn500M -XX:MaxPermSize=64M -XX:+UseConcMarkSweepGC -XX:SurvivorRatio=3,` 
>  请问eden区最终分配的大小是多少？
>
> 这些参数是JVM（Java虚拟机）的启动参数，用于配置JVM的内存管理和垃圾回收等行为。下面是您提供的每个参数的含义：
>
> - `-Xms1G`：设置JVM初始堆内存大小为1G。
> - `-Xmx2G`：设置JVM最大堆内存大小为2G。
> - `-Xmn500M`：设置新生代大小为500M。
> - `-XX:MaxPermSize=64M`：设置永久代最大内存大小为64M（注意，这个参数在Java 8及以上版本中已经被移除，取而代之的是`-XX:MaxMetaspaceSize`）。
> - `-XX:+UseConcMarkSweepGC`：设置使用CMS（Concurrent Mark Sweep）垃圾回收器。
> - `-XX:SurvivorRatio=3`：设置新生代中两个Survivor区域与一个Eden区域的比例为1:3。
>



### 8）接口和抽象类的区别

> 含有abstract修饰符的class即为抽象类，abstract类不能创建的实例对象。
>
> 含有abstract方法的类必须定义为abstract class，abstract class类中的方法不必是抽象的。abstract class类中定义抽象方法必须在具体(Concrete)子类中实现，所以，不能有抽象构造方法或抽象静态方法。如果的子类没有实现抽象父类中的所有抽象方法，那么子类也必须定义为abstract类型。 
>
> 接口（interface）可以说成是抽象类的一种特例，接口中的所有方法都必须是抽象的。接口中的方法定义默认为public
>   abstract类型，接口中的成员变量类型默认为public static final。 
>
> 下面比较一下两者的语法区别： 
>
> 1.抽象类可以有构造方法，接口中不能有构造方法。 
>
> 2.抽象类中可以有普通成员变量，接口中没有普通成员变量 
>
> 3.抽象类中可以包含非抽象的普通方法，接口中的所有方法必须都是抽象的，不能有非抽象的普通方法。 
>
> 4. 抽象类中的抽象方法的访问类型可以是public，protected和（默认类型,虽然eclipse下不报错，但应该也不行），但接口中的抽象方法只能是public类型的，并且默认即为public abstract类型。 
>
>
> 5. 抽象类中可以包含静态方法，接口中不能包含静态方法 
>
> 6.抽象类和接口中都可以包含静态成员变量，抽象类中的静态成员变量的访问类型可以任意，但接口中定义的变量只能是public static final类型，并且默认即为public static final类型。 
>
> 7. 一个类可以实现多个接口，但只能继承一个抽象类。 
>
>
>
> 下面接着再说说两者在应用上的区别： 
>
> 接口更多的是在系统架构设计方法发挥作用，主要用于定义模块之间的通信契约。而抽象类在代码实现方面发挥作用，可以实现代码的重用， 
>
> 例如，模板方法设计模式是抽象类的一个典型应用，假设某个项目的所有Servlet类都要用相同的方式进行权限判断、记录访问日志和处理异常，那么就可以定义一个抽象的基类，让所有的Servlet都继承这个抽象基类，在抽象基类的service方法中完成权限判断、记录访问日志和处理异常的代码，在各个子类中只是完成各自的业务逻辑代码，



### 9）JRE

一般后台线程用于处理时间较短的任务，如在一个Web服务器中可以利用后台线程来处理客户端发过来的请求信息。 而前台线程一般用于处理需要长时间等待的任务，如在Web服务器中的监听客户端请求的程序，或是定时对某些系统资源进行扫描的程序。 所以**jre判断程序是否执行结束的标准为：所有的前台线程执行完毕**。