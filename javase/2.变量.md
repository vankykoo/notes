# 变量

## 1、变量介绍

概念：变量相当于内存中一个数据存储空间的表示。

包含：类型，名称，数值

### ※变量使用的注意事项

<u>**定义在方法中的局部变量，使用前必须初始化，否则就会出现错误。**</u>

原理：当我们新建一个对象时，Java会在Heap中申请一块内存区域用以存放类的数据。而成员变量就是类的数据，也是放在这块内存区域中的。初始化时只需要JVM在申请内存的时候顺便把整块区域都置为零即可完成。所以JVM会自动帮我们完成全局变量的初始化。    对于方法的局部变量，是在线程的Stack中，虽然Stack可以帮我们完成初始化，但这样是存在问题的，比如有些局部变量，在方法的一开始是没有的，有些在循环中的局部变量是要反复的声明多次的。有些局部变量作用域结束后，另一个局部变量又会占用这个局部变量的位置。    局部变量不自动初始化是一种约束，它会尽最大程度减少使用者犯错的可能。假使局部变量可以使用默认值，可能总会无意间忘记赋值，进而导致不可预期的情况出现。 

## 2、+号的使用

1）当左右两边都是数值型时，则做加法运算

2）当左右两边有一方为字符串，则做拼接运算

3）运算顺序为从左到右

例如：

```java
System.out.println(100+98);//输出198
System.out.println("100"+98);//输出10098
System.out.println(100+3+"hello");//输出102hello
System.out.println("hello"+100+3);//输出hello1003
```



## 3、数据类型

### 3.1、数据类型分类

1、基本数据类型【类型[字节]】

byte[1],short[2],int[4],long[8];	float[4],double[8];	char[2];		boolean[1];

> null表示没有地址；null可以赋值给引用变量，不能将null赋给基本类型变量

2、引用类型

类（class）、接口（interface）、数组（[]）



一个字节为2的八次方；两个字节为2的十六次方

如：byte范围为-128~127

### 3.2、整型

※整数类型使用细节：

1）Java各整数类型有固定的范围和字段长度，不受具体OS[操作系统]的影响，以保证Java程序的可移植性。

2）1字节byte=8bit

3）Java整型常量默认为int型，声明long型常量后加'l'或'L‘

```java
//对的
public static void main(String args[]) {
byte a = 3;
byte b = 2;
a+=b;
System.out.println(b);
}

//错的
public static void main(String args[]) {
byte a = 3;
byte b = 2;
b = a + b;
System.out.println(b);
}
```

byte类型的变量在做运算时被会转换为int类型的值，故A、B左为byte，右为int，会报错；而C、D语句中用的是a+=b的语句，此语句会将被赋值的变量自动强制转化为相对应的类型。

### 3.3、浮点型

1）浮点数=符号位+指数位+尾数位

2）尾数部分可能丢失，造成精度损失->小数都是近似值

3）Java的浮点型常量默认为double型，声明float型常量，须后加'f'或'F'

```java
float num = 1.1;	//错的【double占8个字节，float占4个字节】
float num = 1.1f;	//对的

//十进制表示形式： 0.12   0.12f	  .12(必须带小数点)
//科学计数法：5.12e2[表示5.12*10的二次方=512.0]	5.12E-2[表示5.12/10的二次方=0.0512]
```

```java
//要小心对运算结果是小数的值进行相等判断
//应该是以两个数的插值的绝对值在某个精度范围内判断
double num11 = 2.7;
double num12 = 8.1 / 3; 	//这个数不等于2.7
//正确写法
if(Math.abs(num11 - num12) < 0.0000001) {
  System.out.println("差值非常小，到我的规定精度内，认为相等");
}
```



### 3.4、字符型

```java
char c1 = 'a';
char c2 = 97;
char c3 = '中';//一个char占两个字节，默认使用GBK编码存储
System.out.println(c1);//输出a
System.out.println(c2);//输出a
//当输出c2时，会输出97表示的字符（编码）
```

字符类型本质：

1）存储：字符->码值->二进制->存储		例：a->97->0110 0001->存储

2）读取：二进制->码值->字符->显示



### 3.5、布尔类型

1）boolean类型只允许取值true和false，无null

2）适用于逻辑运算，一般用于程序流程控制，if/while/do-while/for

**※不可以用0或非0的整数替代false和true，和C语言不同！！！**

## 4、编码

### 4.1、字符码表：

1）ASCII码表：一个字节表示，一共128个字符

2）Unicode编码表：两个字节表示，字母和汉字都占用两个字节

3）utf-8：字母占一个字节，汉字占3个字节【utf-8是一种变长的编码方式，它可以使用1-6个字节表示一个符号，根据不同的符号而变化字节长度。

4）gbk：字母占1个字节，汉字占2个字节

5）gb2312：表示的汉字少于gbk

6）big5码：繁体中文

## 5、数据类型转换

### 5.1、自动类型转换

当Java程序在进行赋值或者运算时，精度小的类型自动转换为精度大的数据类型。

由小到大：char->int->long->float->double

​		   byte->short->int->long->float->double

> 为什么long可以转化为float捏？
>
> 浮点数的32位并不是简单直接表示大小，而是按照一定标准分配的。 
>
> * 第1位，符号位，即S 
> * 接下来8位，指数域，即E。 
> * 剩下23位，小数域，即M，取值范围为[1 ,2 ) 或[0 , 1) 
> * 然后按照公式：**V=(-1)^s \* M * 2^E**
>
>
>  也就是说浮点数在内存中的32位不是简单地转换为十进制，而是通过公式来计算而来，通过这个公式虽然，只有4个字节，但**浮点数最大值要比长整型的范围要大**。

### 5.2、自动类型转换注意点

1）有多种类型的数据混合运算时，系统首先自动将所有数据转换成容量最大的那种数据类型，然后再进行计算

2）当把精度（容量）大的数据类型赋值给精度（容量）小的数据类型时会报错，反之将会进行自动转换类型

3）（byte，short）和char之间**不会**相互自动转换，当把具体数赋给byte时，会先判断该数是否在byte范围内，如果是就可以赋值；  如果是变量赋值，需要判断类型

4）byte，short，char他们三者可以计算，在计算时首先转换为int类型【byte+byte也为int】

5）boolean不参与转换

6）自动提升原则：表达式结果的类型自动提升为操作数中最大的类型。



### 5.3、强制类型转换

自动类型转换的逆过程，将容量大的数据类型转换成容量小的数据类型，使用时要加上强制转换符，但<u>可能造成精度降低或溢出</u>。

```java
//强制类型转换细节
//（1）强转符号只针对最近的操作数有效，往往会使用小括号提升优先级
int x = (int)10 * 3.5 + 6 * 1.5;//这里只对10做了强制转换，无法赋值
int x = (int)(10 * 3.5 + 6 * 1.5);//可以赋值

//（2）char类型可以保存int的常量值，但不能保存int的变量值，需要强转
char c1 = 100;//对
int m = 100;//对
char c2 = m;//错
char c3 = (char)m;//对
System.out.println(c3);//输出100对应的字符
```



> 注意：
>
> * 只能在继承层次内进行类型转换
> * 在将超类转换成子类之前，应该使用instanceof进行检查。
>
> ```java
> //例如：
> if（staff[1] instanceof Manager){
>   boss = (Manager)staff[1];
> }
> ```
>
> 

### 5.4、String类型的转换

1）基本类型转String类型：基本类型的值+""即可

```java
int n1 = 100;
float n2 = 1.1f;
String str1 = n1 + "";
String str2 = n2 + "";
```

2）String类型转积累数据类型：通过基本类型的包装类调用parseXX方法即可

```java
String n1 = "123";
int num1 = Integer.parseInt(n1);
double num2 = Double.parseDouble(n1);
float num3 = Float.parseFloat(n1);
short num4 = Short.parseShort(n1);
long num5 = Long.parseLong(n1);
boolean num6 = Boolean.parseBoolean("true");
byte num7 = Byte.parseByte(n1);

//String类型转char类型
//在string变量后加上【.charAt(0)】即可
//如：String a = "nice";
//则	a.charAt(0) == 'n';
```

3)注意事项：

在将String类型转成基本数据类型时，要确保String类型能够转成有效的数据。

如果格式不正确，就会抛出异常，程序就会终止。【编译时不报错，运行时报错。】

## 6、API的使用

API(Application Programming Interface):应用程序编程接口。

中文在线文档：https://www.matools.com

查找使用方法：

1）包->类->方法

2）直接索引



## 7、引用类型

四种引用类型      

 JDK1.2 之前，一个对象只有“已被引用”和"未被引用"两种状态，这将无法描述某些特殊情况下的对象，比如，当内存充足时需要保留，而内存紧张时才需要被抛弃的一类对象。

所以在 JDK.1.2 之后，Java 对引用的概念进行了扩充，将引用分为了：强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）、虚引用（Phantom Reference）4 种，这 4 种引用的强度依次减弱。       

一、**强引用**：

`Object obj = new Object(); //只要obj还指向Object对象，Object对象就不会被回收 obj = null; //手动置null`       

只要强引用存在，垃圾回收器将永远不会回收被引用的对象，哪怕内存不足时，JVM也会直接抛出OutOfMemoryError，不会去回收。如果想中断强引用与对象之间的联系，可以显示的将强引用赋值为null，这样一来，JVM就可以适时的回收对象了       

二、**软引用** ：软引用是用来描述一些非必需但仍有用的对象。在内存足够的时候，软引用对象不会被回收，只有在内存不足时，系统则会回收软引用对象，如果回收了软引用对象之后仍然没有足够的内存，才会抛出内存溢出异常。这种特性常常被用来实现缓存技术，比如网页缓存，图片缓存等。在 JDK1.2 之后，用<u>java.lang.ref.SoftReference类</u>来表示软引用。       

三、**弱引用**：弱引用的引用强度比软引用要更弱一些，无论内存是否足够，只要 JVM 开始进行垃圾回收，那些被弱引用关联的对象都会被回收。在 JDK1.2 之后，用 <u>java.lang.ref.WeakReference</u> 来表示弱引用。       

四、**虚引用**：虚引用是最弱的一种引用关系，如果一个对象仅持有虚引用，那么它就和没有任何引用一样，它随时可能会被回收，在 JDK1.2 之后，用 PhantomReference 类来表示，通过查看这个类的源码，发现它只有一个构造函数和一个 get() 方法，而且它的 get() 方法仅仅是返回一个null，也就是说将永远无法通过虚引用来获取对象，虚引用必须要和 ReferenceQueue 引用队列一起使用。   

































