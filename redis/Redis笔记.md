# Redis笔记

## 一、基本介绍

Redis（Remote Dictionary Server）是一种开源的内存数据存储系统，它可以用作数据库、缓存和消息中间件。Redis支持多种数据结构，包括字符串（Strings）、散列（Hashes）、列表（Lists）、集合（Sets）、有序集合（Sorted Sets）等。以下是关于Redis的一些重要特点和用途：

1. **内存存储：** Redis的主要特点是将数据存储在内存中，这使得它能够提供非常快速的读写操作。然而，为了持久性，它也可以将数据异步地保存到磁盘上。

2. **数据结构：** Redis不仅仅是一个键值存储系统，它支持多种复杂的数据结构，使得开发人员可以更灵活地处理数据。这些数据结构包括字符串、列表、集合、有序集合等。

3. **持久性：** 虽然Redis主要将数据存储在内存中，但可以通过持久性选项将数据保存到磁盘上，以便在重新启动时恢复数据。有两种持久性选项：RDB（快照）和AOF（追加文件）。

4. **高性能：** 由于数据存储在内存中，Redis提供了非常高的读写性能。此外，它还采用了单线程模型，使其在处理单个请求时非常迅速。

5. **分布式：** Redis支持主从复制，允许在多个节点之间复制数据。这有助于提高可用性和容错性。Redis Cluster是Redis的分布式解决方案，允许将数据划分到多个节点上，提供更高的水平扩展性。

6. **发布/订阅：** Redis支持发布和订阅模式，使得多个客户端可以通过订阅频道接收消息。这对于实现实时消息传递系统非常有用。

7. **事务：** Redis允许将一系列操作打包成一个事务，要么全部执行，要么全部不执行。这保证了在事务期间不会有其他客户端访问相同的数据。

8. **应用场景：** Redis在缓存、计数器、实时分析、排行榜、消息队列等方面有着广泛的应用。由于其快速、灵活、可扩展等特性，许多大型互联网公司都广泛使用Redis来支持其核心业务。

总体而言，Redis是一个功能丰富、高性能的键值存储系统，适用于多种用例，并成为许多应用架构中不可或缺的一部分。



##二、十大数据类型

###1）总览

Redis支持以下10种数据类型：

1. **String（字符串）**：这是Redis最基本的类型，你可以理解成与Memcached一模一样的类型，一个key对应一个value。string类型是二进制安全的，意思是Redis的string可以包含任何数据，比如jpg图片或者序列化的对象。
2. **Hash（哈希）**：Redis hash是一个键值对集合，是一个string类型的field和value的映射表，hash特别适合用于存储对象。
3. **List（列表）**：Redis列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。
4. **Set（集合）**：Redis的Set是string类型的无序集合。集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。
5. **Sorted Set（有序集合）**：Redis zset和set一样也是string类型元素的集合,且不允许重复的成员。不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。zset的成员是唯一的,但分数(score)却可以重复。
6. **Bitmap（位图）**：位图其实就是字符串，但是可以对字符串的位进行操作。
7. **HyperLogLog（基数统计）**：这是一种用来做基数统计的算法，Redis提供了相应的命令可以很方便的添加元素和计算基数。
8. **Geospatial（地理位置）**：这是一种特殊类型的ZSet，用来存储地理位置信息，并对这些信息进行范围查询。
9. **Stream（流）**：这是Redis 5.0版本新添加的数据类型，主要用于消息队列的应用场景。
10. **Pub/Sub（发布/订阅）**：这不是一种数据类型，但是它是Redis的重要特性之一，常用于制作消息队列。



### 2）命令

#### 1.key

Redis的key的常用命令包括：

1. **DEL key**：删除指定的key数据
2. **DUMP key**：序列化给定的key并返回序列化的值
3. **EXISTS key**：检查给定的key是否存在
4. **EXPIRE key seconds**：为key设置过期时间
5. **EXPIREAT key timestamp**：用时间戳的方式给key设置过期时间
6. **PEXPIRE key milliseconds**：设置key的过期时间以毫秒计
7. **KEYS pattern**：查找所有符合给定模式的key
8. **MOVE key db**：将当前数据库的key移动到数据库db当中
9. **PERSIST key**：移除key的过期时间，key将持久保存
10. **PTTL key**：以毫秒为单位返回key的剩余过期时间
11. **TTL key**：以秒为单位，返回给定key的剩余生存时间
12. **RANDOMKEY**：从当前数据库中随机返回一个key
13. **RENAME key newkey**：修改key的名称
14. **RENAMENX key newkey**：仅当newkey不存在时，将key改名为newkey
15. **TYPE key**：返回key所存储的值的类型

以上就是Redis key的常用命令，每个命令都有其特定的功能，可以根据实际需求选择使用。



※命令不区分大小写，而key是区分大小写的

※可以使用帮助命令，`help @类型`



> 分布式锁是一种在分布式系统中实现互斥访问共享资源的技术。在很多场景中，我们为了保证数据的最终一致性，需要很多的技术方案来支持，比如分布式事务、分布式锁等。
>
> 分布式锁的主要特点包括：
>
> 1. **互斥性**：任意时刻，只能有一个客户端获取锁，不能同时有两个客户端获取到锁。
> 2. **安全性**：锁只能被持有该锁的客户端删除，不能由其它客户端删除。
> 3. **死锁**：获取锁的客户端因为某些原因（如down机等）而未能释放锁，其它客户端再也无法获取到该锁。
> 4. **容错**：当部分节点（redis节点等）down机时，客户端仍然能够获取锁和释放锁。
>
> 分布式锁的具体实现方式有很多，常见的有以下几种：
>
> 1. 数据库乐观锁；
> 2. 基于ZooKeeper的分布式锁;
> 3. 基于Redis的分布式锁；
>
> 例如，基于Redis的分布式锁可以通过`SET key value NX EX max-lock-time`命令实现。这个命令只会导致两种结果：1. 当前没有锁（key不存在），那么就进行加锁操作，并对锁设置个有效期，同时value表示加锁的客户端。2. 已有锁存在，不做任何操作。
>
> 以上就是分布式锁的基本介绍，具体的实现和使用方式可能会根据实际的应用场景和需求有所不同。





####2.string

Redis中String类型的常见命令包括：

1. **SET key value**：设定key持有特定的字符串value，如果key存在则覆盖操作。
2. **GET key**：获得key的value。
3. **GETSET key value**：为键设置新值，并返回上一次的值，如果key不存在，则会创建一个新的key，返回nil。
4. **STRLEN key**：计算值的字符长度。
5. **APPEND key value**：将给定的value追加到原值的末尾。
6. **SETEX key seconds value**：设置键值的同时，设置过期时间，单位秒。
7. **PSETEX key milliseconds value**：设置键值的同时，设置过期时间，单位毫秒。
8. **MSET key1 value1 key2 value2…**：同时设置一个或多个key-value键值对。
9. **MGET key1 key2…**：同时获取一个或多个 value。
10. **INCR key**：将key中存储的数字值增1。只能对数字值操作，如果为空，新增值为1。
11. **DECR key**：将key中存储的数字值减1。只能对数字值操作，如果为空，新增值为-1。
12. **INCRBY key increment**：将key中存储的数字值增加，自定义步长。
13. **DECRBY key decrement**：将key中存储的数字值减去指定值。



set命令参数：

![](C:\Users\86180\Desktop\picPick\129.png)





#### 3.list

Redis中List类型的常用命令包括：

1. **LPUSH key value1 [value2 …]**：将一个或多个值插入到列表头部。如果key不存在，一个空列表会被创建并执行LPUSH操作。当key存在但不是列表类型时，返回一个错误。
2. **RPUSH key value1 [value2 …]**：在列表中添加一个或多个值到列表尾部。
3. **LPOP key**：移出并获取列表的第一个元素。
4. **RPOP key**：移除列表的最后一个元素，返回值为移除的元素。
5. **LINDEX key index**：通过索引获取列表中的元素。
6. **LLEN key**：获取列表长度。
7. **LREM key count value**：移除列表元素。
8. **LSET key index value**：通过索引设置列表元素的值。
9. **LTRIM key start stop**：对一个列表进行修剪 (trim)，就是说，让列表只保留指定区间内的元素，不在指定区间之内的元素都将被删除。
10. **RPOPLPUSH source destination**：移除列表的最后一个元素，并将该元素添加到另一个列表并返回。
11. **LRANGE key start stop**：获取列表指定范围内的元素。



#### 4.hash

Redis中Hash类型的常用命令包括：

1. **HSET key field value**：将哈希表键key中的字段field的值设为value。
2. **HGET key field**：获取存储在哈希表中指定字段的值。
3. **HMSET key field1 value1 [field2 value2 …]**：同时将多个field-value对设置到哈希表key中。
4. **HMGET key field1 [field2 …]**：获取所有给定字段的值。
5. **HGETALL key**：获取在哈希表中指定key的所有字段和值。
6. **HDEL key field1 [field2 …]**：删除一个或多个哈希表字段。
7. **HEXISTS key field**：查看哈希表key中，指定的字段是否存在。
8. **HLEN key**：获取哈希表中字段的数量。
9. **HKEYS key**：获取哈希表中的所有字段。
10. **HVALS key**：获取哈希表中所有值。



#### 5.set

Redis中Set类型的常用命令包括：

1. **SADD key member1 [member2 …]**：向集合添加一个或多个成员。
2. **SCARD key**：获取集合的成员数。
3. **SDIFF key1 [key2]**：返回第一个集合与其他集合之间的差异。
4. **SDIFFSTORE destination key1 [key2]**：返回给定所有集合的差集并存储在destination中。
5. **SINTER key1 [key2]**：返回给定所有集合的交集。
6. **SINTERSTORE destination key1 [key2]**：返回给定所有集合的交集并存储在destination中。
7. **SISMEMBER key member**：判断member元素是否是集合key的成员。
8. **SMEMBERS key**：返回集合中的所有成员。
9. **SMOVE source destination member**：将member元素从source集合移动到destination集合。
10. **SPOP key**：移除并返回集合中的一个随机元素。
11. **SRANDMEMBER key [count]**：返回集合中一个或多个随机数。
12. **SREM key member1 [member2 …]**：移除集合中一个或多个成员。
13. **SUNION key1 [key2]**：返回所有给定集合的并集。
14. **SUNIONSTORE destination key1 [key2]**：所有给定集合的并集存储在destination集合中。
15. **SSCAN key cursor \[MATCH pattern] [COUNT count]**：迭代集合中的元素。

以上就是Redis中Set类型的常用命令，每个命令都有其特定的功能，可以根据实际需求选择使用。



#### 6.zset

Redis中ZSet类型的常用命令包括：

1. **ZADD key score1 member1 [score2 member2 …]**：将一个或多个member元素及其score值加入到有序集key当中。
2. **ZRANGE key start stop [WITHSCORES]**：返回有序集key中，下标在start和stop之间的元素。
3. **ZREVRANGE key start stop [WITHSCORES]**：返回有序集key中，下标在start和stop之间的元素，但元素按score值递减（从大到小）的次序排列。
4. **ZRANGEBYSCORE key min max \[WITHSCORES] [LIMIT offset count]**：返回有序集key中，所有score值介于min和max之间（包括等于min或max）的成员。
5. **ZREVRANGEBYSCORE key max min \[WITHSCORES] [LIMIT offset count]**：返回有序集key中，所有score值介于max和min之间（包括等于max或min）的成员，但元素按score值递减（从大到小）的次序排列。
6. **ZINCRBY key increment member**：为元素的score加上增量。
7. **ZREM key member [member …]**：移除有序集合中的一个或多个成员。
8. **ZCARD key**：获取有序集key的成员数。
9. **ZCOUNT key min max**：返回有序集key中，score值在min和max之间（包括等于min或max）的成员的数量。
10. **ZRANK key member**：返回该值在集合中的排名，从0开始。

以上就是Redis中ZSet类型的常用命令，每个命令都有其特定的功能，可以根据实际需求选择使用。



#### 7.bitmap

Redis中Bitmap类型的常用命令包括：

1. **SETBIT key offset value**：设置比特位，其中value只能是 0 和 1。
2. **GETBIT key offset**：查询比特值。
3. **BITCOUNT key [start end]**：获取指定范围内值为 1 的个数，start 和 end 以字节为单位。
4. **BITOP operation destkey key1 [key2 …]**：对Bitmap做逻辑与、或、异或、非操作。operation 位移操作符，枚举值 AND 与运算 & OR 或运算 | XOR 异或 ^ NOT 取反 ~。destkey 计算的结果，会存储在该key中。key1 … keyn 参与运算的key，可以有多个，空格分割，not运算只能一个key。

以上就是Redis中Bitmap类型的常用命令，每个命令都有其特定的功能，可以根据实际需求选择使用。



Redis中的`BITOP`命令用于在一个或多个保存二进制位的字符串key之间进行位元操作，并将结果保存到`destkey`上。`BITOP`命令支持`AND`、`OR`、`NOT`、`XOR`这四种操作中的任意一种参数：

- `BITOP AND destkey srckey1 srckey2 srckey3... srckeyN`：对一个或多个key求逻辑并，并将结果保存到`destkey`。
- `BITOP OR destkey srckey1 srckey2 srckey3... srckeyN`：对一个或多个key求逻辑或，并将结果保存到`destkey`。
- `BITOP XOR destkey srckey1 srckey2 srckey3... srckeyN`：对一个或多个key求逻辑异或，并将结果保存到`destkey`。
- `BITOP NOT destkey key`：对给定key求逻辑非，并将结果保存到`destkey`。

当`BITOP`处理不同长度的字符串时，较短的那个字符串所缺少的部分会被看作是0。空的key也被看做是包含0的字符串序列。

以上就是Redis中`BITOP`命令的基本用法，每个命令都有其特定的功能，可以根据实际需求选择使用。



#### 8.hyperLogLog

Redis在2.8.9版本添加了HyperLogLog结构。HyperLogLog是一种用来做基数统计的算法，其优点是，在输入元素的数量或者体积非常大时，计算基数所需的空间总是固定的，并且是很小的。在Redis里面，每个HyperLogLog键只需要花费12KB内存，就可以计算接近2^64个不同元素的基数。

这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。但是，因为**HyperLogLog只会根据输入元素来计算基数**，而不会储存输入元素本身，所以HyperLogLog不能像集合那样，返回输入的各个元素。

Redis为HyperLogLog提供了三个命令：PFADD、PFCOUNT、PFMERGE：

- **PFADD**：将任意数量的元素添加到指定的HyperLogLog里面。
- **PFCOUNT**：当PFCOUNT key [key …]命令作用于单个键时，返回储存在给定键的HyperLogLog的近似基数，如果键不存在，那么返回0。当PFCOUNT key [key …]命令作用于多个键时，返回所有给定HyperLogLog的并集的近似基数。
- **PFMERGE**：将多个HyperLogLog合并（merge）为一个HyperLogLog，合并后的HyperLogLog的基数接近于所有输入HyperLogLog的可见集合（observed set）的并集。

以上就是Redis的HyperLogLog的基本介绍，每个命令都有其特定的功能，可以根据实际需求选择使用。



> Redis为HyperLogLog提供了三个命令：PFADD、PFCOUNT、PFMERGE：
>
> 1. **PFADD key element [element …\]**：将任意数量的元素添加到指定的HyperLogLog里面。如果HyperLogLog估计的近似基数（approximated cardinality）在命令执行之后出现了变化，那么命令返回1，否则返回0。如果命令执行时给定的键不存在，那么程序将先创建一个空的HyperLogLog结构，然后再执行命令。
> 2. **PFCOUNT key [key …\]**：当PFCOUNT命令作用于单个键时，返回储存在给定键的HyperLogLog的近似基数，如果键不存在，那么返回0。当PFCOUNT命令作用于多个键时，返回所有给定HyperLogLog的并集的近似基数，这个近似基数是通过将所有给定HyperLogLog合并至一个临时HyperLogLog来计算得出的。
> 3. **PFMERGE destkey sourcekey [sourcekey …\]**：将多个HyperLogLog合并（merge）为一个HyperLogLog，合并后的HyperLogLog的基数接近于所有输入HyperLogLog的可见集合（observed set）的并集。
>
> 以上就是Redis中HyperLogLog类型的常用命令，每个命令都有其特定的功能，可以根据实际需求选择使用。



#### 9.GEO

Redis的GEO类型是在Redis 3.2版本中新增的，主要用于存储地理位置信息，并对存储的信息进行操作。这种类型的元素是二维坐标，即地图上的经纬度。

Redis为GEO类型提供了以下几种操作命令：

1. **GEOADD**：添加地理位置的坐标。
2. **GEODIST**：计算两个位置之间的距离。
3. **GEORADIUS**：根据用户给定的经纬度坐标来获取指定范围内的地理位置集合。
4. **GEORADIUSBYMEMBER**：根据储存在位置集合里面的某个地点获取指定范围内的地理位置集合。
5. **GEOHASH**：返回一个或多个位置对象的geohash值。
6. **GEOPOS**：获取地理位置的坐标。

以上就是Redis中GEO类型的基本介绍，每个命令都有其特定的功能，可以根据实际需求选择使用。





Redis中Geo类型的常用命令包括：

1. **GEOADD key longitude latitude member [longitude latitude member …\]**：向Geo类型中添加一个或多个坐标元素，并返回新添加元素个数。若元素已存在（以 member 参数指定的元素名称作为唯一性判断），则返回值将不包括该元素，但会更新其值。
2. **GEODIST key member1 member2 [m|km|ft|mi\]**：获取两个由GEOADD添加的元素的距离，并表示为参数所指定的距离单位。当其中一个不存在或两个元素都不存在的情况下，将返回 nil。
3. **GEOHASH key member [member …\]**：获取一个或多个由GEOADD添加元素对应的GeoHash值，并以数组的形式返回。当其中某个元素不存在时，对应的位置将返回 nil。
4. **GEOPOS key member [member …\]**：获取一个或多个由GEOADD添加元素的坐标，并以 (经度,纬度) 形式的二维数组返回。当其中某个元素不存在时，对应的位置将返回 nil。
5. **GEORADIUS key longitude latitude radius m|km|ft|mi \[WITHCOORD] [WITHDIST] \[WITHHASH]  \[COUNT count] \[ASC|DESC] \[STORE key] [STOREDIST key]**
6. **GEORADIUSBYMEMBER key member radius m|km|ft|mi [WITHCOORD\] \[WITHDIST] \[WITHHASH] \[COUNT count] \[ASC|DESC] \[STORE key] \[STOREDIST key]**

以上就是Redis中Geo类型的常用命令，每个命令都有其特定的功能，可以根据实际需求选择使用。



#### 10.stream

Redis Stream是Redis 5.0版本引入的一种数据结构，用于高效地处理持续产生的事件流。它提供了一种可持久化的、有序的、可扩展的日志数据结构，适用于实时数据处理、消息队列和发布订阅等场景。

Redis Stream基于日志追加（append-only log）的数据结构。它以一个有序的、不断增长的日志序列来存储事件流数据。每个事件都是一个包含多个字段的消息，它们被追加到Stream的末尾。Stream使用了一种特殊的ID来标识每个消息，称为Entry ID。Entry ID是一个递增的唯一标识符，用于按照时间顺序对消息进行排序。每个消息都有一个唯一的Entry ID，并且新消息的Entry ID总是比旧消息的Entry ID大。Stream中的消息可以被消费者按照不同的消费者组进行消费。

Redis为Stream提供了以下几种操作命令：

- **XADD**：添加消息到末尾。
- **XTRIM**：对流进行修剪，限制长度。
- **XDEL**：删除消息。
- **XLEN**：获取流包含的元素数量，即消息长度。
- **XRANGE**：获取消息列表，会自动过滤已经删除的消息。
- **XREAD**： 以阻塞或非阻塞方式获取消息列表。

以上就是Redis Stream的基本介绍，每个命令都有其特定的功能，可以根据实际需求选择使用。



> **阻塞的方式读取消息队列**，是指在读取消息队列时，如果队列中没有新的消息，那么读取操作会被阻塞，也就是说，读取操作会一直等待，直到队列中有新的消息为止。这种方式的好处是可以实时获取到最新的消息，但是也可能会导致程序暂时停止执行其他任务。
>
> 例如，在Redis中，XREAD命令就提供了阻塞读取的功能。当你使用XREAD命令读取一个Stream时，如果Stream中没有新的消息，你可以指定一个超时时间，让XREAD命令在这段时间内阻塞等待，直到Stream中有新的消息为止。如果超过了指定的超时时间，XREAD命令就会返回一个空结果。
>
> 这种阻塞读取的方式在很多消息队列系统中都有应用，如RabbitMQ、Kafka等，它们都提供了类似的阻塞读取功能。这种方式非常适合于需要实时处理消息的场景。但是，阻塞读取也有可能导致一些问题，比如可能会阻塞过久，影响到程序的正常运行。因此，在使用阻塞读取时，需要根据实际的应用场景来合理设置超时时间。



> 在消息队列系统中，**消费者**是接收和处理消息的一方。消息生产者将消息发送到消息队列，然后消息消费者从队列中取出并处理这些消息。
>
> 消费者可以是一个函数、一个服务，或者是一个对消息进行处理的任何实体。消费者的主要任务是监听消息队列，一旦有新的消息进入队列，消费者就会取出消息并进行相应的处理。
>
> 例如，在一个电商系统中，当用户下单购买商品后，系统会将一个包含订单信息的消息发送到消息队列，然后负责处理订单的服务（作为消费者）就会从队列中取出这个消息，然后进行后续的订单处理工作，如扣库存、生成发货单等。
>
> 总的来说，消费者在消息队列系统中起到了承接和执行任务的作用。



在Redis的Stream数据结构中，消费者端常用的命令主要有以下几个：

- **XREADGROUP GROUP**：这是XREAD命令的特殊版本，支持消费者组。从语法的角度来看，这两个命令几乎是相同的，但是XREADGROUP需要一个特殊和强制的选项：GROUP \<group-name> \<consumer-name>。
- **XGROUP**：使用XGROUP可以创建与流关联的新消费者组，设置要传递的下一条消息，销毁一个消费者组，往消费者组中添加指定的消费者，以及从消费者组中移除指定的消费者。
- **XACK**：当消费者将消息正确处理后，需要调用确认命令来确认消费。只有当调用确认命令后，才会将该消息从待处理的返回中移除。

以上就是Redis Stream数据结构中，消费者端常用的一些命令。如果你需要更详细的信息，可以查阅Redis的官方文档或相关教程。



#### 11.bitfield

* **介绍**

  Redis中的`BITFIELD`数据类型可以将一个Redis字符串看作是一个由二进制位组成的数组，并对这个数组中储存的长度不同的整数进行访问。这意味着，通过这个命令，用户可以执行如“对偏移量1234上的5位长有符号整数进行设置”、“获取偏移量4567上的31位长无符号整数”等操作。

  `BITFIELD`命令还可以对指定的整数执行加法操作和减法操作，并且这些操作可以通过设置妥善地处理计算时出现的溢出情况。`BITFIELD`命令可以在一次调用中同时对多个位范围进行操作：它接受一系列待执行的操作作为参数，并返回一个数组作为回复，数组中的每个元素就是对应操作的执行结果。

  `BITFIELD`命令的基本语法如下：

  ```
  BITFIELD key [GET type offset] [SET type offset value] [INCRBY type offset increment] [OVERFLOW WRAP|SAT|FAIL] 
  ```

  其中，`GET`、`SET`、`INCRBY`和`OVERFLOW`是支持的子命令。`GET`用于返回指定的二进制位范围，`SET`用于对指定的二进制位范围进行设置，并返回它的旧值，`INCRBY`用于对指定的二进制位范围执行加法操作，并返回它的旧值。`OVERFLOW`子命令可以改变之后执行的`INCRBY`子命令在发生溢出情况时的行为。

  `BITFIELD`命令的作用在于它能够将很多小的整数储存到一个长度较大的位图中，又或者将一个非常庞大的键分割为多个较小的键来进行储存，从而非常高效地使用内存，使得Redis能够得到更多不同的应用。特别是在实时分析领域：`BITFIELD`能够以指定的方式对计算溢出进行控制的能力，使得它可以被应用于这一领域。

* **常用命令介绍**

  Redis中的`BITFIELD`命令支持以下子命令：

  1. `GET <type> <offset>`：返回指定的二进制位范围。
  2. `SET <type> <offset> <value>`：对指定的二进制位范围进行设置，并返回它的旧值。
  3. `INCRBY <type> <offset> <increment>`：对指定的二进制位范围执行加法操作，并返回它的旧值。用户可以通过向`increment`参数传入负值来实现相应的减法操作。
  4. `OVERFLOW [WRAP|SAT|FAIL]`：这个子命令可以改变之后执行的`INCRBY`子命令在发生溢出情况时的行为。

  其中，`type`参数表示整数类型，可以是有符号整数（前缀为`i`）或无符号整数（前缀为`u`）。例如，我们可以使用`u8`来表示8位长的无符号整数，也可以使用`i16`来表示16位长的有符号整数。`offset`参数表示偏移量，如果用户给定的是一个没有任何前缀的数字，那么这个数字指示的就是字符串以零为开始的偏移量。如果用户给定的是一个带有`#`前缀的偏移量，那么命令将使用这个偏移量与被设置的数字类型的位长度相乘，从而计算出真正的偏移量。

  `OVERFLOW`子命令的参数有三种：

  - `WRAP`：使用回绕（wrap around）方法处理有符号整数和无符号整数的溢出情况。
  - `SAT`：使用饱和计算（saturation arithmetic）方法处理溢出，也即是说，下溢计算的结果为最小的整数值，而上溢计算的结果为最大的整数值。
  - `FAIL`：在这一模式下，命令将拒绝执行那些会导致上溢或者下溢情况出现的计算，并向用户返回空值表示计算未被执行。

  `BITFIELD`命令的作用在于它能够将很多小的整数储存到一个长度较大的位图中，又或者将一个非常庞大的键分割为多个较小的键来进行储存，从而非常高效地使用内存，使得Redis能够得到更多不同的应用。特别是在实时分析领域：`BITFIELD`能够以指定的方式对计算溢出进行控制的能力，使得它可以被应用于这一领域。





## 三、redis持久化

### 1）介绍

Redis的数据默认是存储在内存中的，这使得数据的读写速度非常快。但是，如果Redis服务器重启或者发生故障，内存中的数据就会丢失。为了防止这种情况，Redis提供了两种持久化机制：RDB和AOF。

1. **RDB（Redis DataBase）**：RDB持久化是通过创建内存数据集的快照来实现的。具体来说，**Redis会在指定的时间间隔内生成一个包含当前所有数据的快照并将其保存到硬盘中。**这个快照文件可以用于数据恢复，例如在Redis重启后或者需要将数据迁移到另一个Redis服务器时。RDB持久化的优点是快照文件紧凑，适合备份和全量复制，且恢复速度快。但是，如果你需要更高的数据安全性，也就是减少可能的数据丢失窗口，那么RDB可能不适合你，因为最后一次快照之后的数据可能会在服务器故障时丢失。
2. **AOF（Append Only File）**：与RDB持久化不同，**AOF持久化记录了服务器接收到的所有写操作命令。**这些命令被追加到AOF文件的末尾，并在服务器启动时重新执行以重建数据集。此外，Redis还可以在AOF文件增长到一定长度时自动地在后台对其进行重写，使得AOF文件的大小始终保持在可接受的范围内。AOF持久化的优点是提供了更高的数据安全性：根据配置，你可以设置每秒同步一次，这样最多只会丢失一秒的数据。

两种持久化方式各有优缺点，可以根据你的业务需求选择使用。你甚至可以同时开启两种持久化方式，这样在Redis重启的时候，如果AOF文件存在，那么Redis会优先使用AOF文件来恢复数据，因为AOF文件保存的数据通常比RDB文件更完整。



### 2）RDB

![](C:\Users\86180\Desktop\picPick\130.png)

####1.介绍

Redis的RDB持久化机制是通过创建内存数据集的快照来实现的。具体来说，Redis会在指定的时间间隔内生成一个包含当前所有数据的快照并将其保存到硬盘中。这个快照文件可以用于数据恢复，例如在Redis重启后或者需要将数据迁移到另一个Redis服务器时。

RDB持久化的触发机制有三种：

1. `save`命令触发：该命令会阻塞当前Redis服务器，执行`save`命令期间，Redis不能处理其他命令，直到RDB完成为止，如果数据量大的话会造成长时间的阻塞，所以线上环境一般禁止使用。

2. `bgsave`命令触发：执行该命令时，Redis会在后台异步进行快照操作，快照同时还可以响应客户端请求。具体流程如下：执行`bgsave`命令时，Redis主进程会`fork`一个子进程来完成RDB的过程，会先将数据写入到一个临时二进制文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。Redis主进程阻塞时间只有`fork`阶段的那一下。相对于`save`，阻塞时间很短。

3. 自动触发：自动触发是可以在`redis.conf`配置文件中修改，默认达到以下三种条件，就会自动触发持久化，触发后，底层调用的其实还有`bgsave`命令：

   - 900秒（15分钟）之内至少一次写操作。

     **redis6.2以及7版本更改为1小时1次。**

   - 300秒（5分钟）之内至少发生10次写操作。

     **redis6.2以及7版本更改为5分钟100次**

   - 60秒（1分钟）之后，如果至少有10000个key发生变化。

RDB持久化的优点是快照文件紧凑，适合备份和全量复制，且恢复速度快。但是，如果你需要更高的数据安全性，也就是减少可能的数据丢失窗口，那么RDB可能不适合你，因为最后一次快照之后的数据可能会在服务器故障时丢失。此外，`fork`的时候，内存中的数据被克隆了一份，大致2倍的膨胀性需要考虑。当进行快照持久化时，会开启一个子进程专门负责快照持久化，子进程会拥有父进程的内存数据，父进程修改内存子进程不会反应出来，所以在快照持久化期间修改的数据不会被保存，可能丢失数据。在一定间隔时间做一次备份，所以如果Redis意外down掉的话，就会丢失最后一次快照后的所有修改。



####2.**redis的rdb持久化时如何将快照备份到另一台设备：**

> Redis的RDB持久化方式会将内存中的数据集生成一个快照并保存到硬盘中的一个文件，这个文件默认是名为`dump.rdb`的二进制文件。如果你想要将这个快照备份到另一台设备，你可以按照以下步骤操作：
>
> 1. **生成RDB文件**：你可以通过在Redis客户端执行`SAVE`或`BGSAVE`命令来手动触发RDB持久化，生成一个包含当前所有数据的快照。`SAVE`命令会阻塞Redis服务器直到持久化过程完成，而`BGSAVE`命令则会在后台异步进行持久化操作。
> 2. **传输RDB文件**：一旦RDB文件被生成，你就可以使用各种文件传输工具（如`scp`、`rsync`或FTP等）将RDB文件从当前设备复制到目标设备。
> 3. **在目标设备上恢复数据**：将RDB文件复制到目标设备后，你需要将Redis服务器配置为使用这个RDB文件。具体来说，你需要修改Redis的配置文件（通常是`redis.conf`），设置`dbfilename`参数为你的RDB文件的路径，然后重启Redis服务器。Redis服务器在启动时会自动从RDB文件中加载数据。
>
> 请注意，由于RDB文件是二进制格式的，所以它不能直接被阅读。此外，如果你的数据量非常大，生成和传输RDB文件可能需要一些时间。在进行这些操作时，你应该确保Redis服务器的运行不会被中断，以防止数据丢失。



####3.bgsave原理：

> Redis的`bgsave`命令是一种异步的RDB持久化方式，它的工作原理如下：
>
> 1. **创建子进程**：当执行`bgsave`命令时，Redis主进程会先判断当前是否已经有`fork()`出来的子进程，如果有则忽略这次`bgsave`请求，如果没有则会`fork()`出一个子进程来执行RDB文件持久化的工作。
> 2. **共享内存空间**：子进程与Redis主进程共享同一份内存空间，所以子进程可以进行RDB文件持久化工作，主进程又能继续对外提供服务，二者互不影响。
> 3. **Copy-On-Write技术**：在`bgsave`过程中，Redis主进程在执行`fork()`函数复制子进程的同时还会继续接收和处理客户端发送的命令请求，而这些写入操作可能会导致数据库状态发生变化。为了解决这个问题，Redis采用了Copy-On-Write（COW）技术。在COW技术中，当主进程需要修改数据时，会触发页异常中断（page-fault），在中断处理中，需要被写入的内存页面会复制一份，复制出来的旧数据交给子进程使用，然后主进程继续进行数据修改。这样，只有在出现了需要变更的数据时（写脏的数据），才进行copy操作。
> 4. **生成RDB文件**：子进程开始遍历全局数据库，将数据库的状态写入到内存缓冲区中，然后将内存缓冲区的内容写入到磁盘文件中，这个过程可能会非常耗时。
> 5. **通知主进程**：子进程完成RDB文件的写入操作之后，向Redis主进程发送一个信号，通知备份操作已经完成。Redis主进程在接收到子进程发送的信号后，持久化操作结束。
>
> 总的来说，`bgsave`命令通过创建子进程和使用Copy-On-Write技术，使得Redis可以在进行RDB持久化的同时，继续对外提供读写服务，从而提高了Redis的性能。



####4.fork函数：

> `fork()`是Linux系统中的一个函数，它通过系统调用创建一个与原来进程几乎完全相同的进程，也就是两个进程可以做完全相同的事，但如果初始参数或者传入的变量不同，两个进程也可以做不同的事。
>
> 一个进程调用`fork()`函数后，系统先给新的进程分配资源，例如存储数据和代码的空间。然后把原来的进程的所有值都复制到新的新进程中，只有少数值与原来的进程的值不同。
>
> `fork()`函数的返回值有三种可能：
>
> - 在父进程中，`fork()`返回新创建子进程的进程ID；
> - 在子进程中，`fork()`返回0；
> - 如果出现错误，`fork()`返回一个负值。
>
> 因此我们可以通过`fork()`返回的值来判断当前进程是子进程还是父进程。在`fork()`函数执行完毕后，如果创建新进程成功，则出现两个进程，一个是子进程，一个是父进程。在子进程中，`fork()`函数返回0，在父进程中，`fork()`返回新创建子进程的进程ID。我们称调用`fork()`的进程为父进程，新创建的进程为子进程。此时父子进程是共存的，他们一起向下执行代码。这就是`fork()`函数的基本原理。



#### 5.触发rdb快照的情况

* 配置文件中默认的快照设置（自动触发）
* 手动save/bgsave命令
* 执行flushall/flushdb命令也会产生dump.rdb文件，但里面是空的，无意义
* 执行shutdown且没有设置开启AOF持久化
* 主从复制时，主节点自动触发





### 3）AOF

#### 1.介绍

![](C:\Users\86180\Desktop\picPick\132.png)

Redis的AOF（Append Only File）持久化是一种日志形式的持久化方法，它会将每一个写入操作都记录到一个日志文件中。这些操作在服务器启动时可以被重新执行，从而重建原始的数据集。所有写入到AOF文件的命令都是以Redis协议本身的格式保存的。

使用AOF持久化，Redis可以提供更高的数据安全性：你可以有不同的fsync策略：完全不进行fsync，每秒fsync一次，或者每个查询fsync一次。这样，即使在Redis停止工作的情况下，也可以最大程度地减少数据丢失的可能性。

需要注意的是，AOF文件通常会比RDB文件大，且恢复速度可能会慢于RDB。但是，AOF文件提供了更好的耐久性和数据一致性，因此在需要这些特性的场景下，AOF是更好的选择。此外，Redis还提供了一个名为`bgrewriteaof`的命令，该命令可以用于在后台异步地重写当前的AOF文件，使其大小保持在可接受的范围内。



####2.写回策略

Redis的AOF（Append Only File）持久化提供了三种写回硬盘的策略：

1. **Always**：这个策略是每次写操作命令执行完后，同步将AOF日志数据写回硬盘。这种做法可以最大程度保证数据不丢失，但是由于它每执行一条写操作命令就同步将AOF内容写回硬盘，所以可能会影响主进程的性能。
2. **Everysec**：这个策略是每次写操作命令执行完后，先将命令写入到AOF文件的内核缓冲区，然后每隔一秒将缓冲区里的内容写回到硬盘。这种机制在性能和持久化方面做了很好的折中，虽然一秒钟的时间在我们看起来很短，但是对于Redis确是很长的一段时间。
3. **No**：这个策略意味着不由Redis控制写回硬盘的时机，转交给操作系统控制写回的时机。也就是每次写操作命令执行完后，先将命令写入到AOF文件的内核缓冲区，再由操作系统决定何时将缓冲区内容写回硬盘。这样的机制保证了性能，但是操作系统写回硬盘的时机是不可预知的，如果AOF日志内容没有写回硬盘，一旦服务器宕机，就会丢失不定数量的数据。

这三种策略只是在控制`fsync()`函数的调用时机。`fsync()`函数是一个系统调用，它会将内核缓冲区的数据直接写入到硬盘，等到硬盘写操作完成后，该函数才会返回。你可以根据你的业务需求选择合适的策略。



####3.redis6和redis7中AOF的区别

在Redis 6和Redis 7中，AOF（Append Only File）持久化的主要区别在于Redis 7引入了多部分AOF机制。在Redis 6及之前的版本中，所有的写操作命令都会被追加到一个单一的AOF文件中。然而，随着写操作命令的增多，AOF文件的大小会逐渐增大，这可能会导致一些问题，比如磁盘空间的消耗、数据恢复的速度变慢等。

为了解决这些问题，Redis 7引入了多部分AOF机制。在这个机制中，原来的单一AOF文件被分割成基础文件（最多一个）和增量文件（可能有多个）。基础文件代表了AOF重写时的初始数据快照（可以是RDB格式或者AOF格式），而增量文件则包含了基础文件生成后的所有写操作命令。这样，即使在大量写操作的情况下，基础文件的大小也会保持不变，只有增量文件的大小会增大。这种机制可以有效地控制AOF文件的大小，从而提高Redis的性能和可用性。



#### 4.AOF的异常恢复

如果Redis的AOF文件出现异常，你可以按照以下步骤进行恢复：

1. **备份AOF文件**：首先，你需要为现有的AOF文件创建一个备份。这是为了防止在修复过程中对原始AOF文件造成进一步的损坏。
2. **修复AOF文件**：然后，你可以使用Redis附带的`redis-check-aof`工具来修复原始的AOF文件。你可以通过执行`redis-check-aof --fix appendonly.aof`命令来进行修复。
3. **检查修复结果**：（可选）你可以使用`diff -u`命令来对比修复后的AOF文件和原始AOF文件的备份，查看两个文件之间的不同之处。
4. **重启Redis服务器**：最后，你需要重启Redis服务器，等待服务器载入修复后的AOF文件，并进行数据恢复。

以上就是Redis AOF文件异常恢复的基本步骤。在进行这些操作时，你应该确保你的操作不会对其他正在运行的服务造成影响。如果你在操作过程中遇到任何问题，你可以查阅相关的技术文档，或者在社区中寻求帮助。



#### 5.AOF的重写机制

AOF（Append Only File）重写是Redis为了解决AOF文件体积膨胀问题而引入的一种机制。随着Redis处理的写命令增多，AOF文件会变得越来越大，这可能会对Redis服务器，甚至对操作系统造成影响，而且AOF文件越大，数据恢复也越慢。

AOF重写的工作原理是，Redis通过创建一个新的AOF文件来替换现有的AOF。新旧两个AOF文件保存的数据相同，但新AOF文件没有了冗余命令。这样，新的AOF文件的大小就会比旧的AOF文件小，从而减少了AOF文件的体积。

具体来说，AOF重写的过程包括以下步骤：

1. Redis服务器创建一个子进程来执行AOF重写操作。
2. 子进程遍历Redis服务器的数据库，将数据库中的每个键值对转换为一个或多个写命令。
3. 子进程将这些写命令写入到新的AOF文件中。
4. 当子进程完成AOF文件的写入操作后，它会向Redis主进程发送一个信号，通知主进程AOF重写操作已经完成。
5. Redis主进程在接收到子进程发送的信号后，会用新的AOF文件替换旧的AOF文件。

需要注意的是，AOF重写操作是在后台异步执行的，所以它不会阻塞Redis服务器的主线程。此外，你可以通过配置文件来控制AOF重写的触发条件，例如，当AOF文件的大小超过一定的阈值时，或者当AOF文件的大小比上次重写后增大了一定的比例时，就会触发AOF重写。



#### 6.AOF优化配置项详解

![](C:\Users\86180\Desktop\picPick\131.png)



### 4）混合使用RDB和AOF

RDB+AOF的混合方式---------> 结论：RDB镜像做全量持久化，AOF做增量持久化：

先使用RDB进行快照存储，然后使用AOF持久化记录所有的写操作，当重写策略满足或手动触发重写的时候，将最新的数据存储为新的RDB记录。这样的话，重启服务的时候会从RDB和AOF两部分恢复数据，既保证了数据完整性，又提高了恢复数据的性能。简单来说：混合持久化方式产生的文件一部分是RDB格式，一部分是AOF格式。**----》AOF包括了RDB头部+AOF混写**

> Redis 4.0引入了一种新的混合持久化方式，这种方式结合了RDB和AOF两种持久化机制。在这种混合持久化方式中，RDB和AOF的持久化过程中的很多操作都是在时间事件`serverCron`中被触发的。
>
> 具体来说，这种混合持久化方式的工作原理如下：
>
> - 首先，Redis会在某个时间点创建一个RDB快照，这个快照保存了当前时刻Redis数据库的状态。
> - 然后，Redis会记录从创建RDB快照开始，对Redis数据库进行的所有写操作命令。
> - 最后，当Redis需要进行AOF重写时，它会先将RDB文件重写进AOF文件，然后再将剩下的AOF日志追加到重写的AOF文件后面。
>
> 这种混合持久化方式结合了RDB和AOF的优点：RDB可以提供一个全量的数据快照，而AOF可以提供从最后一次快照开始的所有写操作命令。这样，即使在大量写操作的情况下，也可以有效地控制AOF文件的大小，从而提高Redis的性能和可用性。



###5）纯缓存模式

Redis的纯缓存模式是指同时关闭RDB和AOF持久化，让Redis专心做缓存。在这种模式下，Redis不会将数据持久化到磁盘，而是只将数据保存在内存中。这样可以提高Redis的性能，但是一旦Redis服务器重启，所有的数据都会丢失。

在纯缓存模式下，你可以通过以下配置来禁用RDB和AOF：

- 禁用RDB：在Redis的配置文件中，设置`save ""`可以禁用RDB。尽管RDB被禁用，你仍然可以使用`save`或`bgsave`命令来手动生成RDB文件。
- 禁用AOF：在Redis的配置文件中，设置`appendonly no`可以禁用AOF。尽管AOF被禁用，你仍然可以使用`bgrewriteaof`命令来手动生成AOF文件。

需要注意的是，纯缓存模式适用于那些数据丢失不会造成严重问题的场景，例如页面缓存、Session共享等。如果你的应用对数据的持久性有较高的要求，那么你应该启用RDB或AOF来保证数据的持久性。



 

## 四、事务

### 1）介绍

Redis的事务是一组命令的集合，一个事务中的所有命令都会被序列化，按照顺序串行化执行队列中的命令，其他客户端提交的命令请求不会插入到事务执行命令序列中。也就是说，Redis事务就是一次性、顺序性、排他性的执行一个队列中的一系列命令。

Redis事务相关的命令包括：

- **MULTI**：开启事务，Redis会将后续的命令逐个放入队列中，然后使用EXEC命令来原子化执行这个命令系列。
- **EXEC**：执行事务中的所有操作命令。
- **DISCARD**：取消事务，放弃执行事务块中的所有命令。
- **WATCH**：监视一个或多个key，如果在事务执行前，这个key（或多个key）被其他命令修改，则事务被中断，不会执行事务中的任何命令。
- **UNWATCH**：取消WATCH对所有key的监视。

需要注意的是，Redis事务**并不是原子性的**。事务可以理解为一个打包的批量执行脚本，但批量指令并非原子化的操作，中间某条指令的失败不会导致前面已做指令的回滚，也不会造成后续的指令不做。这是Redis为了提升性能而采用的简单的事务，这是不同于关系型数据库的，特别要注意区分。

另外，Redis的事务还能保证一个事务内的命令依次执行而不被其他命令插入。也就是说，在事务执行期间，服务器不会中断事务而改去执行其他客户端的命令请求，即不会被其它命令插入，不许加塞，等事务中的所有命令都执行完毕才去处理其他客户端的命令请求。这就是Redis事务的主要意义，就是为了"打包"，避免其它客户端的命令，插队插到中间。



## 五、管道

### 1）介绍

Redis的管道技术是一种批处理技术，用于一次处理多个Redis命令，从而提高整个交互的性能。通常情况下，Redis是单行执行的，客户端先向服务器发送请求，服务端接收并处理请求后再把结果返回给客户端。这种处理模式在非频繁请求时不会有任何问题。但是，当需要处理大量请求时，这种一次发送一个请求，等待服务器响应，然后再发送下一个请求的模式就会变得效率低下。

为了解决这种问题，Redis引入了管道技术。也就是说，客户端可以一次发送多条命令，不用逐条等待命令的返回值，而是到最后一起读取返回结果，这样只需要一次网络开销，速度就会得到明显的提升。

在Redis中，如果客户端使用管道发送了多条命令，那么服务器就会将多条命令放入一个队列中，这一操作会消耗一定的内存，所以管道中命令的数量并不是越大越好（太大容易撑爆内存），而是应该有一个合理的值。

总的来说，Redis的管道技术可以在服务端未响应时，客户端可以继续向服务端发送请求，并最终一次性读取所有服务端的响应。这种模式大大减少了影响性能的关键因素-网络往返时间。但是，需要注意的是，管道技术并不能保证事务性，也就是说，如果管道中的某个命令执行失败，其他命令仍然会继续执行。



### 2）使用

#### 1.Linux

①将执行的命令写入一个txt文件中，例如

```txt
set k1 v1
hset k2 name vanky
hset k2 age 18
hset k2 gender man
```

②使用管道执行

```sh
cat cmd.txt | redis-cli -a redis密码 --pipe
```



#### 2.Java

Redis管道技术的使用主要涉及到以下几个步骤：

1. 创建一个Redis客户端实例：首先，你需要创建一个Redis客户端实例，这个实例将用于发送命令到Redis服务器。

```java
Jedis jedis = new Jedis("Redis服务器IP", 6379);
```

2. 创建一个管道实例：然后，你需要创建一个管道实例。管道实例是通过Redis客户端实例的`pipelined()`方法创建的。

```java
Pipeline pipe = jedis.pipelined();
```

3. 向管道中添加命令：接下来，你可以向管道中添加多个命令。这些命令会被一次性发送到Redis服务器。

```java
for (int i = 0; i < COMMAND_NUM; i++) {
    pipe.set("pipe_" + String.valueOf(i), String.valueOf(i), SetParams.setParams().ex(60));
}
```

4. 执行管道中的命令：最后，你需要调用`sync()`方法来执行管道中的所有命令。

```java
pipe.sync();
```

这就是使用Redis管道技术的基本步骤。需要注意的是，管道中的命令数量并不是越多越好，因为这可能会消耗大量的内存。因此，你应该根据实际情况来确定一个合理的命令数量。

以下是完整的示例代码：

```java
public class JedisDemo {
    private static int COMMAND_NUM = 1000;
    private static String REDIS_HOST = "Redis服务器IP";

    public static void main(String[] args) {
        Jedis jedis = new Jedis(REDIS_HOST, 6379);
        withoutPipeline(jedis);
        withPipeline(jedis);
    }

    private static void withoutPipeline(Jedis jedis) {
        Long start = System.currentTimeMillis();
        for (int i = 0; i < COMMAND_NUM; i++) {
            jedis.set("no_pipe_" + String.valueOf(i), String.valueOf(i), SetParams.setParams().ex(60));
        }
        long end = System.currentTimeMillis();
        long cost = end - start;
        System.out.println("withoutPipeline cost : " + cost + " ms");
    }

    private static void withPipeline(Jedis jedis) {
        Pipeline pipe = jedis.pipelined();
        long start_pipe = System.currentTimeMillis();
        for (int i = 0; i < COMMAND_NUM; i++) {
            pipe.set("pipe_" + String.valueOf(i), String.valueOf(i), SetParams.setParams().ex(60));
        }
        pipe.sync();
        long end_pipe = System.currentTimeMillis();
        long cost_pipe = end_pipe - start_pipe;
        System.out.println("withPipeline cost : " + cost_pipe + " ms");
    }
}
```

这段代码首先创建了一个Jedis实例，然后分别使用和不使用管道技术执行了一系列的set命令，并比较了两种方式的执行时间。结果显示，使用管道技术的执行时间明显少于不使用管道技术的执行时间，这充分证明了Redis管道技术的效率优势。



###3）管道和事务的区别

Redis事务和管道是两种不同的技术，它们各自有不同的用途和特性。

**Redis事务**：

- Redis事务提供了一种将多个命令作为一个整体来执行的机制。在事务开始之后，所有的命令都会被序列化并按照顺序执行。在事务执行期间，服务器不会中断事务而改去执行其他客户端的命令请求，即不会被其它命令插入，不许加塞，等事务中的所有命令都执行完毕才去处理其他客户端的命令请求。
- Redis事务并不是原子性的。事务可以理解为一个打包的批量执行脚本，但批量指令并非原子化的操作，中间某条指令的失败不会导致前面已做指令的回滚，也不会造成后续的指令不做。

**Redis管道**：

- Redis管道是一种批处理技术，用于一次处理多个Redis命令，从而提高整个交互的性能。客户端可以一次发送多条命令，不用逐条等待命令的返回值，而是到最后一起读取返回结果，这样只需要一次网络开销，速度就会得到明显的提升。
- 管道技术并不能保证事务性（原子性），也就是说，如果管道中的某个命令执行失败，其他命令仍然会继续执行。

总的来说，Redis事务主要用于保证一系列命令作为一个整体来执行，而Redis管道主要用于提高处理大量命令的效率。在实际使用中，你可以根据具体的需求来选择使用事务还是管道。

Redis管道技术的主要目标是提高网络效率，而不是保证原子性。因此，当你需要保证一系列命令的原子性执行时，你应该使用Redis的事务功能，而不是管道技术。



## 六、发布订阅

Redis的发布订阅（Pub/Sub）是一种消息通信模式：发送者（发布者）发送消息，订阅者（订阅者）接收消息。Redis客户端可以订阅任意数量的频道。

以下是发布订阅模式的工作方式：

- 发布者将消息发送到某个频道。
- 订阅了这个频道的订阅者就能接收到这条消息。

例如，假设我们有一个频道名为`channel1`，以及订阅这个频道的三个客户端——`client2`、`client5`和`client1`。当有新消息通过`PUBLISH`命令发送给频道`channel1`时，这个消息就会被发送给订阅它的三个客户端。

Redis发布订阅相关的命令包括：

- `PSUBSCRIBE pattern [pattern ...]`：订阅一个或多个符合给定模式的频道。
- `PUBSUB subcommand [argument [argument ...]]`：查看订阅与发布系统状态。
- `PUBLISH channel message`：将信息发送到指定的频道。
- `PUNSUBSCRIBE [pattern [pattern ...]]`：退订所有给定模式的频道。
- `SUBSCRIBE channel [channel ...]`：订阅给定的一个或多个频道的信息。
- `UNSUBSCRIBE [channel [channel ...]]`：退订给定的频道。

总的来说，Redis的发布订阅模式提供了一种有效的消息通信机制，可以用于实现各种复杂的消息传递和处理场景。





##七、主从复制

### 1）介绍

Redis的主从复制是一种数据冗余和备份机制，它允许一个Redis服务器（称为主节点）的数据被复制到一个或多个Redis服务器（称为从节点）。这种复制是单向的，只能由主节点到从节点。默认情况下，每台Redis服务器都是主节点，一个主节点可以有多个从节点，但一个从节点只能有一个主节点。

主从复制的**主要作用**包括：

- **数据冗余**：主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式。
- **故障恢复**：当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复。
- **负载均衡**：在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务，分担服务器负载。
- **高可用基石**：主从复制还是哨兵和集群能够实施的基础，因此说主从复制是Redis高可用的基础。



主从复制的**过程**大致可以分为三个阶段：

1. **建立连接阶段**：从节点向主节点发送连接请求，建立连接。
2. **数据同步阶段**：从节点向主节点发送同步命令，开始同步。根据主从节点当前状态的不同，可以分为全量复制和部分复制。
3. **命令传播阶段**：主节点将自己执行的写命令发送给从节点，从节点接收命令并执行，从而保证主从节点数据的一致性。

需要注意的是，Redis的主从数据是异步同步的，所以分布式的Redis系统并不满足「一致性」要求。当客户端在Redis的主节点修改了数据后，立即返回，即使在主从网络断开的情况下，主节点依旧可以正常对外提供修改服务，所以Redis满足「可用性」。Redis保证「最终一致性」，从节点会努力追赶主节点，最终从节点的状态会和主节点的状态将保持一致。



### 2）修改redis主从配置

![](C:\Users\86180\Desktop\picPick\133.png)



### 3）命令

在Redis中，主从复制的常用命令主要有以下几种：

1. 在`redis.conf`中配置 `slaveof <masterip> <masterport>`，例如 `slaveof 192.168.1.2 6379` 将建立与实例 `192.168.1.2:6379` 的主从关系。这种方式等同于在Redis启动命令中增加参数 `slaveof`。
2. 在`redis-server`启动参数中增加 `--slaveof` 参数。
3. 使用`redis-cli`客户端连接到redis服务，执行 `slaveof <masterip> <masterport>` 命令。

注意：如果Redis重启，主从关系将无法重新建立。

此外，主从复制机制包含三个部分：全量同步、部分同步、命令传播。

- 全量同步：master节点创建全量数据的RDB快照文件，通过网络连接发送给slave节点，slave节点加载快照文件恢复数据，然后再继续发送复制过程中复制积压缓冲区内新增的命令，使之达到数据一致状态。
- 命令传播：如果master-slave节点保持连接，master节点将持续向slave节点发送命令流，以保证master节点数据集发生的改变同样作用在slave节点数据集上，这些命令包含：客户端写请求、key过期、数据淘汰以及其他所有引起数据集变更的操作。



### 4）原理和工作流程

Redis主从复制的原理和工作流程主要包括以下几个部分：

1. **全量同步**：master节点创建全量数据的RDB快照文件，通过网络连接发送给slave节点，slave节点加载快照文件恢复数据，然后再继续发送复制过程中复制积压缓冲区内新增的命令，使之达到数据一致状态。
2. **部分同步**：在Redis 2.8版本之后进行了重新设计，引入了部分同步的概念。如果主从之间只有少量的数据不一致，采用代价较低的部分同步来完成主从复制。
3. **命令传播**：如果master-slave节点保持连接，master节点将持续向slave节点发送命令流，以保证master节点数据集发生的改变同样作用在slave节点数据集上，这些命令包含：客户端写请求、key过期、数据淘汰以及其他所有引起数据集变更的操作。





## 八、哨兵监控

### 1）介绍

Redis哨兵模式是Redis的高可用方式，哨兵节点是特殊的redis服务，不提供读写服务，主要用来监控redis实例节点。

哨兵模式的工作原理如下：

1. **心跳机制**：哨兵会定时向主节点和从节点发送info命令获取其拓扑结构和状态信息。同时，哨兵节点之间也互相通信，交换对主从节点的监控状况。
2. **主观下线和客观下线**：如果master节点回复PING命令的时间超过down-after-milliseconds设定的阈值（默认30s），则这个master会被哨兵标记为主观下线。当多个哨兵实例都认为master处于主观下线状态时，master将处于客观下线状态。
3. **故障转移**：如果一个master离线，哨兵会开始进行故障转移，master下的一个slave会被选为新的master，其他的slave会开始复制新的master。

哨兵模式的主要工作任务包括：

- **监控**：哨兵会不断地检查你的Master和Slave是否运作正常。
- **提醒**：当被监控的某个Redis节点出现问题时，哨兵可以通过API向管理员或者其他应用程序发送通知。
- **自动故障迁移**：当一个Master不能正常工作时，哨兵会进行自动故障迁移操作，将失效Master的其中一个Slave升级为新的Master，并让失效Master的其他Slave改为复制新的Master；当客户端试图连接失效的Master时，集群也会向客户端返回新Master的地址，使得集群可以使用新Master代替失效Master。



### 2）常用命令

Redis哨兵模式的常用命令主要有以下几种：

1. **启动哨兵**：可以通过以下两种方式启动哨兵：
   - `redis-sentinel sentinel.conf`
   - `redis-server sentinel.conf --sentinel`
2. **查看日志**：可以通过以下命令查看哨兵的日志：
   - `tail -f /var/local/redis/logs/sentinel.log`
3. **查看哨兵是否启动**：可以通过以下两种方式查看哨兵是否已经启动：
   - 通过`ps`指令查询：`ps -ef | grep sentinel`
   - 通过`redis-cli`连接哨兵节点，如果连接成功则说明哨兵已经启动
4. **关闭主节点**：可以通过以下命令关闭主节点：
   - 查询进程：`ps -ef | grep redis`
   - 终止master的redis服务：`sudo /etc/init.d/redis-server stop`



### 3）运行流程

Redis哨兵模式的运行流程主要包括以下几个步骤：

1. **启动**：首先，你需要在每个Redis节点上启动哨兵进程。哨兵是一个独立的进程，可以通过`redis-sentinel`命令或者`redis-server --sentinel`命令启动。
2. **监控**：哨兵会定期发送PING命令来监控Redis主节点和从节点的运行状态。
3. **主观下线判断**：如果一个Redis节点在指定的时间内没有回应PING命令，哨兵会将这个节点标记为主观下线。
4. **客观下线判断**：如果多个哨兵都将同一个节点标记为主观下线，那么这个节点就会被标记为客观下线。
5. **故障转移**：当一个主节点被标记为客观下线后，哨兵会开始故障转移过程。哨兵会从所有的从节点中选举出一个新的主节点，并向所有的从节点发送命令，让它们成为新主节点的从节点。
6. **通知**：哨兵会向所有的客户端发送消息，通知它们主节点已经更换。

![](C:\Users\86180\Desktop\picPick\134.png)



> 在Redis的哨兵模式中，**建议使用奇数台哨兵**主要是为了避免"脑裂"现象。
>
> "脑裂"是指在一个分布式系统中，由于网络问题导致系统被划分为两个或更多的部分，每个部分都认为自己是整个系统的主节点。这种情况下，如果有偶数台哨兵，可能会出现两个哨兵群体各自选出一个主节点，导致数据不一致。
>
> 使用奇数台哨兵可以避免这种情况。当网络出现问题，哨兵群体被划分为两部分时，只有节点数更多的那一部分能够选出新的主节点，因为只有它们的节点数能够满足大多数（quorum）的要求。这样就可以确保系统的一致性。



###4）选举策略

Redis哨兵模式的选举策略主要包括以下步骤：

1. **选举开始**：当主服务器宕机，哨兵节点会开始选举过程。每个哨兵节点都会尝试成为领导者。
2. **投票**：每个哨兵节点都会向其他哨兵节点发送命令，请求它们的投票。如果接收到的哨兵节点在指定的时间内没有投票给其他哨兵节点，那么它就会投票给请求投票的哨兵节点，并承诺在指定的时间内不投票给其他哨兵节点。
3. **赢得选举**：一个哨兵节点需要获得大多数哨兵节点的投票才能赢得选举。例如，如果你有3个哨兵节点，那么一个哨兵节点需要获得2个投票才能赢得选举。
4. **领导者角色**：一旦一个哨兵节点赢得了选举，它就会成为领导者。然后，领导者会负责协调主服务器的故障转移操作。
5. **故障转移**：领导者会选择一个从服务器进行提升，将其变为新的主服务器。然后，它会向所有其他的从服务器和哨兵节点发送命令，通知它们新的主服务器是谁。

以上就是Redis哨兵模式的选举策略。这种策略确保了在主服务器出现故障时，可以快速而有效地进行故障转移。



### 5）raft算法

Raft算法是一种易于理解的分布式一致性算法，它的目标是使分布式系统的状态保持一致。Raft算法主要包括以下几个部分：

1. **角色定义**：Raft算法将系统中的角色分为领导者（Leader）、跟随者（Follower）和候选人（Candidate）。在任何时刻，一个节点可以是这三种角色中的任何一种。
2. **Leader选举**：当一个节点在一段时间内没有收到来自Leader的心跳消息时，它会变成候选人并开始一次Leader选举。每个候选人都会向其他节点发送请求投票的消息。收到大多数投票的候选人会成为新的Leader。
3. **日志复制**：Leader负责接收客户端的请求，并将这些请求作为日志条目添加到它自己的日志中。然后，Leader会将这些日志条目复制到其他Follower节点。当一个日志条目被复制到大多数节点上时，该日志条目就可以被提交。
4. **安全性**：Raft算法通过一些机制来保证系统的安全性。例如，只有拥有最新已提交日志条目的Follower才有资格成为Leader。此外，Leader只能通过推进commit index来提交当前term的已经复制到大多数服务器上的日志。
5. **故障恢复**：如果Leader发生故障，Follower节点会重新进行Leader选举，以确保系统能够正常运行。

以上就是Raft算法的基本概念和工作流程。这种算法通过将复杂问题分解为几个子问题，并使用强假设来减少需要考虑的状态，从而实现了易于理解和实现的目标。





## 九、集群

### 1）介绍

Redis集群是Redis的一种分布式解决方案，它具有高可用性、可扩展性、分布式和容错等特性。以下是关于Redis集群的一些详细介绍：

1. **水平扩容和垂直扩容**：Redis集群可以实现水平扩容和垂直扩容。水平扩容是指增加一套主从集群，让部分数据可以被新加入的主从集群存储。垂直扩容是指增加某个集群的内存，提升单机/单集群的处理能力。
2. **高可用性和易用性**：一套哨兵集群可以监控多套Redis主从集群，高可用的实现依赖于哨兵。易用性指的是客户端的易用性。
3. **Hash槽**：Redis使用hash槽算法，默认分配16384个hash槽位，然后将槽位均匀分配到不同的Redis实例中去。找数据的时候通过crc16 (key) % 16384找到对应的槽位，再看槽位在哪台实例上，最后去实例上取数据。
4. **Gossip协议**：Redis使用流行病协议，即Gossip Protocol ，每台redis主机即使客户端也是服务端，随时都在向整个集群扩散自己的可用性状态，实际上就是基于P2P的去中心化网络拓扑架构。
5. **主观下线和客观下线**：如果一个实例距离最后一次有效回复PING命令的时间超过配置文件own-after-milliseconds选项所指定的值，则这个实例会被Sentinel标记为主观下线。只有在足够数量的Sentinel都将一个服务器标记为主观下线之后，服务器才会被标记为客观下线。



### 2）槽位

Redis集群使用了一种称为哈希槽（Hash Slot）的技术来实现数据的分片。在Redis集群中，所有的键根据哈希函数映射到0~16383整数槽内，每个key通过CRC16校验后对16384取模来决定放置哪个槽。每一个Redis实例负责维护一部分哈希槽以及槽所映射的键值数据。

这种结构很容易添加或者删除节点。当需要增加节点时，只需要把其他节点的某些哈希槽挪到新节点就可以了；当需要移除节点时，只需要把移除节点上的哈希槽挪到其他节点就行了。

这种分片机制增加或移除实例是非常麻烦的一件事，所以我们可以考虑一开始就开启32个节点实例，当我们可以新增Redis服务器时，我们可以将一半的节点移动到新的Redis服务器。这样我们只需要在新服务器启动一个空节点，然后移动数据，配置新节点为源节点的从节点，然后更新被移动节点的ip信息，然后向新服务器发送slaveof命令关闭主从配置，最后关闭旧服务器不需要使用的实例并且重新启动客户端。这样我们就可以在几乎不需要停机时间时完成数据的移动。

总的来说，Redis集群通过哈希槽和分片技术实现了高效、灵活的数据管理和扩展性。



> 一致性哈希算法是一种特殊的哈希算法，于1997年由麻省理工学院提出，主要用于解决分布式系统的数据分区问题。当增加或者减少一台服务器时，能够尽可能小地改变已存在的服务请求与处理请求服务器之间的映射关系。一致性哈希解决了简单哈希算法在分布式哈希表中存在的动态伸缩等问题。
>
> 一致性哈希算法将整个哈希值空间映射成一个虚拟的圆环，整个哈希空间的取值范围为0~2^32-1。然后，计算各服务器节点的哈希值，并映射到哈希环上。当服务器接收到数据请求时，首先需要计算请求Key的哈希值；然后将计算的哈希值映射到哈希环上的具体位置；接下来，从这个位置沿着哈希环顺时针查找，遇到的第一个节点就是key对应的节点。
>
> 当增加或者删除一台服务器时，受影响的数据仅仅是新添加或删除的服务器到其环空间中前一台的服务器（也就是顺着逆时针方向遇到的第一台服务器）之间的数据，其他都不会受到影响。这样就确保节点发生故障时，集群能保持正常稳定。
>
> 总结来说，一致性哈希算法对于节点的增减都只需重定位环空间中的一小部分数据，具有较好的容错性和可扩展性。





### 3）哈希槽

哈希槽是Redis集群中的一个重要概念，用于实现数据的分片和负载均衡。在Redis集群中，所有的键根据哈希函数映射到0~16383整数槽内，每个key通过CRC16校验后对16384取模来决定放置哪个槽。每一个Redis实例负责维护一部分哈希槽以及槽所映射的键值数据。

这种结构很容易添加或者删除节点。当需要增加节点时，只需要把其他节点的某些哈希槽挪到新节点就可以了；当需要移除节点时，只需要把移除节点上的哈希槽挪到其他节点就行了。

这种分片机制增加或移除实例是非常麻烦的一件事，所以我们可以考虑一开始就开启32个节点实例，当我们可以新增Redis服务器时，我们可以将一半的节点移动到新的Redis服务器。这样我们只需要在新服务器启动一个空节点，然后移动数据，配置新节点为源节点的从节点，然后更新被移动节点的ip信息，然后向新服务器发送slaveof命令关闭主从配置，最后关闭旧服务器不需要使用的实例并且重新启动客户端。这样我们就可以在几乎不需要停机时间时完成数据的移动。

总结来说，Redis集群通过哈希槽和分片技术实现了高效、灵活的数据管理和扩展性。



**为什么redis集群的最大槽数是16384个？**

Redis集群选择16384个槽位的原因主要有两个：

1. **网络带宽考虑**：Redis实例之间会定期交换「槽信息」，如果槽位过多，意味着网络包会变大，从而可能过度占用网络带宽。
2. **实例数量考虑**：Redis作者认为集群在一般情况下是不会超过1000个实例。因此，选择16384个槽位既可以将数据合理地分布到Redis集群中的不同实例，又不会在交换数据时导致带宽占用过多。

总的来说，16384个槽位是一个折中的选择，既满足了网络带宽的需求，又考虑到了实例数量的限制。这样可以确保在大多数情况下，Redis集群的性能和效率都能得到保证。



**为什么redis集群一般不建议超过1000个实例？**

Redis集群一般不建议超过1000个实例的原因主要有以下几点：

1. **性能考虑**：Redis的性能受到存储的键（key）的数量的影响。当Redis中的键的数量增加时，Redis的性能可能会受到影响。例如，在哈希表中查找一个键，它需要遍历所有哈希表中的键来查找目标键。当键的数量增加时，遍历时间也会相应增加，这可能会导致Redis的性能下降。
2. **内存使用**：Redis内存使用率也会受到存储的键数量的影响。因此，在Redis中存储大量的键可能会导致Redis内存使用率升高，从而需要更多的内存和更好的硬件配置。
3. **网络带宽**：每个Redis实例都需要定期与其他实例交换信息，包括哈希槽信息等。如果实例数量过多，那么这些信息交换所需的网络带宽就会增加，可能会对网络性能产生影响。
4. **管理复杂性**：随着实例数量的增加，集群的管理复杂性也会增加。例如，需要处理更多的故障转移、数据迁移等问题。

因此，为了保持良好的性能和易管理性，一般建议Redis集群的实例数量不要超过1000个。



#### BUG：Could not connect to Redis : No route to host（redis集群报错）

出现此BUG的情况是因为系统的iptables的设置问题，因为redis没有对外开启6379的端口.

解决： `sudo iptables -F` ，那台主机连不到就在那台主机设置。



### 4）redis集群扩容和缩容

![](C:\Users\86180\Desktop\picPick\135.png)



### 5）常用命令

Redis集群常用的一些命令如下：

1. **查看Redis集群信息**：可以使用`redis-cli -c -p 6379 cluster nodes`或者`redis-trib.rb check 10.26.25.115:6379 redis-trib.rb info 10.26.25.115:6379`来查看Redis集群的信息。
2. **节点命令**：
   - **加入节点**：可以使用`CLUSTER MEET <ip> <port>`或者`redis-trib.rb add-node <ip> <port> 10.25.157.78:7022`来将指定的节点添加到集群中。
   - **移除节点**：可以使用`CLUSTER FORGET <node_id>`或者`redis-trib.rb del-node <ip> <port> <node_id>`来从集群中移除指定的节点。
   - **设置主从节点**：可以使用`CLUSTER REPLICATE <node_id>`来将当前节点设置为指定节点的从节点。
   - **节点数据备份到硬盘**：可以使用`CLUSTER SAVECONFIG`来将节点的配置文件保存到硬盘里面。
3. **槽命令**：
   - **添加槽**：可以使用`CLUSTER ADDSLOTS <slot> [slot ...]`来将一个或多个槽指派给当前节点。
   - **删除槽**：可以使用`CLUSTER DELSLOTS <slot> [slot ...]`来移除一个或多个槽对当前节点的指派。
   - **移除所有槽**：可以使用`CLUSTER FLUSHSLOTS`来移除指派给当前节点的所有槽，让当前节点变成一个没有指派任何槽的节点。
4. **键命令**：
   - **计算键应该被放置在哪个槽上**：可以使用`CLUSTER KEYSLOT <key>`命令。
   - **返回槽目前包含的键值对数量**：可以使用`CLUSTER COUNTKEYSINSLOT <slot>`命令。
   - **返回count个slot槽中的键**：可以使用`CLUSTER GETKEYSINSLOT <slot> <count>`命令。

以上只是一部分常用命令，具体情况可能需要根据你的实际环境和需求来选择合适的命令。





## 十、springboot集成redis

### 1）Jedis

Jedis是Redis官方推荐的Java连接开发工具。它是一款基于Java语言的Redis客户端，集成了Redis的命令操作，提供了连接池管理。在Java中，Redis对应于Jedis就相当于关系数据库对应于JDBC。

Jedis的基本使用包括创建Jedis对象，使用jedis存储数据，以及jedis读取数据的操作命令和redis读取数据的操作命令基本相同。例如，你可以使用`jedis.set(String key,String value)`来存储数据，使用`String value = jedis.get(String key)`来读取数据。

此外，Jedis还提供了一些高级功能，如事务、管道、脚本、连接池等。这使得Jedis成为目前使用最广泛的Redis Java客户端。



### 2）lettuce

Lettuce是Redis的一款高级Java客户端，与Jedis并列成为最热门的客户端之一，目前已成为SpringBoot 2.0版本默认的redis客户端。相比老牌Jedis，Lettuce属于后起之秀，不仅功能丰富，而且提供了很多新的功能特性，比如异步操作、响应式编程等等，同时还解决了Jedis中线程不安全的问题。

Lettuce是一个高性能基于Java编写的Redis驱动框架，底层集成了Project Reactor提供天然的反应式编程，通信框架集成了Netty使用了非阻塞IO，5.x版本之后融合了JDK1.8的异步编程特性，在保证高性能的同时提供了十分丰富易用的API。

Lettuce使用的时候依赖于四个主要组件：RedisURI（连接信息）、RedisClient（Redis客户端）、Connection（Redis连接）、RedisCommands（Redis命令API接口）。基本上覆盖了Redis发行版本的所有命令。



### 3）RedisTemplate

#### 1.介绍

Spring Boot 的 `spring-boot-starter-data-redis` 为 Redis 的相关操作提供了一个高度封装的 `RedisTemplate` 类，而且对每种类型的数据结构都进行了归类，将同一类型操作封装为 operation 接口。`RedisTemplate` 对五种数据结构分别定义了操作。

RedisTemplate 的泛型是 `<Object,Object>`，写代码不方便，需要写好多类型转换的代码；我们需要一个泛型为 `<String,Object>` 形式的 RedisTemplate。 并且，这个 RedisTemplate 没有设置数据存在 Redis 时，key 及 value 的序列化方式。

看到这个 `@ConditionalOnMissingBean` 注解后，就知道 如果 Spring 容器中有了 RedisTemplate 对象了，这个自动配置的 RedisTemplate 不会实例化。 因此我们可以直接自己写个配置类，配置 RedisTemplate。

既然自动配置不好用，就重新配置一个 RedisTemplate。在代码中注入 RedisTemplate 后即可使用。

同时，使用 `@EnableCaching` 开启声明式缓存支持，这样就可以使用基于注解的缓存技术。 注解缓存是一个对缓存使用的抽象，通过在代码中添加下面的一些注解，达到缓存的效果。

- `@Cacheable`：在方法执行前 Spring 先查看缓存中是否有数据，如果有数据，则直接返回缓存数据；没有则调用方法并将方法返回值放进缓存。
- `@CachePut`：将方法的返回值放到缓存中。
- `@CacheEvict`：删除缓存中的数据。



#### 2.使用

在Spring Boot项目中使用Redis，你可以选择使用`RedisTemplate`或者`StringRedisTemplate`。以下是一些基本步骤：

1. **添加Redis依赖**：在你的`pom.xml`文件中添加如下依赖：

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-redis</artifactId>
</dependency>
```

2. **配置Redis连接信息**：在你的`application.properties`或者`application.yml`配置文件中添加Redis连接信息，例如：

```properties
spring.redis.host=localhost
spring.redis.port=6379
```

3. **使用RedisTemplate进行操作**：你可以创建一个配置类，在其中创建一个`RedisTemplate` Bean，然后在你的服务类或控制器中注入这个Bean。例如：

```java
@Configuration
public class RedisConfig {
    @Bean
    public RedisTemplate<String, Object> redisTemplate(RedisConnectionFactory connectionFactory) {
        RedisTemplate<String, Object> template = new RedisTemplate<>();
        template.setConnectionFactory(connectionFactory);
        template.setKeySerializer(new StringRedisSerializer());
        template.setValueSerializer(new GenericJackson2JsonRedisSerializer());
        return template;
    }
}
```

4. 然后在你的服务类或控制器中**注入这个Bean**：

```java
@Autowired
private RedisTemplate<String, Object> redisTemplate;
```

然后你就可以使用这个Bean来进行Redis操作了，例如设置键值对、获取值等。

如果你想要使用Spring Cache来简化缓存操作，你需要在你的启动类上添加`@EnableCaching`注解来启用缓存支持，然后在你的服务类或方法上使用Spring Cache提供的缓存注解，如 `@Cacheable`、`@CachePut`、`@CacheEvict`等。



## 十一、应用问题及解决

### 1）缓存穿透

Redis缓存穿透是指用户查询的数据既不在缓存中，也不在数据库中，但用户仍然源源不断地发起请求，导致每次请求都会到数据库，从而压垮数据库。例如，客户查询一个根本不存在的东西，首先从Redis中查不到，然后会去数据库中查询，数据库中也查询不到，那么就不会将数据放入到缓存中，后面如果还有类似源源不断的请求，最后都会压到数据库来处理，从而给数据库造成巨大的压力。

解决缓存穿透问题的方法有以下几种：

1. **业务层校验**：用户发过来的请求，根据请求参数进行校验，对于明显错误的参数，直接拦截返回。比如，请求参数为主键自增id，那么对于请求小于0的id参数，明显不符合，可以直接返回错误请求。
2. **不存在数据设置短过期时间**：对于某个查询为空的数据，可以将这个空结果进行Redis缓存，但是设置很短的过期时间，比如30s。
3. **布隆过滤器**：布隆过滤器是一种数据结构，利用极小的内存，可以判断大量的数据“一定不存在或者可能存在”。对于缓存穿透，我们可以将查询的数据条件都哈希到一个足够大的布隆过滤器中，用户发送的请求会先被布隆过滤器拦截，一定不存在的数据就直接拦截返回了。
4. **实时监控** ：当发现Redis的命中率开始急速降低，需要排查访问对象和访问的数据，和运维人员配合，可以设置黑名单限制服务



### 2）缓存击穿

Redis缓存击穿是指一个并发访问量比较大的key在某个时间过期，导致所有的请求直接打在数据库上。这种情况下，如果有大量的并发请求来查询这个key，那么这些请求都会因为在Redis中查不到而去查询数据库，可能会给数据库带来很大压力。

解决缓存击穿问题的常见方法有以下几种：

1. **设置热点数据永远不过期**：对于一些访问非常频繁的热点数据，可以设置其在Redis中永不过期。
2. **实时调整**：现场监控哪些数据热门，实时调整key的过期时长
3. **使用互斥锁（Mutex key）**：当缓存失效时，可以先使用Redis的SETNX命令或其他方法尝试获取一个互斥锁。如果获取锁成功，那么就去加载数据库数据并刷新缓存；如果获取锁失败（说明有其他线程已经在加载数据了），那么就让当前线程稍微等待一下，然后重试整个获取缓存的流程。

![](C:\Users\86180\Desktop\picPick\136.png)

> **互斥锁（Mutex）**是一种用于多线程编程中，防止两条线程同时对同一公共资源（比如全局变量）进行读写的机制。每个线程在对资源操作前都尝试先加锁，成功加锁才能操作，操作结束解锁。但应注意：同一时刻，只能有一个线程持有该锁。
>
> 在Linux内核中，互斥锁指的是一个特殊的加锁原语，它在共享内存系统上强制保证序列化。互斥锁是一种睡眠锁，它的行为类似于二进制信号量（semaphores），在2006年被引入时，作为后者的替代品。
>
> 互斥锁的实现有硬件实现和软件实现，软件实现是通过一些特别的算法譬如 en.wikipedia.org/wiki/P ，这类软件实现通常比硬件实现需要更多的内存。CPU如果提供一些用来构建锁的atomic指令，一般会更高效一些。



### 3）缓存雪崩

**Redis缓存雪崩**是指缓存中有大量的数据，在同一个时间点，或者较短的时间段内，全部过期了，这个时候请求过来，缓存没有数据，都会请求数据库，则数据库的压力就会突增，扛不住就会宕机。

针对这种情况，一般我们都是使用以下方案：

1. 如果是热点数据，那么**可以考虑设置永远不过期。**
2. 缓存的过期时间除非比较严格，要不考虑**设置一个波动随机值**，比如理论十分钟，那这类key的缓存时间都加上一个1~3分钟，过期时间在7~13分钟内波动，<u>有效防止都在同一个时间点上大量过期</u>。
3. 如果是热点数据在一台redis服务器上，也是极其危险的，如果网络有问题，或者redis服务器挂了，那么所有的热点数据也会雪崩（查询不到），因此**将热点数据打散分不到不同的机房中**，也可以有效减少这种情况。
4. 也可以**考虑双缓存的方式**，数据库数据同步到缓存A和B，A设置过期时间，B不设置过期时间，如果A为空的时候去读B，同时异步去更新缓存，但是更新的时候需要同时更新两个缓存。
5. **使用锁或队列**：用加锁或者队列的方式保证来保证不会有大量的线程对数据库一次性进行读写，从而避免失效时大量的并发请求落到底层存储系统上。不适用高并发情况



### 4）分布式锁

Redis分布式锁是一种在分布式系统中实现互斥访问共享资源的机制。在Redis中，我们可以使用一些特定的命令来实现分布式锁，例如`SETNX`、`EXPIRE`、`DEL`等。

以下是Redis分布式锁的基本工作原理：

1. **加锁**：客户端使用`SETNX`命令尝试设置一个锁。如果这个锁不存在，那么`SETNX`命令会成功，并返回1，表示客户端成功获取了锁。如果这个锁已经存在，那么`SETNX`命令会失败，并返回0，表示锁已经被其他客户端持有。
2. **设置过期时间**：为了防止死锁，我们通常会为锁设置一个过期时间。这可以通过Redis的`EXPIRE`命令来实现。如果客户端在持有锁的期间崩溃而没有主动解锁，那么当过期时间到达后，Redis会自动删除这个锁，从而允许其他客户端获取锁。
3. **解锁**：当客户端完成对共享资源的操作后，它需要使用`DEL`命令来删除这个锁，从而允许其他客户端获取锁。

需要注意的是，由于网络延迟和客户端崩溃等问题，Redis分布式锁可能会有一些潜在的问题。例如，一个客户端可能在执行`SETNX`和`EXPIRE`命令之间崩溃，导致一个永不过期的死锁。为了解决这个问题，Redis 2.6.12版本开始引入了一种新的加锁模式：通过一条命令（`SET key value NX PX milliseconds`）**同时设置值、过期时间和加锁。**

此外，还有一些开源库（如Redlock和Redission）提供了更高级的Redis分布式锁功能，例如阻塞等待、自动续租、公平锁等。

![](C:\Users\86180\Desktop\picPick\137.png)



#### 防止锁被误释放

上锁时设置UUID，解锁时需要验证uuid是否一致

```java
@Autowired
private RedisTemplate redisTemplate;

public void testLock(){
  //获取uuid
  String uuid = UUID.randomUUID().toString();

  //1获取锁，setnx
  Boolean lock = redisTemplate.opsForValue().setIfAbsent("lock", uuid,10L, TimeUnit.SECONDS);
  //2获取锁成功、查询num的值
  if(lock){
    Object value = redisTemplate.opsForValue().get("num");
    //2.1判断num为空return
    if(StringUtils.isEmpty(value)){
      return;
    }
    //2.2有值就转成成int
    int num = Integer.parseInt(value+"");
    //2.3把redis的num加1
    redisTemplate.opsForValue().set("num", ++num);
    //2.4释放锁，del
    //验证uuid
    String lockUuid = redisTemplate.opsForValue().get("lock").toString();
    if(uuid.equals(lockUuid)){
      redisTemplate.delete("lock");
    }
  }else{
    //3获取锁失败、每隔0.1秒再获取
    try {
      Thread.sleep(100);
      testLock();
    } catch (InterruptedException e) {
      e.printStackTrace();
    }
  }
}
```



#### 保证删除锁的原子性

使用lua脚本来保证。

> Lua是一种轻量级的脚本语言，由巴西里约热内卢天主教大学的一个研究小组于1993年开发。它用标准C语言编写并以源代码形式开放，设计目的是为了嵌入应用程序中，从而为应用程序提供灵活的扩展和定制功能。
>
> Lua的特性包括：
>
> - **轻量级**：它用标准C语言编写并以源代码形式开放，编译后仅仅一百余K，可以很方便地嵌入别的程序里。
> - **可扩展**：Lua提供了非常易于使用的扩展接口和机制：由宿主语言 (通常是C或C++)提供这些功能，Lua可以使用它们，就像是本来就内置的功能一样。
> - **支持面向过程和函数式编程**：Lua同时支持面向过程编程和函数式编程。
> - **自动内存管理**：Lua有自动内存管理机制。
> - **提供多线程支持**：Lua通过协同进程提供多线程支持。
>
> Lua被广泛应用于游戏开发、独立应用脚本、Web应用脚本、扩展和数据库插件等领域。例如，很多游戏会使用Lua脚本来实现某些功能，因为Lua脚本可以嵌入到其他程序中运行，游戏升级的时候，可以直接升级脚本，而不用重新安装游戏。



> 在Redis中，你可以使用Lua脚本来执行一些自定义的操作。以下是一些基本步骤：
>
> 1. **编写Lua脚本**：首先，你需要使用Lua语言来编写一个或多个Redis命令，并将它们保存为一个.lua文件。例如，你可以编写一个脚本，如`redis.call('SET', KEYS, ARGV)`。
> 2. **加载脚本**：然后，你可以使用`EVAL`或`EVALSHA`命令将脚本加载到Redis服务器中。这个命令会返回脚本的SHA1哈希值，你可以用这个哈希值来在以后的命令中引用这个脚本。
> 3. **执行脚本**：最后，你可以使用`EVAL`或`EVALSHA`命令来执行已经加载的脚本。在执行过程中，你可以向脚本传递一些参数，例如键名和值等。
>
> 例如，你可以使用以下命令来执行一个已经加载的脚本：
>
> ```shell
> EVALSHA sha1 1 key value
> ```
>
> 在这个命令中，`sha1`是你在加载脚本时得到的哈希值，`1`是键名的数量，`key`是键名，而`value`是要设置的值。

项目中使用：

定义key，key应该是为每个sku定义的，也就是每个sku有一把锁。

```java
String locKey ="lock:"+skuId; // 锁住的是每个商品的数据
Boolean lock = redisTemplate.opsForValue().setIfAbsent(locKey, uuid,3,TimeUnit.SECONDS);
```

```java
/*使用lua脚本来锁*/
// 定义lua 脚本
String script = "if redis.call('get', KEYS[1]) == ARGV[1] then return redis.call('del', KEYS[1]) else return 0 end";
// 使用redis执行lua执行
DefaultRedisScript<Long> redisScript = new DefaultRedisScript<>();
redisScript.setScriptText(script);
// 设置一下返回值类型 为Long
// 因为删除判断的时候，返回的0,给其封装为数据类型。如果不封装那么默认返回String 类型，
// 那么返回字符串与0 会有发生错误。
redisScript.setResultType(Long.class);
// 第一个要是script 脚本 ，第二个需要判断的key，第三个就是key所对应的值。
redisTemplate.execute(redisScript, Arrays.asList(locKey), uuid);
```

![](C:\Users\86180\Desktop\picPick\138.png)



#### 注意

为了确保分布式锁可用，至少要确保锁的实现同时满足以下四个条件：

* **互斥性**：在任意时刻，只有一个客户端能持有锁。
* **不会发生死锁**：即使有一个客户端在持有锁的期间崩溃而没有主动解锁，也能保证后续其他客户端能加锁。
* **解铃还须系铃人**：加锁和解锁必须是同一个客户端，客户端自己不能把别人加的锁给解了。
* **加锁和解锁必须具有原子性**。

