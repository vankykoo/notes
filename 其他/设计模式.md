# 设计模式

## 一、七大设计原则

### 1.**开放-封闭原则 (Open-Closed Principle, OCP)**

- 原则描述：软件实体（类、模块、函数等）应当**对扩展开放，对修改关闭**。也就是说，当需求变化时，应尽量通过添加新代码来实现功能增强，而不是修改现有的代码。
- 举例：在开发图形库时，如果需要支持多种形状的绘制，可以创建一个抽象的`Shape`接口，并为每种形状（如`Circle`、`Rectangle`）提供具体实现类。当要增加新的形状时，只需新增一个遵循`Shape`接口的类即可，无需修改已有代码。



### 2.**单一职责原则 (Single Responsibility Principle, SRP)**

- 原则描述：一个类或模块应该有且仅有一个改变它的原因。简单来说，每个类都应该专注于做一件事，并把它做好。
- 举例：在员工管理系统中，`Employee`类只负责处理与员工基本信息相关的操作，而薪资计算的功能则由另一个`SalaryCalculator`类负责，这样修改员工信息不会影响到薪资计算逻辑，反之亦然。



### 3.**里氏替换原则 (Liskov Substitution Principle, LSP)**

- 原则描述：子类型必须能够替换它们的基类型。即继承体系中的子类在父类出现的地方能够无二义性地替代父类工作，而不改变程序正确性。
- 举例：假设有一个`Shape`基类和派生出的`Square`子类，`Square`是一个特殊的`Rectangle`，但在使用`Shape`的地方，无论传入的是`Rectangle`还是`Square`，都能正常执行面积计算等方法，而不会因多态调用产生错误结果。



### 4.**依赖倒置原则 (Dependency Inversion Principle, DIP)**

- 原则描述：高层模块不应该依赖于低层模块，两者都应依赖于抽象。抽象不应依赖于细节，细节应依赖于抽象。
- 举例：在应用程序中，控制器类（高层模块）不直接依赖于数据库访问类（低层模块），而是共同依赖于一个数据访问接口（抽象）。这样，在更换数据库技术时，只需重新实现接口，而不用修改控制器。



### 5.**接口隔离原则 (Interface Segregation Principle, ISP)**

- 原则描述：客户端不应该被迫依赖它不需要的方法。接口应该小而专，每个接口代表一种独立的角色或职责。
- 举例：一个大的`UserService`接口可以拆分为更细粒度的`UserAuthentication`, `UserProfileManagement`, `UserPermissionControl`等接口，各个组件根据实际需求选择合适的接口进行依赖，避免接口方法的冗余和浪费。



### 6.**合成/聚合复用原则 (Composition/Aggregate Reuse Principle, CRP)**

- 原则描述：优先使用组合或者聚合关系而非继承来达到复用的目的。换句话说，尽量使用“拥有”关系（包含实例）而不是“是”关系（继承）来复用行为。
- 举例：在构建一个系统时，可以创建一个`Car`类，其中包含多个部件对象（如`Engine`、`Wheel`等），而不是让`Car`从这些部件继承。这样，部件的变化不会直接影响到`Car`类，增强了系统的灵活性。





### 7.**迪米特法则 (Law of Demeter, LoD)**

- 原则描述：也称为最少知识原则，即一个对象应当尽可能少地了解其他对象。一个对象只需要知道与其直接交互的对象即可。
- 举例：在一个订单系统中，`Order`类只需与`Customer`类交互获取必要的信息，而不直接访问`Customer`的地址信息，而是通过`Customer.getAddress()`间接获取，这样**减少了对象之间的耦合度**。





## 二、UML类图

UML类图（Unified Modeling Language Class Diagram）是面向对象分析与设计中最为常用的图形化建模工具之一，它主要用于描述系统的静态结构。在UML类图中，主要元素包括类、接口以及它们之间的关系。下面是一些关键概念和组成部分：

1. **类（Class）**：
   - 类名：通常以粗体表示，在顶部书写。
   - 属性（Attributes）：类的成员变量或数据字段，描述类所拥有的状态信息，一般在类名称下方列出，并可标注可见性（+公共、-私有、#保护）和其他属性如数据类型、初始值等。
   - 操作（Operations）：类的方法或行为，位于类定义的底部，同样可以标记可见性和参数列表。

2. **关系（Relationships）**：
   - 继承（Inheritance）：用一个带空心三角形箭头的直线表示，**箭头指向基类，用于表示子类对父类的继承关系**。
   - 实现（Realization）：**类实现接口**时，使用虚线箭头，**箭头指向接口**，表示类实现了接口的所有方法。
   - 关联（Association）：用来**表示类之间的连接**，可以通过线条上的角色名和多重性（0..*, 1..*, 1, etc.）来详细说明关联关系。
   - 聚合（Aggregation）：特殊的关联关系，表示**整体与部分的关系**，通常通过空心菱形箭头表示（箭头从整体指向部分）。
   - 组合（Composition）：比聚合更强的关系，表示部分不能脱离整体存在，用实心菱形箭头表示。
   - 依赖（Dependency）：表示一种较弱的“使用”关系，即一个元素的变化可能会影响到另一个元素，用带箭头的虚线表示。

3. **接口（Interface）**：
   - 在类图中，接口被表示为类似于类的框，但通常会有特殊标记（比如在顶行画三条破折号），并只包含操作声明，不包含属性。

UML类图能够清晰地展示系统中的类结构及其相互间的静态联系，有助于设计者理解系统的组织架构，并作为文档支持后续的开发、维护工作。通过绘制类图，可以更直观地发现和解决设计问题，确保软件设计的一致性和完整性。





## 三、单例模式

### 零、介绍

①单例模式保证了系统内存中该类只存在一个对象，节省了系统资源，对于一些需要频繁创建销毁的对象，可以使用单例模式提高系统性能。

②当实例化一个单例类时，必须要记住使用相应的获取对象的方法，而不是使用new。

③使用场景：需要频繁创建和销毁的对象，创建对象时耗时过多或耗费资源过多，但又经常用到的对象；工具类对象，频繁访问数据库或文件的对象（数据源/session工厂）。





### 一、饿汉式（静态变量）

```java
package com.vanky.design.singleton.type1;

/**
 * @author vanky
 * @create 2024/3/17 15:29
 */
public class Singleton1 {

    public static void main(String[] args) {
        Singleton instance = Singleton.getInstance();
        Singleton instance1 = Singleton.getInstance();

        for (int i = 0; i < 10; i++){
            instance.print();
            instance1.print();
        }

        System.out.println(instance1 == instance);//true
    }

}


/**
 * 饿汉式（静态变量）：在类装载的时候就完成实例化。
 * 缺点：如果未用到这个实例，可能造成内存浪费
 */
class Singleton{

    private int num = 0;

    //1.构造器私有化，外部不能new
    private Singleton(){

    }

    //2.本类内部创建对象实例
    private final static Singleton instance = new Singleton();

    //3.提供一个公有的静态方法，返回实例对象
    public static Singleton getInstance(){
        return instance;
    }

    public void print(){
        System.out.println(this.num++);
    }
}
```





### 二、饿汉式（静态代码块）

```java
package com.vanky.design.singleton.type2;

/**
 * @author vanky
 * @create 2024/3/17 15:41
 */
public class Singleton2 {

    public static void main(String[] args) {
        Singleton instance = Singleton.getInstance();
        Singleton instance1 = Singleton.getInstance();

        System.out.println(instance1 == instance);//true
    }

}

/**
 * 饿汉式（静态代码块）
 */
class Singleton{
    //构造器私有化，外部不能new
    private Singleton(){

    }

    //本类内部创建对象实例
    private static Singleton instance;

    //静态代码块中创建单例对象
    static {
        instance = new Singleton();
    }

    //给外部提供一个获取实例对象的静态方法
    public static Singleton getInstance(){
        return instance;
    }
}
```





### 三、懒汉式（线程不安全）

```java
/**
 * 懒汉式（线程不安全）
 */
class Singleton{
    private static Singleton instance;

    private Singleton(){}

    public static Singleton getInstance(){
        if (instance == null){
            //多线程环境下，可能有多个线程进来实例化对象
            instance = new Singleton();
        }
        return instance;
    }
}
```





### 四、懒汉式（线程安全）

```java
/**
 * 懒汉式（线程安全）
 * 缺点：方法同步，效率低
 */
class Singleton{
    private static Singleton instance;

    private Singleton(){}

    //在原有的基础上，给方法加上同步关键字synchronized
    public static synchronized Singleton getInstance(){
        if (instance == null){
            instance = new Singleton();
        }
        return instance;
    }
}
```





### 五、懒汉式（双重检查）【推荐】

```java
/**
 * 懒汉式（双重检查）
 * 线程安全，同步方法，保证效率
 */
class Singleton{
 
    private static volatile Singleton instance;

    private Singleton(){}

    public static Singleton getInstance(){
        if (instance == null){  //第一层检查
            synchronized (Singleton.class){
                if (instance == null){  //第二次检查
                    instance = new Singleton();
                }
            }
        }

        return instance;
    }
}
```





### 六、懒汉式（静态内部类）【推荐】

```java
/**
 * 懒汉式（静态内部类）
 * 线程安全，利用静态内部类特点实现延迟加载，效率高
 * 
 * 1.在需要实例化时，调用getInstance方法才会装载SingletonInstance类，从而完成Singleton的实例化。
 * 2.类的静态属性只会在第一次加载类的时候初始化，JVM帮我们保证了线程的安全；
 */
class Singleton{

    //构造器私有化
    private Singleton(){}

    //静态内部类，有一个静态属性：Singleton
    private static class SingletonInstance{
        private static final Singleton INSTANCE = new Singleton();
    }

    //静态公有方法，直接返回SingletonInstance.INSTANCE
    public static synchronized Singleton getInstance(){
        return SingletonInstance.INSTANCE;
    }
}
```





### 七、枚举【推荐】

```java
/**
 * @author vanky
 * @create 2024/3/17 16:35
 */
public class Singleton7 {

    public static void main(String[] args) {
        Singleton instance = Singleton.INSTANCE;
        Singleton instance1 = Singleton.INSTANCE;

        System.out.println(instance1 == instance);//true
    }

}

enum Singleton{
    INSTANCE;

    public void run(){
        System.out.println("hello,world!");
    }
}
```

