# 设计模式

## 一、七大设计原则

### 1.**开放-封闭原则 (Open-Closed Principle, OCP)**

- 原则描述：软件实体（类、模块、函数等）应当**对扩展开放，对修改关闭**。也就是说，当需求变化时，应尽量通过添加新代码来实现功能增强，而不是修改现有的代码。
- 举例：在开发图形库时，如果需要支持多种形状的绘制，可以创建一个抽象的`Shape`接口，并为每种形状（如`Circle`、`Rectangle`）提供具体实现类。当要增加新的形状时，只需新增一个遵循`Shape`接口的类即可，无需修改已有代码。



### 2.**单一职责原则 (Single Responsibility Principle, SRP)**

- 原则描述：一个类或模块应该有且仅有一个改变它的原因。简单来说，每个类都应该专注于做一件事，并把它做好。
- 举例：在员工管理系统中，`Employee`类只负责处理与员工基本信息相关的操作，而薪资计算的功能则由另一个`SalaryCalculator`类负责，这样修改员工信息不会影响到薪资计算逻辑，反之亦然。



### 3.**里氏替换原则 (Liskov Substitution Principle, LSP)**

- 原则描述：子类型必须能够替换它们的基类型。即继承体系中的子类在父类出现的地方能够无二义性地替代父类工作，而不改变程序正确性。
- 举例：假设有一个`Shape`基类和派生出的`Square`子类，`Square`是一个特殊的`Rectangle`，但在使用`Shape`的地方，无论传入的是`Rectangle`还是`Square`，都能正常执行面积计算等方法，而不会因多态调用产生错误结果。



### 4.**依赖倒置原则 (Dependency Inversion Principle, DIP)**

- 原则描述：高层模块不应该依赖于低层模块，两者都应依赖于抽象。抽象不应依赖于细节，细节应依赖于抽象。
- 举例：在应用程序中，控制器类（高层模块）不直接依赖于数据库访问类（低层模块），而是共同依赖于一个数据访问接口（抽象）。这样，在更换数据库技术时，只需重新实现接口，而不用修改控制器。



### 5.**接口隔离原则 (Interface Segregation Principle, ISP)**

- 原则描述：客户端不应该被迫依赖它不需要的方法。接口应该小而专，每个接口代表一种独立的角色或职责。
- 举例：一个大的`UserService`接口可以拆分为更细粒度的`UserAuthentication`, `UserProfileManagement`, `UserPermissionControl`等接口，各个组件根据实际需求选择合适的接口进行依赖，避免接口方法的冗余和浪费。



### 6.**合成/聚合复用原则 (Composition/Aggregate Reuse Principle, CRP)**

- 原则描述：优先使用组合或者聚合关系而非继承来达到复用的目的。换句话说，尽量使用“拥有”关系（包含实例）而不是“是”关系（继承）来复用行为。
- 举例：在构建一个系统时，可以创建一个`Car`类，其中包含多个部件对象（如`Engine`、`Wheel`等），而不是让`Car`从这些部件继承。这样，部件的变化不会直接影响到`Car`类，增强了系统的灵活性。





### 7.**迪米特法则 (Law of Demeter, LoD)**

- 原则描述：也称为最少知识原则，即一个对象应当尽可能少地了解其他对象。一个对象只需要知道与其直接交互的对象即可。
- 举例：在一个订单系统中，`Order`类只需与`Customer`类交互获取必要的信息，而不直接访问`Customer`的地址信息，而是通过`Customer.getAddress()`间接获取，这样**减少了对象之间的耦合度**。





## 二、UML类图

UML类图（Unified Modeling Language Class Diagram）是面向对象分析与设计中最为常用的图形化建模工具之一，它主要用于描述系统的静态结构。在UML类图中，主要元素包括类、接口以及它们之间的关系。下面是一些关键概念和组成部分：

1. **类（Class）**：
   - 类名：通常以粗体表示，在顶部书写。
   - 属性（Attributes）：类的成员变量或数据字段，描述类所拥有的状态信息，一般在类名称下方列出，并可标注可见性（+公共、-私有、#保护）和其他属性如数据类型、初始值等。
   - 操作（Operations）：类的方法或行为，位于类定义的底部，同样可以标记可见性和参数列表。

2. **关系（Relationships）**：
   - 继承（Inheritance）：用一个带空心三角形箭头的直线表示，**箭头指向基类，用于表示子类对父类的继承关系**。
   - 实现（Realization）：**类实现接口**时，使用虚线箭头，**箭头指向接口**，表示类实现了接口的所有方法。
   - 关联（Association）：用来**表示类之间的连接**，可以通过线条上的角色名和多重性（0..*, 1..*, 1, etc.）来详细说明关联关系。
   - 聚合（Aggregation）：特殊的关联关系，表示**整体与部分的关系**，通常通过空心菱形箭头表示（箭头从整体指向部分）。
   - 组合（Composition）：比聚合更强的关系，表示部分不能脱离整体存在，用实心菱形箭头表示。
   - 依赖（Dependency）：表示一种较弱的“使用”关系，即一个元素的变化可能会影响到另一个元素，用带箭头的虚线表示。

3. **接口（Interface）**：
   - 在类图中，接口被表示为类似于类的框，但通常会有特殊标记（比如在顶行画三条破折号），并只包含操作声明，不包含属性。

UML类图能够清晰地展示系统中的类结构及其相互间的静态联系，有助于设计者理解系统的组织架构，并作为文档支持后续的开发、维护工作。通过绘制类图，可以更直观地发现和解决设计问题，确保软件设计的一致性和完整性。





## 三、单例模式

### 零、介绍

①单例模式保证了系统内存中该类只存在一个对象，节省了系统资源，对于一些需要频繁创建销毁的对象，可以使用单例模式提高系统性能。

②当实例化一个单例类时，必须要记住使用相应的获取对象的方法，而不是使用new。

③使用场景：需要频繁创建和销毁的对象，创建对象时耗时过多或耗费资源过多，但又经常用到的对象；工具类对象，频繁访问数据库或文件的对象（数据源/session工厂）。





### 一、饿汉式（静态变量）

```java
package com.vanky.design.singleton.type1;

/**
 * @author vanky
 * @create 2024/3/17 15:29
 */
public class Singleton1 {

    public static void main(String[] args) {
        Singleton instance = Singleton.getInstance();
        Singleton instance1 = Singleton.getInstance();

        for (int i = 0; i < 10; i++){
            instance.print();
            instance1.print();
        }

        System.out.println(instance1 == instance);//true
    }

}


/**
 * 饿汉式（静态变量）：在类装载的时候就完成实例化。
 * 缺点：如果未用到这个实例，可能造成内存浪费
 */
class Singleton{

    private int num = 0;

    //1.构造器私有化，外部不能new
    private Singleton(){

    }

    //2.本类内部创建对象实例
    private final static Singleton instance = new Singleton();

    //3.提供一个公有的静态方法，返回实例对象
    public static Singleton getInstance(){
        return instance;
    }

    public void print(){
        System.out.println(this.num++);
    }
}
```





### 二、饿汉式（静态代码块）

```java
package com.vanky.design.singleton.type2;

/**
 * @author vanky
 * @create 2024/3/17 15:41
 */
public class Singleton2 {

    public static void main(String[] args) {
        Singleton instance = Singleton.getInstance();
        Singleton instance1 = Singleton.getInstance();

        System.out.println(instance1 == instance);//true
    }

}

/**
 * 饿汉式（静态代码块）
 */
class Singleton{
    //构造器私有化，外部不能new
    private Singleton(){

    }

    //本类内部创建对象实例
    private static Singleton instance;

    //静态代码块中创建单例对象
    static {
        instance = new Singleton();
    }

    //给外部提供一个获取实例对象的静态方法
    public static Singleton getInstance(){
        return instance;
    }
}
```





### 三、懒汉式（线程不安全）

```java
/**
 * 懒汉式（线程不安全）
 */
class Singleton{
    private static Singleton instance;

    private Singleton(){}

    public static Singleton getInstance(){
        if (instance == null){
            //多线程环境下，可能有多个线程进来实例化对象
            instance = new Singleton();
        }
        return instance;
    }
}
```





### 四、懒汉式（线程安全）

```java
/**
 * 懒汉式（线程安全）
 * 缺点：方法同步，效率低
 */
class Singleton{
    private static Singleton instance;

    private Singleton(){}

    //在原有的基础上，给方法加上同步关键字synchronized
    public static synchronized Singleton getInstance(){
        if (instance == null){
            instance = new Singleton();
        }
        return instance;
    }
}
```





### 五、懒汉式（双重检查）【推荐】

```java
/**
 * 懒汉式（双重检查）
 * 线程安全，同步方法，保证效率
 */
class Singleton{
 
    private static volatile Singleton instance;

    private Singleton(){}

    public static Singleton getInstance(){
        if (instance == null){  //第一层检查
            synchronized (Singleton.class){
                if (instance == null){  //第二次检查
                    instance = new Singleton();
                }
            }
        }

        return instance;
    }
}
```





### 六、懒汉式（静态内部类）【推荐】

```java
/**
 * 懒汉式（静态内部类）
 * 线程安全，利用静态内部类特点实现延迟加载，效率高
 * 
 * 1.在需要实例化时，调用getInstance方法才会装载SingletonInstance类，从而完成Singleton的实例化。
 * 2.类的静态属性只会在第一次加载类的时候初始化，JVM帮我们保证了线程的安全；
 */
class Singleton{

    //构造器私有化
    private Singleton(){}

    //静态内部类，有一个静态属性：Singleton
    private static class SingletonInstance{
        private static final Singleton INSTANCE = new Singleton();
    }

    //静态公有方法，直接返回SingletonInstance.INSTANCE
    public static synchronized Singleton getInstance(){
        return SingletonInstance.INSTANCE;
    }
}
```





### 七、枚举【推荐】

```java
/**
 * @author vanky
 * @create 2024/3/17 16:35
 */
public class Singleton7 {

    public static void main(String[] args) {
        Singleton instance = Singleton.INSTANCE;
        Singleton instance1 = Singleton.INSTANCE;

        System.out.println(instance1 == instance);//true
    }

}

enum Singleton{
    INSTANCE;

    public void run(){
        System.out.println("hello,world!");
    }
}
```





## 四、工厂模式

### 零、介绍

1.  意义：将实例化对象的代码提取出来，放到一个类中统一管理和维护，达到和主项目的依赖关系的解耦。
2.  三种工厂模式：简单工厂模式、工厂方法模式、抽象工厂模式
3.  设计模式的依赖抽象原则：
   * 创建对象实例时，不要直接new类，而是把这个new类的动作放在一个工厂的方法中，并返回。（变量不要直接持有具体类的引用）
   * 不用让类继承具体类，而是继承抽象类或是实现接口。
   * 不用覆盖基类中已经实现的方法。



### 一、简单工厂模式

简单工厂模式是一种**创建型设计模式**，它提供了一个统一的接口用于创建对象，而实际实例化哪一个类的工作则由这个工厂类决定。在简单工厂中，客户端不需要知道如何创建一个具体的对象，而是直接调用工厂提供的**静态方法**来获取所需的对象。

**（1）简单工厂模式的角色和结构：**

1. **工厂类（Factory）**：
   - 这个类负责生产具体的产品对象。
   - 通常包含一个静态方法，根据传入的参数（如类型标识符或配置信息）判断应该创建哪个具体产品的实例。
   - 它隐藏了产品类的具体实现细节，并负责管理对象的创建过程。

2. **抽象产品类（Abstract Product）**：
   - 定义所有具体产品需要实现的公共接口或者抽象方法，这些方法是客户使用产品的入口点。

3. **具体产品类（Concrete Product）**：
   - 实现了抽象产品类所定义的接口，每个具体产品都对应一种特定的产品对象。

**（2）简单工厂模式的流程：**
- 客户端请求一个产品对象时，不直接实例化具体产品类，而是通过调用工厂类的静态方法传递相应的参数。
- 工厂类根据参数值决定应该实例化哪个具体产品类，并返回该产品的实例给客户端。
- 客户端拿到的是抽象产品类型的引用，这样可以针对抽象类型编程，符合“依赖倒置原则”和“开闭原则”。

**（3）优缺点：**
- **优点**：
    - 将对象的创建与使用分离，简化了客户端代码，无需了解产品的具体实现。
    - 避免了客户端直接接触具体产品类，方便修改和扩展产品结构。
- **缺点**：
    - 当新增产品类型时，可能需要修改工厂类的逻辑，违反了“开闭原则”，即对扩展开放、对修改关闭的原则。
    - 如果产品族过于庞大，工厂类可能会变得复杂且难以维护。

简单工厂模式虽然被称为“工厂模式”，但严格来说，它并不属于GOF（四人帮）所提出的23种经典设计模式之一。后续的工厂方法模式和抽象工厂模式则是更符合“开闭原则”的工厂模式实现方式。



### 二、工厂方法模式

工厂方法模式（Factory Method Pattern）是一种创建型设计模式，它在面向对象编程中用于将对象的创建过程封装在对应的工厂类中，并且通过定义一个接口来让子类决定实例化哪一个类。该模式的主要目的是为了将对象的创建与使用分离，并且使得系统更容易扩展新的产品类型。

**结构与角色：**

1. **抽象工厂（Abstract Factory）**：
   - 定义了一个创建产品对象的公共接口，声明一个创建产品的工厂方法（factory method），通常是抽象方法。

2. **具体工厂（Concrete Factory）**：
   - 是抽象工厂的一个实现，每个具体工厂对应一种产品类型，负责生产相应的产品对象。
   - 具体工厂实现了抽象工厂中定义的工厂方法，返回的是具体产品类型的实例。

3. **抽象产品（Abstract Product）**：
   - 定义了所有具体产品共有的接口或者抽象类，是工厂方法所返回的对象类型。

4. **具体产品（Concrete Product）**：
   - 实现了抽象产品接口的具体类，代表了某种特定的产品对象。

**工作流程：**
- 客户端请求创建一个产品对象时，不是直接创建产品对象，而是通过调用具体工厂的工厂方法。
- 具体工厂根据客户端的需求选择并创建适当的具体产品对象。
- 客户端只依赖于抽象产品，无需了解实际创建和返回的产品对象的具体类型，这样增加了系统的灵活性和可扩展性。

**优点：**
- 符合开闭原则，即对扩展开放，对修改关闭。增加新产品时，只需要新增一个具体产品类和相应的具体工厂即可，无需修改已有代码。
- 把对象的创建过程集中管理，降低了模块间的耦合度，提高了代码的可复用性和可维护性。

**缺点：**
- 如果产品种类过多，会导致类的数目剧增，进而增加系统的复杂性。
- 工厂方法通常需要与if-else或switch-case等逻辑判断配合使用，以决定创建哪种具体产品，这可能导致工厂类变得庞大而难以维护。

例如，在Java中，假设有一个`PizzaStore`抽象工厂，它有一个工厂方法`createPizza(String type)`，不同的具体工厂如`ChicagoPizzaStore`和`NYPizzaStore`会根据传入的披萨类型字符串来创建不同口味的`Pizza`对象。





### 三、抽象工厂模式

抽象工厂模式（Abstract Factory Pattern）是一种创建型设计模式，它提供了一种方式来封装一组相关或相互依赖对象的创建过程，而不暴露具体的实现细节。这种模式的核心是为了解决一个系统中可能存在的多个产品族（即相关的产品系列）的问题，允许客户端在不指定具体产品类的情况下创建并使用这些产品的家族。

**结构与角色：**

1. **抽象工厂（Abstract Factory）**：
   - 定义了创建产品家族的一组接口，每个接口用于创建一种特定类型的产品。
   - 抽象工厂通常包含一系列创建方法，对应于不同产品族中的各个产品系列。

2. **具体工厂（Concrete Factory）**：
   - 实现了抽象工厂接口，负责生产某个产品家族的具体产品实例。
   - 每个具体工厂对应一个特定的产品族，根据需要创建该产品族内的不同产品。

3. **抽象产品（Abstract Product）**：
   - 定义了产品家族中每类产品所共有的接口或者抽象类。
   - 例如，如果有一个汽车产品族，抽象产品可能是“引擎”和“轮胎”，它们都有各自的抽象接口。

4. **具体产品（Concrete Product）**：
   - 是抽象产品的实现类，代表了实际可以使用的、具有特定属性的产品对象。
   - 在上述汽车产品族的例子中，具体产品可以是“涡轮增压引擎”、“电动汽车引擎”、“夏季高性能轮胎”等。

**工作流程：**
- 客户端请求创建一个产品家族时，不是直接创建产品对象，而是通过调用具体工厂的方法获取这个家族下的产品。
- 具体工厂根据请求生成相应产品家族中的具体产品实例，并将它们组合在一起。
- 客户端通过抽象产品接口与产品交互，无需知道实际的产品实现细节。

**优点：**
- 隔离了高层模块与底层实现之间的耦合度，使得更换整个产品族变得容易，只需要改变具体工厂即可。
- 支持产品族的扩展，增加新的产品族时只需新增相应的具体工厂和具体产品，原有代码不受影响。
- 保证了各产品对象间的兼容性，因为它们都是由同一个工厂创建的，符合一致的设计原则。

**缺点：**
- 当产品族中的产品数量增加时，会增加系统的复杂性和维护成本。
- 如果新添加的产品和现有产品不遵循原有的产品族划分规则，抽象工厂就难以适应这样的变化。

在Java或其他面向对象编程语言中，抽象工厂模式常被应用于图形用户界面库（GUI库），如按钮、文本框等组件的创建；数据库驱动程序，以支持多种数据库类型的连接；或者是不同风格的外观主题切换等场景。





## 五、原型模式

### 零、介绍

设计模式中的原型模式是一种创建型设计模式，它提供了一种通过复制现有对象（即原型）来创建新对象的方法。在原型模式中，一个对象可以创建其自身的一个副本而不依赖于特定的类构造器函数或者使用new操作符等传统的创建方式。这种模式适用于当直接实例化对象耗时或复杂，尤其是需要多次创建相似或相同状态的对象时。

原型模式的核心角色包括：

1. **抽象原型（Prototype）接口**：定义了克隆自身的操作，通常是一个`clone()`方法。所有具体原型类都必须实现这个接口。

2. **具体原型（Concrete Prototype）类**：实现了抽象原型接口的类，包含将自身深度或浅度拷贝的具体实现。这意味着当调用`clone()`方法时，会创建并返回当前对象的一个复制品。

使用原型模式的优点有：
- 提高性能：通过复用已有的对象结构来减少创建对象的时间和内存开销。
- 简化对象创建过程：客户端不需要知道如何创建复杂对象的内部结构，只需从原型中获取一个拷贝即可。
- 支持动态创建具有相同或部分相同状态的对象。

需要注意的是，在Java等语言中，实现原型模式时通常需要用到对象拷贝技术。拷贝分为两种类型：
- 浅拷贝（Shallow Copy）：只复制对象本身以及其中值类型的成员变量，对于引用类型成员，仅复制引用，不复制引用指向的对象内容。
- 深拷贝（Deep Copy）：不仅复制对象本身，还递归地复制所有引用类型成员所指向的对象，从而保证原对象与克隆对象之间的独立性。



### 一、克隆羊

```java
//需要实现Cloneable接口
public class Sheep implements Cloneable{
    private int age;
    private String name;
    private String color = "白色";

    public Sheep(int age, String name) {
        this.age = age;
        this.name = name;
    }

    @Override
    public String toString() {
        return "Sheep{" +
                "age=" + age +
                ", name='" + name + '\'' +
                ", color='" + color + '\'' +
                '}';
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    @Override
    protected Object clone(){

        Sheep sheep = null;
        try{
            sheep = (Sheep)super.clone();
        }catch (Exception e){
            System.out.println(e.getMessage());
        }

        return sheep;
    }
}
```

```java
public class CloneSheep {

    public static void main(String[] args) throws CloneNotSupportedException {
        Sheep sheep = new Sheep(18, "肖恩");
        Sheep sheep1 = (Sheep) sheep.clone();
        Sheep sheep2 = (Sheep) sheep.clone();
        Sheep sheep3 = (Sheep) sheep.clone();
        Sheep sheep4 = (Sheep) sheep.clone();
        Sheep sheep5 = (Sheep) sheep.clone();

        System.out.println(sheep1);
        System.out.println(sheep2);
        System.out.println(sheep3);
        System.out.println(sheep4);
        System.out.println(sheep5);
    }

}
```



### 二、深拷贝

```java
public class DeepCloneableTarget implements Serializable,Cloneable {

    @Override
    protected Object clone() throws CloneNotSupportedException {
        return super.clone();
    }
}
```



```java
public class DeepProtoType implements Serializable, Cloneable {

    public String name;
    public DeepCloneableTarget deepCloneableTarget;
    public DeepProtoType(){
        super();
    }

    /**
     * 方式一
     */
    @Override
    protected Object clone() throws CloneNotSupportedException {
        //完成对基本数据的克隆
        DeepProtoType deepProtoType = (DeepProtoType) super.clone();
        //单独处理引用类型属性
        deepProtoType.deepCloneableTarget = (DeepCloneableTarget) deepCloneableTarget.clone();

        return deepProtoType;
    }

    /**
     * 方式2
     */
    public Object deepClone(){
        //创建流对象
        ByteArrayOutputStream bos = null;
        ObjectOutputStream oos = null;
        ByteArrayInputStream bis = null;
        ObjectInputStream ois = null;

        try{
            //序列化
            bos = new ByteArrayOutputStream();
            oos = new ObjectOutputStream(bos);
            oos.writeObject(this);

            //反序列化
            bis = new ByteArrayInputStream(bos.toByteArray());
            ois = new ObjectInputStream(bis);
            DeepProtoType deepProtoType = (DeepProtoType) ois.readObject();

            return deepProtoType;
        }catch (Exception e){
            System.out.println(e.getMessage());
            return null;
        }

    }
}
```



## 六、建造者模式

### 零、介绍

设计模式中的**建造者模式（Builder Pattern）**是一种创建型设计模式，主要用于解决复杂对象的构建问题。它的核心目的是将一个复杂的对象的构造过程与它的表示（或结果）分离，使得同样的构建过程可以创建不同的表现形式的产品对象。

在建造者模式中，通常包含以下几个关键角色：

1. **抽象建造者（Builder）**：定义了创建产品的各个步骤的接口，并且一般会有一个方法来返回最终的产品。

2. **具体建造者（Concrete Builder）**：实现了抽象建造者的接口，每个具体建造者都负责实现构建过程的一个具体版本，提供指定类型的复杂对象的构造细节。

3. **产品（Product）**：是建造者需要创建的对象的接口或抽象类，它定义了产品的共性属性和方法。

4. **导演者（Director）**（可选角色）：负责安排建造流程，调用具体建造者的相关方法来一步步构造产品，但不涉及具体的构造细节。

通过使用建造者模式，我们可以有以下优点：
- 封装性良好，客户端只需知道建造者的接口，而不必了解内部的具体构造逻辑。
- 面向对象的设计原则之一——单一职责原则得到体现，每个建造者只负责创建对象的一部分。
- 可以按照步骤逐步创建对象，能够很好地应对构造过程较为复杂的场景。
- 便于控制构造过程，支持不同层次的产品配置和定制化。
- 提高代码可读性和可维护性，因为复杂构造过程被分离开来。

例如，在实际应用中，建造者模式可用于构建如XML文档、复杂的数据库查询、配置文件、汽车、电脑配置等具有多个部件组成，且这些部件有不同的组合方式以生成不同形态或配置的产品对象。



### 一、代码

####①抽象建造者（Builder）

```java
/**
 * 抽象建造者Builder
 */
public abstract class HouseBuilder {

    protected House house = new House();

    //抽象方法
    public abstract void buildBasic();
    public abstract void buildWalls();
    public abstract void roofed();

    public House buildHouse() {
        return house;
    }
}
```



#### ②具体建造者

```java
/**
 * 具体建造者：Concrete Builder
 */
public class CommonHouse extends HouseBuilder{
    @Override
    public void buildBasic() {
        System.out.println("CommonHouse 打地基");
    }

    @Override
    public void buildWalls() {
        System.out.println("CommonHouse 砌墙");
    }

    @Override
    public void roofed() {
        System.out.println("CommonHouse 封顶");
    }
}
```



#### ③产品

```java
/**
 * 产品product
 */
public class House {

    private String basic;
    private String walls;
    private String roof;

    public String getBasic() {
        return basic;
    }

    public void setBasic(String basic) {
        this.basic = basic;
    }

    public String getWalls() {
        return walls;
    }

    public void setWalls(String walls) {
        this.walls = walls;
    }

    public String getRoof() {
        return roof;
    }

    public void setRoof(String roof) {
        this.roof = roof;
    }
}
```



#### ④导演者

```java
/**
 * 导演者：Director
 */
public class HouseDirector {

    //聚合
    HouseBuilder houseBuilder;

    //传入方法一：构造器
    public HouseDirector(HouseBuilder houseBuilder){
        this.houseBuilder = houseBuilder;
    }

    //传入方法二：setter方法
    public void setHouseBuilder(HouseBuilder houseBuilder) {
        this.houseBuilder = houseBuilder;
    }

    public House constructHouse(){
        houseBuilder.buildBasic();
        houseBuilder.buildWalls();
        houseBuilder.roofed();

        return houseBuilder.buildHouse();
    }
}
```



## 七、适配器模式

### 零、介绍

设计模式中的适配器模式（Adapter Pattern）是一种结构型设计模式，主要用于解决接口不兼容的问题，使原本因接口不同而不能直接协作的类能够协同工作。适配器模式的核心思想是将一个接口转换为另一个接口，以符合客户端的期望，这样即使目标接口和原接口不匹配，也能通过适配器进行间接交互。

适配器模式的基本组成部分包括：

1. **Target**（目标接口）：这是客户所期待的接口，定义了客户端需要的方法。
2. **Adaptee**（被适配者）：这是已经存在的接口或类，拥有功能但接口不符合目标接口的需求。
3. **Adapter**（适配器）：适配器类实现了目标接口，并在其内部持有对被适配者的引用，负责将目标接口的方法调用转化为对被适配者相应方法的调用。

适配器模式有两种常见的实现方式：

- **类适配器**：通过继承来实现适配，适配器类继承自`Adaptee`并实现`Target`接口，在适配器类中重写`Target`接口方法，调用`Adaptee`的原有方法。

- **对象适配器**：通过组合来实现适配，适配器类包含一个`Adaptee`对象的引用，同时实现`Target`接口，并在实现的目标接口方法中委托给`Adaptee`对象的方法。 

适配器模式的主要优点包括：
- 允许在不修改原有代码的基础上复用已有类。
- 提高系统的灵活性，可连接不同的类，减少耦合度。
- 解决旧接口与新接口之间的兼容性问题。

实际应用中，适配器模式常用于处理API的变化、第三方库接口的整合以及系统组件间的协同工作等场景。



### 一、类适配器

目标：220v电压 ----》5v电压

```java
/**
 * 适配接口
 */
public interface IVoltage5V {

    /**
     * 输出5v电压
     * @return
     */
    int output5V();

}
```



```java
/**
 * 被适配者
 */
public class Voltage220V {

    public int output220V(){
        int src = 220;
        System.out.println("输出电压：" + src + " V");
        return src;
    }

}
```



```java
/**
 * 适配器
 */
public class VoltageAdapter extends Voltage220V implements IVoltage5V{
    @Override
    public int output5V() {
        int src = output220V();

        int des = src / 44; //转出5v输出

        return des;
    }
}
```



### 二、对象适配器

```java
/**
 * 适配器
 */
public class VoltageAdapter implements IVoltage5V {

    //使用组合替代继承
    private Voltage220V voltage220V;

    public VoltageAdapter(Voltage220V voltage220V) {
        this.voltage220V = voltage220V;
    }

    @Override
    public int output5V() {
        int src = voltage220V.output220V();

        int des = src / 44; //转出5v输出

        return des;
    }
}
```



### 三、接口适配器

```java
public interface MyInterface {

    void m1();

    void m2();

    void m3();

}
```



```java
/**
 * 抽象类实现接口，对接口方法进行空实现
 */
public abstract class AbsClass implements MyInterface{

    //空实现
    @Override
    public void m1() {

    }

    @Override
    public void m2() {

    }

    @Override
    public void m3() {

    }
}
```



```java
public class Client {

    public static void main(String[] args) {
        AbsClass absClass = new AbsClass(){
            /**
             * 重写需要使用到的方法即可
             */
            @Override
            public void m1(){
                System.out.println("使用了m1方法");
            }
        };

        absClass.m1();
    }

}
```



## 八、桥接模式

### 零、介绍

设计模式中的**桥接模式（Bridge Pattern）**是一种**结构型**设计模式，它的主要目的是将抽象部分与其实现部分分离，使它们可以独立地变化。在传统的继承关系中，当抽象类的实现需要多种变化维度时，容易导致类的爆炸性增长（即多个维度下的组合会导致大量的子类）。桥接模式通过引入抽象层和实现层两个独立的层次结构，以“组合”而非“继承”的方式来解耦抽象接口与具体实现，使得这两者可以在运行时动态绑定。

**模式的主要角色包括：**

1. **Abstraction（抽象类）**：
   定义了抽象接口，维护一个对Implementor对象的引用，并且它定义了一些操作，这些操作委托给Implementor完成。

2. **Refined Abstraction（改进的抽象类或子类）**：
   是Abstraction的一个扩展版本，它可以增加新的行为，同时仍然依赖Implementor进行实现细节。

3. **Implementor（实现接口或抽象类）**：
   定义了实现类需要实现的接口，它不依赖于Abstraction的具体实现，而是提供了具体的算法实现。

4. **Concrete Implementor（具体实现类）**：
   实现Implementor接口，提供不同类型的实现，而这些不同的实现可以在运行时被Abstraction对象灵活使用。

**桥接模式的优点：**
- 有效地解耦了抽象和实现，两者可以独立变化。
- 支持多维度的变化，避免了因为类爆炸而导致的设计复杂性。
- 提高了系统的可扩展性和灵活性，新增功能只需添加新类，不需要修改现有代码。

**应用场景：**
- 当系统需要在多个维度上进行变化时，例如GUI库中窗口组件和渲染引擎是两个独立变化的维度。
- 需要将抽象部分和实现部分分离，以便分别进行独立开发和复用时。
- 想要避免因大量具有特定功能的子类而导致类层次结构过于庞大和复杂的情况。



### 一、代码

![](https://raw.githubusercontent.com/vankykoo/image/main/cut/20240319165130.png)



```java
/**
 * 抽象接口Implementor
 */
public interface Brand {

    void open();

    void close();

    void call();

}
```

```java
/**
 * 抽象类Abstraction
 */
public abstract class Phone {
	//把接口聚合到抽象类中，抽象类可以调用接口的方法
    private Brand brand;

    public Phone(Brand brand) {
        this.brand = brand;
    }

    protected void open(){
        this.brand.open();
    }

    protected void close(){
        this.brand.close();
    }

    protected void call(){
        this.brand.call();
    }
}
```

```java
/**
 * 抽象类的子类1  Refined Abstraction
 */
public class UpRightPhone extends Phone {

    public UpRightPhone(Brand brand) {
        super(brand);
    }

    public void open() {
        super.open();
        System.out.println("直立手机");
    }

    public void close() {
        super.close();
        System.out.println("直立手机");
    }

    public void call() {
        super.call();
        System.out.println("直立手机");
    }

}

/**
 * 抽象类的子类2  Refined Abstraction
 */
public class FoldedPhone extends Phone{
    public FoldedPhone(Brand brand) {
        super(brand);
    }

    public void open(){
        super.open();
        System.out.println("折叠手机");
    }

    public void close(){
        super.close();
        System.out.println("折叠手机");
    }

    public void call(){
        super.call();
        System.out.println("折叠手机");
    }
}
```

```java
/**
 * 接口的实现类1   Concrete Implementor
 */
public class Vivo implements Brand{

    @Override
    public void open() {
        System.out.println("Vivo 开机");
    }

    @Override
    public void close() {
        System.out.println("Vivo 关机");
    }

    @Override
    public void call() {
        System.out.println("Vivo 打电话");
    }

}

/**
 * 接口的实现类2   Concrete Implementor
 */
public class XiaoMi implements Brand{
    @Override
    public void open() {
        System.out.println("XiaoMi 开机");
    }

    @Override
    public void close() {
        System.out.println("XiaoMi 关机");
    }

    @Override
    public void call() {
        System.out.println("XiaoMi 打电话");
    }
}
```

```java
/**
 * 使用
 */
public class Client {

    public static void main(String[] args) {
        FoldedPhone foldedPhone = new FoldedPhone(new Vivo());
        foldedPhone.open();
        foldedPhone.call();
        foldedPhone.close();

        UpRightPhone upRightPhone = new UpRightPhone(new XiaoMi());
        upRightPhone.open();
        upRightPhone.call();
        upRightPhone.close();
    }

}
```

